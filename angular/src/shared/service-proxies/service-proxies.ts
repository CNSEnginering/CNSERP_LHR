/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.3.1.0 (NJsonSchema v9.14.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import * as moment from 'moment';
import { BinaryData } from 'fs';
import { List } from 'lodash';
import { map } from "rxjs/operators";
import { url } from 'inspector';
import { ICurrencyRateHistoryDto, CurrencyRateHistoryDto } from '@app/main/commonServices/shared/dto/currencyRateHistory-dto';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
    * @return Success
    */
    getCompanyName(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Account/GetCompanyName";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCompanyName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyName(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
    /**
     * @param input (optional)
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AccountsPostingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxDetIDFilter (optional)
     * @param minDetIDFilter (optional)
     * @param bookIDFilter (optional)
     * @param maxConfigIDFilter (optional)
     * @param minConfigIDFilter (optional)
     * @param maxDocNoFilter (optional)
     * @param minDocNoFilter (optional)
     * @param maxDocMonthFilter (optional)
     * @param minDocMonthFilter (optional)
     * @param maxDocDateFilter (optional)
     * @param minDocDateFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditTimeFilter (optional)
     * @param minAuditTimeFilter (optional)
     * @param postedFilter (optional)
     * @param bookNameFilter (optional)
     * @param accountIDFilter (optional)
     * @param maxSubAccIDFilter (optional)
     * @param minSubAccIDFilter (optional)
     * @param narrationFilter (optional)
     * @param maxAmountFilter (optional)
     * @param minAmountFilter (optional)
     * @param accountNameFilter (optional)
     * @param subAccNameFilter (optional)
     * @param maxDetailIDFilter (optional)
     * @param minDetailIDFilter (optional)
     * @param chequeNoFilter (optional)
     * @param regNoFilter (optional)
     * @param referenceFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, maxDetIDFilter: number | null | undefined, minDetIDFilter: number | null | undefined, bookIDFilter: string | null | undefined, maxConfigIDFilter: number | null | undefined, minConfigIDFilter: number | null | undefined, maxDocNoFilter: number | null | undefined, minDocNoFilter: number | null | undefined, maxDocMonthFilter: number | null | undefined, minDocMonthFilter: number | null | undefined, maxDocDateFilter: moment.Moment | null | undefined, minDocDateFilter: moment.Moment | null | undefined, auditUserFilter: string | null | undefined, maxAuditTimeFilter: moment.Moment | null | undefined, minAuditTimeFilter: moment.Moment | null | undefined, postedFilter: number | null | undefined, bookNameFilter: string | null | undefined, accountIDFilter: string | null | undefined, maxSubAccIDFilter: number | null | undefined, minSubAccIDFilter: number | null | undefined, narrationFilter: string | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, accountNameFilter: string | null | undefined, subAccNameFilter: string | null | undefined, maxDetailIDFilter: number | null | undefined, minDetailIDFilter: number | null | undefined, chequeNoFilter: string | null | undefined, regNoFilter: string | null | undefined, referenceFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAccountsPostingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxDetIDFilter !== undefined)
            url_ += "MaxDetIDFilter=" + encodeURIComponent("" + maxDetIDFilter) + "&";
        if (minDetIDFilter !== undefined)
            url_ += "MinDetIDFilter=" + encodeURIComponent("" + minDetIDFilter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (maxConfigIDFilter !== undefined)
            url_ += "MaxConfigIDFilter=" + encodeURIComponent("" + maxConfigIDFilter) + "&";
        if (minConfigIDFilter !== undefined)
            url_ += "MinConfigIDFilter=" + encodeURIComponent("" + minConfigIDFilter) + "&";
        if (maxDocNoFilter !== undefined)
            url_ += "MaxDocNoFilter=" + encodeURIComponent("" + maxDocNoFilter) + "&";
        if (minDocNoFilter !== undefined)
            url_ += "MinDocNoFilter=" + encodeURIComponent("" + minDocNoFilter) + "&";
        if (maxDocMonthFilter !== undefined)
            url_ += "MaxDocMonthFilter=" + encodeURIComponent("" + maxDocMonthFilter) + "&";
        if (minDocMonthFilter !== undefined)
            url_ += "MinDocMonthFilter=" + encodeURIComponent("" + minDocMonthFilter) + "&";
        if (maxDocDateFilter !== undefined)
            url_ += "MaxDocDateFilter=" + encodeURIComponent(maxDocDateFilter ? "" + maxDocDateFilter.toJSON() : "") + "&";
        if (minDocDateFilter !== undefined)
            url_ += "MinDocDateFilter=" + encodeURIComponent(minDocDateFilter ? "" + minDocDateFilter.toJSON() : "") + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditTimeFilter !== undefined)
            url_ += "MaxAuditTimeFilter=" + encodeURIComponent(maxAuditTimeFilter ? "" + maxAuditTimeFilter.toJSON() : "") + "&";
        if (minAuditTimeFilter !== undefined)
            url_ += "MinAuditTimeFilter=" + encodeURIComponent(minAuditTimeFilter ? "" + minAuditTimeFilter.toJSON() : "") + "&";
        if (postedFilter !== undefined)
            url_ += "PostedFilter=" + encodeURIComponent("" + postedFilter) + "&";
        if (bookNameFilter !== undefined)
            url_ += "BookNameFilter=" + encodeURIComponent("" + bookNameFilter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (maxSubAccIDFilter !== undefined)
            url_ += "MaxSubAccIDFilter=" + encodeURIComponent("" + maxSubAccIDFilter) + "&";
        if (minSubAccIDFilter !== undefined)
            url_ += "MinSubAccIDFilter=" + encodeURIComponent("" + minSubAccIDFilter) + "&";
        if (narrationFilter !== undefined)
            url_ += "NarrationFilter=" + encodeURIComponent("" + narrationFilter) + "&";
        if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&";
        if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&";
        if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&";
        if (subAccNameFilter !== undefined)
            url_ += "SubAccNameFilter=" + encodeURIComponent("" + subAccNameFilter) + "&";
        if (maxDetailIDFilter !== undefined)
            url_ += "MaxDetailIDFilter=" + encodeURIComponent("" + maxDetailIDFilter) + "&";
        if (minDetailIDFilter !== undefined)
            url_ += "MinDetailIDFilter=" + encodeURIComponent("" + minDetailIDFilter) + "&";
        if (chequeNoFilter !== undefined)
            url_ += "ChequeNoFilter=" + encodeURIComponent("" + chequeNoFilter) + "&";
        if (regNoFilter !== undefined)
            url_ += "RegNoFilter=" + encodeURIComponent("" + regNoFilter) + "&";
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAccountsPostingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAccountsPostingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAccountsPostingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetAccountsPostingForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetAccountsPostingForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAccountsPostingForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAccountsPostingForView(id: number | null | undefined): Observable<GetAccountsPostingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/GetAccountsPostingForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountsPostingForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsPostingForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountsPostingForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountsPostingForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountsPostingForView(response: HttpResponseBase): Observable<GetAccountsPostingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAccountsPostingForViewDto.fromJS(resultData200) : new GetAccountsPostingForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountsPostingForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAccountsPostingForEdit(id: number | null | undefined): Observable<GetAccountsPostingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/GetAccountsPostingForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountsPostingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsPostingForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountsPostingForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountsPostingForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountsPostingForEdit(response: HttpResponseBase): Observable<GetAccountsPostingForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAccountsPostingForEditOutput.fromJS(resultData200) : new GetAccountsPostingForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountsPostingForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditAccountsPostingDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param mode (optional)
     * @param fromDoc (optional)
     * @param toDoc (optional)
     * @return Success
     */
    getDetailForAccountsPosting(fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, mode: string | null | undefined, fromDoc: number | null | undefined, toDoc: number | null | undefined): Observable<GetDetailForAccountsPostingDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/GetDetailForAccountsPosting?";
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (mode !== undefined)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        if (fromDoc !== undefined)
            url_ += "fromDoc=" + encodeURIComponent("" + fromDoc) + "&";
        if (toDoc !== undefined)
            url_ += "ToDoc=" + encodeURIComponent("" + toDoc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDetailForAccountsPosting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailForAccountsPosting(<any>response_);
                } catch (e) {
                    return <Observable<GetDetailForAccountsPostingDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDetailForAccountsPostingDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailForAccountsPosting(response: HttpResponseBase): Observable<GetDetailForAccountsPostingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetDetailForAccountsPostingDto.fromJS(resultData200) : new GetDetailForAccountsPostingDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDetailForAccountsPostingDto>(<any>null);
    }

    /**
     * @param users (optional)
     * @param books (optional)
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param mode (optional)
     * @param fromDoc (optional)
     * @param toDoc (optional)
     * @return Success
     */
    getAccountsPostingList(users: string[] | null | undefined, books: string[] | null | undefined, fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, mode: string | null | undefined, fromDoc: number | null | undefined, toDoc: number | null | undefined): Observable<AccountsPostingListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/getAccountsPostingList?";
        if (users !== undefined)
            users && users.forEach(item => { url_ += "users=" + encodeURIComponent("" + item) + "&"; });
        if (books !== undefined)
            books && books.forEach(item => { url_ += "books=" + encodeURIComponent("" + item) + "&"; });
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (mode !== undefined)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        if (fromDoc !== undefined)
            url_ += "fromDoc=" + encodeURIComponent("" + fromDoc) + "&";
        if (toDoc !== undefined)
            url_ += "ToDoc=" + encodeURIComponent("" + toDoc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountsPostingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsPostingList(<any>response_);
                } catch (e) {
                    return <Observable<AccountsPostingListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountsPostingListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountsPostingList(response: HttpResponseBase): Observable<AccountsPostingListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(AccountsPostingListDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountsPostingListDto[]>(<any>null);
    }

    /**
     * @param postedData (optional)
     * @param mode (optional)
     * @param bit (optional)
     * @return Success
     */
    postingData(postedData: number[] | null | undefined, mode: string | null | undefined, bit: boolean | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountsPostings/PostingData?";
        if (mode !== undefined)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        if (bit !== undefined)
            url_ += "bit=" + encodeURIComponent("" + bit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postedData);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPostingData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostingData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostingData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AccountSubLedgersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param accountIDFilter (optional)
     * @param subAccNameFilter (optional)
     * @param cityFilter (optional)
     * @param phoneFilter (optional)
     * @param contactFilter (optional)
     * @param regNoFilter (optional)
     * @param tAXAUTHFilter (optional)
     * @param chartofControlAccountNameFilter (optional)
     * @param taxAuthorityTAXAUTHDESCFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, accountIDFilter: string | null | undefined, subAccNameFilter: string | null | undefined, cityFilter: string | null | undefined, phoneFilter: string | null | undefined, contactFilter: string | null | undefined, regNoFilter: string | null | undefined, tAXAUTHFilter: string | null | undefined, chartofControlAccountNameFilter: string | null | undefined, taxAuthorityTAXAUTHDESCFilter: string | null | undefined,slType:string|null|undefined,slDesc:string|null|undefined,minSubAccIDFilter: number | null | undefined,maxSubAccIDFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAccountSubLedgerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (subAccNameFilter !== undefined)
            url_ += "SubAccNameFilter=" + encodeURIComponent("" + subAccNameFilter) + "&";
        if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (contactFilter !== undefined)
            url_ += "ContactFilter=" + encodeURIComponent("" + contactFilter) + "&";
        if (regNoFilter !== undefined)
            url_ += "RegNoFilter=" + encodeURIComponent("" + regNoFilter) + "&";
        if (tAXAUTHFilter !== undefined)
            url_ += "TAXAUTHFilter=" + encodeURIComponent("" + tAXAUTHFilter) + "&";
        if (chartofControlAccountNameFilter !== undefined)
            url_ += "ChartofControlAccountNameFilter=" + encodeURIComponent("" + chartofControlAccountNameFilter) + "&";
        if (taxAuthorityTAXAUTHDESCFilter !== undefined)
            url_ += "TaxAuthorityTAXAUTHDESCFilter=" + encodeURIComponent("" + taxAuthorityTAXAUTHDESCFilter) + "&";
        if (slType !== undefined)
            url_ += "slType=" + encodeURIComponent("" + slType) + "&";
        if (slDesc !== undefined)
            url_ += "slDesc=" + encodeURIComponent("" + slDesc) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (minSubAccIDFilter !== undefined && minSubAccIDFilter !== null)
            url_ += "MinSubAccIDFilter=" + encodeURIComponent("" + minSubAccIDFilter) + "&";
        if (maxSubAccIDFilter !== undefined && maxSubAccIDFilter !== null)
            url_ += "MaxSubAccIDFilter=" + encodeURIComponent("" + maxSubAccIDFilter) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAccountSubLedgerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAccountSubLedgerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAccountSubLedgerForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetAccountSubLedgerForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetAccountSubLedgerForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAccountSubLedgerForViewDto>(<any>null);
    }

    /**
    * @param fromAccountID
    * @param toAccountID
    * @return Success
    */
    transferSubledgers(fromAccountID: string | null | undefined, toAccountID: string | null | undefined): Observable<string> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/TransferSubledgers?";
        if (fromAccountID !== undefined)
            url_ += "fromAccountID=" + encodeURIComponent(fromAccountID ? "" + fromAccountID : "") + "&";
        if (toAccountID !== undefined)
            url_ += "toAccountID=" + encodeURIComponent(toAccountID ? "" + toAccountID : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processTransferSubledgers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTransferSubledgers(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTransferSubledgers(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAccountSubLedgerForView(id: number | null | undefined): Observable<GetAccountSubLedgerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAccountSubLedgerForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountSubLedgerForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountSubLedgerForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountSubLedgerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountSubLedgerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountSubLedgerForView(response: HttpResponseBase): Observable<GetAccountSubLedgerForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAccountSubLedgerForViewDto.fromJS(resultData200) : new GetAccountSubLedgerForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountSubLedgerForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @param accountID (optional)
     * @return Success
     */
    getAccountSubLedgerForEdit(id: number | null | undefined, accountID: string | null | undefined): Observable<GetAccountSubLedgerForEditOutput> {
     debugger;
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAccountSubLedgerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (accountID !== undefined)
            url_ += "AccountID=" + encodeURIComponent("" + accountID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountSubLedgerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountSubLedgerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountSubLedgerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountSubLedgerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountSubLedgerForEdit(response: HttpResponseBase): Observable<GetAccountSubLedgerForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAccountSubLedgerForEditOutput.fromJS(resultData200) : new GetAccountSubLedgerForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountSubLedgerForEditOutput>(<any>null);
    }

    /**
     * @param mode (optional)
     * @return Success
     */
    getAccountSubLedgerForCreate(mode: string | null | undefined): Observable<GetAccountSubLedgerForCreateOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAccountSubLedgerForCreate?";
        if (mode !== undefined)
            url_ += "Mode=" + encodeURIComponent("" + mode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountSubLedgerForCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountSubLedgerForCreate(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountSubLedgerForCreateOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountSubLedgerForCreateOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountSubLedgerForCreate(response: HttpResponseBase): Observable<GetAccountSubLedgerForCreateOutputDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAccountSubLedgerForCreateOutputDto.fromJS(resultData200) : new GetAccountSubLedgerForCreateOutputDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountSubLedgerForCreateOutputDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditAccountSubLedgerDto | null | undefined): Observable<void> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @param accountID (optional)
     * @return Success
     */
    delete(id: number | null | undefined, accountID: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (accountID !== undefined)
            url_ += "AccountID=" + encodeURIComponent("" + accountID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param accountIDFilter (optional)
     * @param subAccNameFilter (optional)
     * @param cityFilter (optional)
     * @param phoneFilter (optional)
     * @param contactFilter (optional)
     * @param regNoFilter (optional)
     * @param tAXAUTHFilter (optional)
     * @param chartofControlAccountNameFilter (optional)
     * @param taxAuthorityTAXAUTHDESCFilter (optional)
     * @return Success
     */
    getAccountSubLedgersToExcel(filter: string | null | undefined, accountIDFilter: string | null | undefined, subAccNameFilter: string | null | undefined, cityFilter: string | null | undefined, phoneFilter: string | null | undefined, contactFilter: string | null | undefined, regNoFilter: string | null | undefined, tAXAUTHFilter: string | null | undefined, chartofControlAccountNameFilter: string | null | undefined, taxAuthorityTAXAUTHDESCFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAccountSubLedgersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (subAccNameFilter !== undefined)
            url_ += "SubAccNameFilter=" + encodeURIComponent("" + subAccNameFilter) + "&";
        if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (contactFilter !== undefined)
            url_ += "ContactFilter=" + encodeURIComponent("" + contactFilter) + "&";
        if (regNoFilter !== undefined)
            url_ += "RegNoFilter=" + encodeURIComponent("" + regNoFilter) + "&";
        if (tAXAUTHFilter !== undefined)
            url_ += "TAXAUTHFilter=" + encodeURIComponent("" + tAXAUTHFilter) + "&";
        if (chartofControlAccountNameFilter !== undefined)
            url_ += "ChartofControlAccountNameFilter=" + encodeURIComponent("" + chartofControlAccountNameFilter) + "&";
        if (taxAuthorityTAXAUTHDESCFilter !== undefined)
            url_ += "TaxAuthorityTAXAUTHDESCFilter=" + encodeURIComponent("" + taxAuthorityTAXAUTHDESCFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountSubLedgersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountSubLedgersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountSubLedgersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllChartofControlForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAllChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllTaxAuthorityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAllTaxAuthorityForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTaxAuthorityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaxAuthorityForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaxAuthorityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    getAllTaxClassesForCombobox(input: string | null | undefined): Observable<ListResultDtoOfGetAllTaxClassesForCombobox> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAllTaxClassesForCombobox?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTaxClassesForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaxClassesForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetAllTaxClassesForCombobox>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetAllTaxClassesForCombobox>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaxClassesForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfGetAllTaxClassesForCombobox> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfGetAllTaxClassesForCombobox.fromJS(resultData200) : new ListResultDtoOfGetAllTaxClassesForCombobox();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetAllTaxClassesForCombobox>(<any>null);
    }

    /**
     * @param accountID (optional)
     * @return Success
     */
    maxid(accountID: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/Maxid?";
        if (accountID !== undefined)
            url_ += "AccountID=" + encodeURIComponent("" + accountID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMaxid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxid(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMaxid(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllAccountSubledger_lookup(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetAllAccountSubledger_lookup?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllAccountSubledger_lookup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountSubledger_lookup(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccountSubledger_lookup(response: HttpResponseBase): Observable<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto>(<any>null);
    }

    /**
     * @return Success
     */
    readexcel(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/readexcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processReadexcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReadexcel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReadexcel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getSalesTaxDesc(taxAuth: string): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/AccountSubLedgers/GetSalesTaxDesc?";
        if (taxAuth !== undefined)
            url_ += "taxAuth=" + encodeURIComponent("" + taxAuth) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processgetSalesTaxDesc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processgetSalesTaxDesc(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processgetSalesTaxDesc(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class APOptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param dEFBANKIDFilter (optional)
     * @param maxDEFPAYCODEFilter (optional)
     * @param minDEFPAYCODEFilter (optional)
     * @param dEFVENCTRLACCFilter (optional)
     * @param dEFCURRCODEFilter (optional)
     * @param pAYTERMSFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param currencyRateIdFilter (optional)
     * @param bankBANKIDFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, dEFBANKIDFilter: string | null | undefined, maxDEFPAYCODEFilter: number | null | undefined, minDEFPAYCODEFilter: number | null | undefined, dEFVENCTRLACCFilter: string | null | undefined, dEFCURRCODEFilter: string | null | undefined, pAYTERMSFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, currencyRateIdFilter: string | null | undefined, bankBANKIDFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAPOptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dEFBANKIDFilter !== undefined)
            url_ += "DEFBANKIDFilter=" + encodeURIComponent("" + dEFBANKIDFilter) + "&";
        if (maxDEFPAYCODEFilter !== undefined)
            url_ += "MaxDEFPAYCODEFilter=" + encodeURIComponent("" + maxDEFPAYCODEFilter) + "&";
        if (minDEFPAYCODEFilter !== undefined)
            url_ += "MinDEFPAYCODEFilter=" + encodeURIComponent("" + minDEFPAYCODEFilter) + "&";
        if (dEFVENCTRLACCFilter !== undefined)
            url_ += "DEFVENCTRLACCFilter=" + encodeURIComponent("" + dEFVENCTRLACCFilter) + "&";
        if (dEFCURRCODEFilter !== undefined)
            url_ += "DEFCURRCODEFilter=" + encodeURIComponent("" + dEFCURRCODEFilter) + "&";
        if (pAYTERMSFilter !== undefined)
            url_ += "PAYTERMSFilter=" + encodeURIComponent("" + pAYTERMSFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (currencyRateIdFilter !== undefined)
            url_ += "CurrencyRateIdFilter=" + encodeURIComponent("" + currencyRateIdFilter) + "&";
        if (bankBANKIDFilter !== undefined)
            url_ += "BankBANKIDFilter=" + encodeURIComponent("" + bankBANKIDFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAPOptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAPOptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAPOptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetAPOptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetAPOptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAPOptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAPOptionForView(id: number | null | undefined): Observable<GetAPOptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAPOptionForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAPOptionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPOptionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAPOptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAPOptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPOptionForView(response: HttpResponseBase): Observable<GetAPOptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAPOptionForViewDto.fromJS(resultData200) : new GetAPOptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAPOptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAPOptionForEdit(id: number | null | undefined): Observable<GetAPOptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAPOptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAPOptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPOptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAPOptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAPOptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPOptionForEdit(response: HttpResponseBase): Observable<GetAPOptionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAPOptionForEditOutput.fromJS(resultData200) : new GetAPOptionForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAPOptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditAPOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param dEFBANKIDFilter (optional)
     * @param maxDEFPAYCODEFilter (optional)
     * @param minDEFPAYCODEFilter (optional)
     * @param dEFVENCTRLACCFilter (optional)
     * @param dEFCURRCODEFilter (optional)
     * @param pAYTERMSFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param currencyRateIdFilter (optional)
     * @param bankBANKIDFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @return Success
     */
    getAPOptionsToExcel(filter: string | null | undefined, dEFBANKIDFilter: string | null | undefined, maxDEFPAYCODEFilter: number | null | undefined, minDEFPAYCODEFilter: number | null | undefined, dEFVENCTRLACCFilter: string | null | undefined, dEFCURRCODEFilter: string | null | undefined, pAYTERMSFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, currencyRateIdFilter: string | null | undefined, bankBANKIDFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAPOptionsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dEFBANKIDFilter !== undefined)
            url_ += "DEFBANKIDFilter=" + encodeURIComponent("" + dEFBANKIDFilter) + "&";
        if (maxDEFPAYCODEFilter !== undefined)
            url_ += "MaxDEFPAYCODEFilter=" + encodeURIComponent("" + maxDEFPAYCODEFilter) + "&";
        if (minDEFPAYCODEFilter !== undefined)
            url_ += "MinDEFPAYCODEFilter=" + encodeURIComponent("" + minDEFPAYCODEFilter) + "&";
        if (dEFVENCTRLACCFilter !== undefined)
            url_ += "DEFVENCTRLACCFilter=" + encodeURIComponent("" + dEFVENCTRLACCFilter) + "&";
        if (dEFCURRCODEFilter !== undefined)
            url_ += "DEFCURRCODEFilter=" + encodeURIComponent("" + dEFCURRCODEFilter) + "&";
        if (pAYTERMSFilter !== undefined)
            url_ += "PAYTERMSFilter=" + encodeURIComponent("" + pAYTERMSFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (currencyRateIdFilter !== undefined)
            url_ += "CurrencyRateIdFilter=" + encodeURIComponent("" + currencyRateIdFilter) + "&";
        if (bankBANKIDFilter !== undefined)
            url_ += "BankBANKIDFilter=" + encodeURIComponent("" + bankBANKIDFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAPOptionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPOptionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPOptionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllCurrencyRateForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAPOptionCurrencyRateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAllCurrencyRateForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllCurrencyRateForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyRateForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAPOptionCurrencyRateLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAPOptionCurrencyRateLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyRateForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAPOptionCurrencyRateLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAPOptionCurrencyRateLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAPOptionCurrencyRateLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAPOptionCurrencyRateLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllBankForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAPOptionBankLookupTableDto> {

        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAllBankForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllBankForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBankForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAPOptionBankLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAPOptionBankLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBankForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAPOptionBankLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAPOptionBankLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAPOptionBankLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAPOptionBankLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllChartofControlForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAPOptionChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetAllChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAPOptionChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAPOptionChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAPOptionChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAPOptionChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAPOptionChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAPOptionChartofControlLookupTableDto>(<any>null);
    }

    /**
     * @return Success
     */
    getCompanyProfileData(): Observable<CompanyProfileViewDto> {
        let url_ = this.baseUrl + "/api/services/app/APOptions/GetCompanyProfileData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCompanyProfileData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyProfileData(<any>response_);
                } catch (e) {
                    return <Observable<CompanyProfileViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyProfileViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyProfileData(response: HttpResponseBase): Observable<CompanyProfileViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CompanyProfileViewDto.fromJS(resultData200) : new CompanyProfileViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyProfileViewDto>(<any>null);
    }
}

@Injectable()
export class APTermsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param tERMDESCFilter (optional)
     * @param maxTERMRATEFilter (optional)
     * @param minTERMRATEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param iNACTIVEFilter (optional)
     * @param tERMTYPE (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, tERMDESCFilter: string | null | undefined, maxTERMRATEFilter: number | null | undefined, minTERMRATEFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, iNACTIVEFilter: number | null | undefined, tERMTYPE: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAPTermForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/APTerms/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (tERMDESCFilter !== undefined)
            url_ += "TERMDESCFilter=" + encodeURIComponent("" + tERMDESCFilter) + "&";
        if (maxTERMRATEFilter !== undefined)
            url_ += "MaxTERMRATEFilter=" + encodeURIComponent("" + maxTERMRATEFilter) + "&";
        if (minTERMRATEFilter !== undefined)
            url_ += "MinTERMRATEFilter=" + encodeURIComponent("" + minTERMRATEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (iNACTIVEFilter !== undefined)
            url_ += "INACTIVEFilter=" + encodeURIComponent("" + iNACTIVEFilter) + "&";
        if (tERMTYPE !== undefined)
            url_ += "TERMTYPE=" + encodeURIComponent("" + tERMTYPE) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAPTermForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAPTermForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAPTermForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetAPTermForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetAPTermForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAPTermForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAPTermForView(id: number | null | undefined): Observable<GetAPTermForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/APTerms/GetAPTermForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAPTermForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPTermForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAPTermForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAPTermForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPTermForView(response: HttpResponseBase): Observable<GetAPTermForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAPTermForViewDto.fromJS(resultData200) : new GetAPTermForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAPTermForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAPTermForEdit(id: number | null | undefined): Observable<GetAPTermForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/APTerms/GetAPTermForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAPTermForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPTermForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAPTermForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAPTermForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPTermForEdit(response: HttpResponseBase): Observable<GetAPTermForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAPTermForEditOutput.fromJS(resultData200) : new GetAPTermForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAPTermForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditAPTermDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/APTerms/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/APTerms/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param tERMDESCFilter (optional)
     * @param maxTERMRATEFilter (optional)
     * @param minTERMRATEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param iNACTIVEFilter (optional)
     * @param tERMTYPE (optional)
     * @return Success
     */
    getAPTermsToExcel(filter: string | null | undefined, tERMDESCFilter: string | null | undefined, maxTERMRATEFilter: number | null | undefined, minTERMRATEFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, iNACTIVEFilter: number | null | undefined, tERMTYPE: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/APTerms/GetAPTermsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (tERMDESCFilter !== undefined)
            url_ += "TERMDESCFilter=" + encodeURIComponent("" + tERMDESCFilter) + "&";
        if (maxTERMRATEFilter !== undefined)
            url_ += "MaxTERMRATEFilter=" + encodeURIComponent("" + maxTERMRATEFilter) + "&";
        if (minTERMRATEFilter !== undefined)
            url_ += "MinTERMRATEFilter=" + encodeURIComponent("" + minTERMRATEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (iNACTIVEFilter !== undefined)
            url_ += "INACTIVEFilter=" + encodeURIComponent("" + iNACTIVEFilter) + "&";
        if (tERMTYPE !== undefined)
            url_ += "TERMTYPE=" + encodeURIComponent("" + tERMTYPE) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAPTermsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAPTermsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAPTermsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class APTransactionListServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBookList(): Observable<ListResultDtoOfGetBookViewModeldto> {
        let url_ = this.baseUrl + "/api/services/app/APTransactionList/GetBookList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBookList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetBookViewModeldto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetBookViewModeldto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookList(response: HttpResponseBase): Observable<ListResultDtoOfGetBookViewModeldto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfGetBookViewModeldto.fromJS(resultData200) : new ListResultDtoOfGetBookViewModeldto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetBookViewModeldto>(<any>null);
    }

    /**
     * @param fromdate (optional)
     * @param todate (optional)
     * @param bookId (optional)
     * @param userId (optional)
     * @param directPost (optional)
     * @param status (optional)
     * @return Success
     */
    getReportParm(fromdate: moment.Moment | null | undefined, todate: moment.Moment | null | undefined, bookId: string | null | undefined, userId: string | null | undefined, directPost: boolean | null | undefined, status: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/APTransactionList/GetReportParm?";
        if (fromdate !== undefined)
            url_ += "Fromdate=" + encodeURIComponent(fromdate ? "" + fromdate.toJSON() : "") + "&";
        if (todate !== undefined)
            url_ += "Todate=" + encodeURIComponent(todate ? "" + todate.toJSON() : "") + "&";
        if (bookId !== undefined)
            url_ += "BookId=" + encodeURIComponent("" + bookId) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (directPost !== undefined)
            url_ += "DirectPost=" + encodeURIComponent("" + directPost) + "&";
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetReportParm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportParm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetReportParm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param bookid (optional)
     * @return Success
     */
    getMonthList(bookid: string | null | undefined): Observable<ListResultDtoOfMonthListDto> {
        let url_ = this.baseUrl + "/api/services/app/APTransactionList/GetMonthList?";
        if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMonthList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfMonthListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfMonthListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMonthList(response: HttpResponseBase): Observable<ListResultDtoOfMonthListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfMonthListDto.fromJS(resultData200) : new ListResultDtoOfMonthListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfMonthListDto>(<any>null);
    }

    /**
     * @param bookid (optional)
     * @return Success
     */
    getYearList(bookid: string | null | undefined): Observable<ListResultDtoOfYearListDto> {
        let url_ = this.baseUrl + "/api/services/app/APTransactionList/GetYearList?";
        if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetYearList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYearList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfYearListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfYearListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetYearList(response: HttpResponseBase): Observable<ListResultDtoOfYearListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfYearListDto.fromJS(resultData200) : new ListResultDtoOfYearListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfYearListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUserList(): Observable<ListResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/APTransactionList/GetUserList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserList(response: HttpResponseBase): Observable<ListResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfUserDto.fromJS(resultData200) : new ListResultDtoOfUserDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class APTransactionListingReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param book (optional)
     * @param user (optional)
     * @param tenantId (optional)
     * @param status (optional)
     * @param locId (optional)
     * @return Success
     */
    getData(fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, book: string | null | undefined, user: string | null | undefined, tenantId: number | null | undefined, status: string | null | undefined, locId: number | null | undefined): Observable<TransactionListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/APTransactionListingReports/GetData?";
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (book !== undefined)
            url_ += "Book=" + encodeURIComponent("" + book) + "&";
        if (user !== undefined)
            url_ += "User=" + encodeURIComponent("" + user) + "&";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(<any>response_);
                } catch (e) {
                    return <Observable<TransactionListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<TransactionListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TransactionListDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionListDto[]>(<any>null);
    }
}

@Injectable()
export class AROptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param dEFBANKIDFilter (optional)
     * @param maxDEFPAYCODEFilter (optional)
     * @param minDEFPAYCODEFilter (optional)
     * @param dEFCUSCTRLACCFilter (optional)
     * @param dEFCURRCODEFilter (optional)
     * @param pAYTERMSFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param bankBANKIDFilter (optional)
     * @param currencyRateIdFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, dEFBANKIDFilter: string | null | undefined, maxDEFPAYCODEFilter: number | null | undefined, minDEFPAYCODEFilter: number | null | undefined, dEFCUSCTRLACCFilter: string | null | undefined, dEFCURRCODEFilter: string | null | undefined, pAYTERMSFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, bankBANKIDFilter: string | null | undefined, currencyRateIdFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAROptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dEFBANKIDFilter !== undefined)
            url_ += "DEFBANKIDFilter=" + encodeURIComponent("" + dEFBANKIDFilter) + "&";
        if (maxDEFPAYCODEFilter !== undefined)
            url_ += "MaxDEFPAYCODEFilter=" + encodeURIComponent("" + maxDEFPAYCODEFilter) + "&";
        if (minDEFPAYCODEFilter !== undefined)
            url_ += "MinDEFPAYCODEFilter=" + encodeURIComponent("" + minDEFPAYCODEFilter) + "&";
        if (dEFCUSCTRLACCFilter !== undefined)
            url_ += "DEFCUSCTRLACCFilter=" + encodeURIComponent("" + dEFCUSCTRLACCFilter) + "&";
        if (dEFCURRCODEFilter !== undefined)
            url_ += "DEFCURRCODEFilter=" + encodeURIComponent("" + dEFCURRCODEFilter) + "&";
        if (pAYTERMSFilter !== undefined)
            url_ += "PAYTERMSFilter=" + encodeURIComponent("" + pAYTERMSFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (bankBANKIDFilter !== undefined)
            url_ += "BankBANKIDFilter=" + encodeURIComponent("" + bankBANKIDFilter) + "&";
        if (currencyRateIdFilter !== undefined)
            url_ += "CurrencyRateIdFilter=" + encodeURIComponent("" + currencyRateIdFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAROptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAROptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAROptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetAROptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetAROptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAROptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAROptionForView(id: number | null | undefined): Observable<GetAROptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAROptionForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAROptionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAROptionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAROptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAROptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAROptionForView(response: HttpResponseBase): Observable<GetAROptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAROptionForViewDto.fromJS(resultData200) : new GetAROptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAROptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getAROptionForEdit(id: number | null | undefined): Observable<GetAROptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAROptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAROptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAROptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAROptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAROptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAROptionForEdit(response: HttpResponseBase): Observable<GetAROptionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetAROptionForEditOutput.fromJS(resultData200) : new GetAROptionForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAROptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditAROptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param dEFBANKIDFilter (optional)
     * @param maxDEFPAYCODEFilter (optional)
     * @param minDEFPAYCODEFilter (optional)
     * @param dEFCUSCTRLACCFilter (optional)
     * @param dEFCURRCODEFilter (optional)
     * @param pAYTERMSFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param bankBANKIDFilter (optional)
     * @param currencyRateIdFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @return Success
     */
    getAROptionsToExcel(filter: string | null | undefined, dEFBANKIDFilter: string | null | undefined, maxDEFPAYCODEFilter: number | null | undefined, minDEFPAYCODEFilter: number | null | undefined, dEFCUSCTRLACCFilter: string | null | undefined, dEFCURRCODEFilter: string | null | undefined, pAYTERMSFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, bankBANKIDFilter: string | null | undefined, currencyRateIdFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAROptionsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dEFBANKIDFilter !== undefined)
            url_ += "DEFBANKIDFilter=" + encodeURIComponent("" + dEFBANKIDFilter) + "&";
        if (maxDEFPAYCODEFilter !== undefined)
            url_ += "MaxDEFPAYCODEFilter=" + encodeURIComponent("" + maxDEFPAYCODEFilter) + "&";
        if (minDEFPAYCODEFilter !== undefined)
            url_ += "MinDEFPAYCODEFilter=" + encodeURIComponent("" + minDEFPAYCODEFilter) + "&";
        if (dEFCUSCTRLACCFilter !== undefined)
            url_ += "DEFCUSCTRLACCFilter=" + encodeURIComponent("" + dEFCUSCTRLACCFilter) + "&";
        if (dEFCURRCODEFilter !== undefined)
            url_ += "DEFCURRCODEFilter=" + encodeURIComponent("" + dEFCURRCODEFilter) + "&";
        if (pAYTERMSFilter !== undefined)
            url_ += "PAYTERMSFilter=" + encodeURIComponent("" + pAYTERMSFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (bankBANKIDFilter !== undefined)
            url_ += "BankBANKIDFilter=" + encodeURIComponent("" + bankBANKIDFilter) + "&";
        if (currencyRateIdFilter !== undefined)
            url_ += "CurrencyRateIdFilter=" + encodeURIComponent("" + currencyRateIdFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAROptionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAROptionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAROptionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllBankForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAROptionBankLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAllBankForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllBankForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBankForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAROptionBankLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAROptionBankLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBankForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAROptionBankLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAROptionBankLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAROptionBankLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAROptionBankLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllCurrencyRateForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAROptionCurrencyRateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAllCurrencyRateForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllCurrencyRateForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyRateForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAROptionCurrencyRateLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAROptionCurrencyRateLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyRateForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAROptionCurrencyRateLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAROptionCurrencyRateLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAROptionCurrencyRateLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAROptionCurrencyRateLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllChartofControlForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAROptionChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AROptions/GetAllChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAROptionChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAROptionChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAROptionChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAROptionChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfAROptionChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAROptionChartofControlLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @param userName (optional)
     * @param serviceName (optional)
     * @param methodName (optional)
     * @param browserInfo (optional)
     * @param hasException (optional)
     * @param minExecutionDuration (optional)
     * @param maxExecutionDuration (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @param userName (optional)
     * @param serviceName (optional)
     * @param methodName (optional)
     * @param browserInfo (optional)
     * @param hasException (optional)
     * @param minExecutionDuration (optional)
     * @param maxExecutionDuration (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(NameValueDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @param userName (optional)
     * @param entityTypeFullName (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional)
     * @param entityId (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @param userName (optional)
     * @param entityTypeFullName (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional)
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(EntityPropertyChangeDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class BanksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param bANKIDFilter (optional)
     * @param bANKNAMEFilter (optional)
     * @param branchNameFilter (optional)
     * @param aDDR1Filter (optional)
     * @param aDDR2Filter (optional)
     * @param aDDR3Filter (optional)
     * @param aDDR4Filter (optional)
     * @param cITYFilter (optional)
     * @param sTATEFilter (optional)
     * @param cOUNTRYFilter (optional)
     * @param pOSTALFilter (optional)
     * @param cONTACTFilter (optional)
     * @param pHONEFilter (optional)
     * @param fAXFilter (optional)
     * @param iNACTIVEFilter (optional)
     * @param maxINACTDATEFilter (optional)
     * @param minINACTDATEFilter (optional)
     * @param bKACCTNUMBERFilter (optional)
     * @param iDACCTBANKFilter (optional)
     * @param iDACCTWOFFFilter (optional)
     * @param iDACCTCRCARDFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, cMPIDFilter: string | null | undefined, bANKIDFilter: string | null | undefined, bANKNAMEFilter: string | null | undefined, branchNameFilter: string | null | undefined, aDDR1Filter: string | null | undefined, aDDR2Filter: string | null | undefined, aDDR3Filter: string | null | undefined, aDDR4Filter: string | null | undefined, cITYFilter: string | null | undefined, sTATEFilter: string | null | undefined, cOUNTRYFilter: string | null | undefined, pOSTALFilter: string | null | undefined, cONTACTFilter: string | null | undefined, pHONEFilter: string | null | undefined, fAXFilter: string | null | undefined, iNACTIVEFilter: number | null | undefined, maxINACTDATEFilter: moment.Moment | null | undefined, minINACTDATEFilter: moment.Moment | null | undefined, bKACCTNUMBERFilter: string | null | undefined, iDACCTBANKFilter: string | null | undefined, iDACCTWOFFFilter: string | null | undefined, iDACCTCRCARDFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBankForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Banks/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (bANKIDFilter !== undefined)
            url_ += "BANKIDFilter=" + encodeURIComponent("" + bANKIDFilter) + "&";
        if (bANKNAMEFilter !== undefined)
            url_ += "BANKNAMEFilter=" + encodeURIComponent("" + bANKNAMEFilter) + "&";
        if (branchNameFilter !== undefined)
            url_ += "BranchNameFilter=" + encodeURIComponent("" + branchNameFilter) + "&";
        if (aDDR1Filter !== undefined)
            url_ += "ADDR1Filter=" + encodeURIComponent("" + aDDR1Filter) + "&";
        if (aDDR2Filter !== undefined)
            url_ += "ADDR2Filter=" + encodeURIComponent("" + aDDR2Filter) + "&";
        if (aDDR3Filter !== undefined)
            url_ += "ADDR3Filter=" + encodeURIComponent("" + aDDR3Filter) + "&";
        if (aDDR4Filter !== undefined)
            url_ += "ADDR4Filter=" + encodeURIComponent("" + aDDR4Filter) + "&";
        if (cITYFilter !== undefined)
            url_ += "CITYFilter=" + encodeURIComponent("" + cITYFilter) + "&";
        if (sTATEFilter !== undefined)
            url_ += "STATEFilter=" + encodeURIComponent("" + sTATEFilter) + "&";
        if (cOUNTRYFilter !== undefined)
            url_ += "COUNTRYFilter=" + encodeURIComponent("" + cOUNTRYFilter) + "&";
        if (pOSTALFilter !== undefined)
            url_ += "POSTALFilter=" + encodeURIComponent("" + pOSTALFilter) + "&";
        if (cONTACTFilter !== undefined)
            url_ += "CONTACTFilter=" + encodeURIComponent("" + cONTACTFilter) + "&";
        if (pHONEFilter !== undefined)
            url_ += "PHONEFilter=" + encodeURIComponent("" + pHONEFilter) + "&";
        if (fAXFilter !== undefined)
            url_ += "FAXFilter=" + encodeURIComponent("" + fAXFilter) + "&";
        if (iNACTIVEFilter !== undefined)
            url_ += "INACTIVEFilter=" + encodeURIComponent("" + iNACTIVEFilter) + "&";
        if (maxINACTDATEFilter !== undefined)
            url_ += "MaxINACTDATEFilter=" + encodeURIComponent(maxINACTDATEFilter ? "" + maxINACTDATEFilter.toJSON() : "") + "&";
        if (minINACTDATEFilter !== undefined)
            url_ += "MinINACTDATEFilter=" + encodeURIComponent(minINACTDATEFilter ? "" + minINACTDATEFilter.toJSON() : "") + "&";
        if (bKACCTNUMBERFilter !== undefined)
            url_ += "BKACCTNUMBERFilter=" + encodeURIComponent("" + bKACCTNUMBERFilter) + "&";
        if (iDACCTBANKFilter !== undefined)
            url_ += "IDACCTBANKFilter=" + encodeURIComponent("" + iDACCTBANKFilter) + "&";
        if (iDACCTWOFFFilter !== undefined)
            url_ += "IDACCTWOFFFilter=" + encodeURIComponent("" + iDACCTWOFFFilter) + "&";
        if (iDACCTCRCARDFilter !== undefined)
            url_ += "IDACCTCRCARDFilter=" + encodeURIComponent("" + iDACCTCRCARDFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBankForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBankForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBankForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetBankForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetBankForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBankForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getBankForView(id: number | null | undefined): Observable<GetBankForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Banks/GetBankForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBankForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBankForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBankForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankForView(response: HttpResponseBase): Observable<GetBankForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetBankForViewDto.fromJS(resultData200) : new GetBankForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getBankForEdit(id: number | null | undefined): Observable<GetBankForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Banks/GetBankForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBankForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBankForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBankForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankForEdit(response: HttpResponseBase): Observable<GetBankForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetBankForEditOutput.fromJS(resultData200) : new GetBankForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBankForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditBankDto | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Banks/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Banks/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param bANKIDFilter (optional)
     * @param bANKNAMEFilter (optional)
     * @param aDDR1Filter (optional)
     * @param aDDR2Filter (optional)
     * @param aDDR3Filter (optional)
     * @param aDDR4Filter (optional)
     * @param cITYFilter (optional)
     * @param sTATEFilter (optional)
     * @param cOUNTRYFilter (optional)
     * @param pOSTALFilter (optional)
     * @param cONTACTFilter (optional)
     * @param pHONEFilter (optional)
     * @param fAXFilter (optional)
     * @param iNACTIVEFilter (optional)
     * @param maxINACTDATEFilter (optional)
     * @param minINACTDATEFilter (optional)
     * @param bKACCTNUMBERFilter (optional)
     * @param iDACCTBANKFilter (optional)
     * @param iDACCTWOFFFilter (optional)
     * @param iDACCTCRCARDFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @return Success
     */
    getBanksToExcel(filter: string | null | undefined, cMPIDFilter: string | null | undefined, bANKIDFilter: string | null | undefined, bANKNAMEFilter: string | null | undefined, aDDR1Filter: string | null | undefined, aDDR2Filter: string | null | undefined, aDDR3Filter: string | null | undefined, aDDR4Filter: string | null | undefined, cITYFilter: string | null | undefined, sTATEFilter: string | null | undefined, cOUNTRYFilter: string | null | undefined, pOSTALFilter: string | null | undefined, cONTACTFilter: string | null | undefined, pHONEFilter: string | null | undefined, fAXFilter: string | null | undefined, iNACTIVEFilter: number | null | undefined, maxINACTDATEFilter: moment.Moment | null | undefined, minINACTDATEFilter: moment.Moment | null | undefined, bKACCTNUMBERFilter: string | null | undefined, iDACCTBANKFilter: string | null | undefined, iDACCTWOFFFilter: string | null | undefined, iDACCTCRCARDFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Banks/GetBanksToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (bANKIDFilter !== undefined)
            url_ += "BANKIDFilter=" + encodeURIComponent("" + bANKIDFilter) + "&";
        if (bANKNAMEFilter !== undefined)
            url_ += "BANKNAMEFilter=" + encodeURIComponent("" + bANKNAMEFilter) + "&";
        if (aDDR1Filter !== undefined)
            url_ += "ADDR1Filter=" + encodeURIComponent("" + aDDR1Filter) + "&";
        if (aDDR2Filter !== undefined)
            url_ += "ADDR2Filter=" + encodeURIComponent("" + aDDR2Filter) + "&";
        if (aDDR3Filter !== undefined)
            url_ += "ADDR3Filter=" + encodeURIComponent("" + aDDR3Filter) + "&";
        if (aDDR4Filter !== undefined)
            url_ += "ADDR4Filter=" + encodeURIComponent("" + aDDR4Filter) + "&";
        if (cITYFilter !== undefined)
            url_ += "CITYFilter=" + encodeURIComponent("" + cITYFilter) + "&";
        if (sTATEFilter !== undefined)
            url_ += "STATEFilter=" + encodeURIComponent("" + sTATEFilter) + "&";
        if (cOUNTRYFilter !== undefined)
            url_ += "COUNTRYFilter=" + encodeURIComponent("" + cOUNTRYFilter) + "&";
        if (pOSTALFilter !== undefined)
            url_ += "POSTALFilter=" + encodeURIComponent("" + pOSTALFilter) + "&";
        if (cONTACTFilter !== undefined)
            url_ += "CONTACTFilter=" + encodeURIComponent("" + cONTACTFilter) + "&";
        if (pHONEFilter !== undefined)
            url_ += "PHONEFilter=" + encodeURIComponent("" + pHONEFilter) + "&";
        if (fAXFilter !== undefined)
            url_ += "FAXFilter=" + encodeURIComponent("" + fAXFilter) + "&";
        if (iNACTIVEFilter !== undefined)
            url_ += "INACTIVEFilter=" + encodeURIComponent("" + iNACTIVEFilter) + "&";
        if (maxINACTDATEFilter !== undefined)
            url_ += "MaxINACTDATEFilter=" + encodeURIComponent(maxINACTDATEFilter ? "" + maxINACTDATEFilter.toJSON() : "") + "&";
        if (minINACTDATEFilter !== undefined)
            url_ += "MinINACTDATEFilter=" + encodeURIComponent(minINACTDATEFilter ? "" + minINACTDATEFilter.toJSON() : "") + "&";
        if (bKACCTNUMBERFilter !== undefined)
            url_ += "BKACCTNUMBERFilter=" + encodeURIComponent("" + bKACCTNUMBERFilter) + "&";
        if (iDACCTBANKFilter !== undefined)
            url_ += "IDACCTBANKFilter=" + encodeURIComponent("" + iDACCTBANKFilter) + "&";
        if (iDACCTWOFFFilter !== undefined)
            url_ += "IDACCTWOFFFilter=" + encodeURIComponent("" + iDACCTWOFFFilter) + "&";
        if (iDACCTCRCARDFilter !== undefined)
            url_ += "IDACCTCRCARDFilter=" + encodeURIComponent("" + iDACCTCRCARDFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBanksToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBanksToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBanksToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllChartofControlForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBankChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Banks/GetAllChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBankChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBankChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBankChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfBankChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfBankChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBankChartofControlLookupTableDto>(<any>null);
    }
}
@Injectable(
    { providedIn: 'root' }
)
export class CPRServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxCprIdFilter (optional)
     * @param minCprIdFilter (optional)
     * @param cprNoFilter (optional)
     * @param activeFilter (optional)
     * @param audtUserFilter (optional)
     * @param maxAudtDateFilter (optional)
     * @param minAudtDateFilter (optional)
     * @param createdByFilter (optional)
     * @param maxCreateDateFilter (optional)
     * @param minCreateDateFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, maxCprIdFilter: number | null | undefined, minCprIdFilter: number | null | undefined, cprNoFilter: string | null | undefined, activeFilter: number | null | undefined, createdByFilter: string | null | undefined, maxCreateDateFilter: moment.Moment | null | undefined, minCreateDateFilter: moment.Moment | null | undefined, audtUserFilter: string | null | undefined, maxAudtDateFilter: moment.Moment | null | undefined, minAudtDateFilter: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCPRForViewDto> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/CPR/GetAll?";

        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxCprIdFilter !== undefined)
            url_ += "MaxCprIdFilter=" + encodeURIComponent("" + maxCprIdFilter) + "&";
        if (minCprIdFilter !== undefined)
            url_ += "MinCprIdFilter=" + encodeURIComponent("" + minCprIdFilter) + "&";
        if (cprNoFilter !== undefined)
            url_ += "cprNoFilter=" + encodeURIComponent("" + cprNoFilter) + "&";
        if (activeFilter != undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&";
        if (audtUserFilter !== undefined)
            url_ += "AudtUserFilter=" + encodeURIComponent("" + audtUserFilter) + "&";
        if (maxAudtDateFilter !== undefined)
            url_ += "MaxAudtDateFilter=" + encodeURIComponent(maxAudtDateFilter ? "" + maxAudtDateFilter.toJSON() : "") + "&";
        if (minAudtDateFilter !== undefined)
            url_ += "MinAudtDateFilter=" + encodeURIComponent(minAudtDateFilter ? "" + minAudtDateFilter.toJSON() : "") + "&";
        if (createdByFilter !== undefined)
            url_ += "CreatedByFilter=" + encodeURIComponent("" + createdByFilter) + "&";
        if (maxCreateDateFilter !== undefined)
            url_ += "MaxCreateDateFilter=" + encodeURIComponent(maxCreateDateFilter ? "" + maxCreateDateFilter.toJSON() : "") + "&";
        if (minCreateDateFilter !== undefined)
            url_ += "MinCreateDateFilter=" + encodeURIComponent(minCreateDateFilter ? "" + minCreateDateFilter.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            debugger;
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {

                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCPRForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCPRForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCPRForViewDto> {
        debugger;
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetCPRForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetCPRForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCPRForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    GetCPRForView(id: number | null | undefined): Observable<GetCPRForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CPR/GetCPRForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCPRForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCPRForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCPRForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCPRForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCPRForView(response: HttpResponseBase): Observable<GetCPRForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCPRForViewDto.fromJS(resultData200) : new GetCPRForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCPRForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getCPRForEdit(id: number | null | undefined): Observable<GetCPRForEditOutput> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/CPR/GetCPRForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {

            return this.processGetCPRForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {

                    return this.processGetCPRForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCPRForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCPRForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCPRForEdit(response: HttpResponseBase): Observable<GetCPRForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCPRForEditOutput.fromJS(resultData200) : new GetCPRForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCPRForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditCPRDto | null | undefined): Observable<void> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/CPR/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        debugger;
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CPR/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            debugger;
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        debugger;
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
    * @param filter (optional)
    * @param maxCprIdFilter (optional)
    * @param minCprIdFilter (optional)
    * @param cprNoFilter (optional)
    * @param activeFilter (optional)
    * @param audtUserFilter (optional)
    * @param maxAudtDateFilter (optional)
    * @param minAudtDateFilter (optional)
    * @param createdByFilter (optional)
    * @param maxCreateDateFilter (optional)
    * @param minCreateDateFilter (optional)
    * @return Success
    */
    GetCPRToExcel(filter: string | null | undefined, maxCprIdFilter: number | null | undefined, minCprIdFilter: number | null | undefined, cprNoFilter: string | null | undefined, activeFilter: number | null | undefined, auditUserFilter: string | null | undefined, maxAudtDateFilter: moment.Moment | null | undefined, minAudtDateFilter: moment.Moment | null | undefined, createdByFilter: string | null | undefined, maxCreateDateFilter: moment.Moment | null | undefined, minCreateDateFilter: moment.Moment | null | undefined,): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Cpr/GetCPRToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxCprIdFilter !== undefined)
            url_ += "MaxCprIdFilter=" + encodeURIComponent("" + maxCprIdFilter) + "&";
        if (minCprIdFilter !== undefined)
            url_ += "MinCprIdFilter=" + encodeURIComponent("" + minCprIdFilter) + "&";
        if (cprNoFilter !== undefined)
            url_ += "cprNoFilter=" + encodeURIComponent("" + cprNoFilter) + "&";
        if (activeFilter != undefined)
            url_ += "ActiveFilter=" + encodeURIComponent("" + activeFilter) + "&";
        if (auditUserFilter !== undefined)
            url_ += "auditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAudtDateFilter !== undefined)
            url_ += "MaxAudtDateFilter=" + encodeURIComponent(maxAudtDateFilter ? "" + maxAudtDateFilter.toJSON() : "") + "&";
        if (minAudtDateFilter !== undefined)
            url_ += "MinAudtDateFilter=" + encodeURIComponent(minAudtDateFilter ? "" + minAudtDateFilter.toJSON() : "") + "&";
        if (createdByFilter !== undefined)
            url_ += "CreatedByFilter=" + encodeURIComponent("" + createdByFilter) + "&";
        if (maxCreateDateFilter !== undefined)
            url_ += "MaxCreateDateFilter=" + encodeURIComponent(maxCreateDateFilter ? "" + maxCreateDateFilter.toJSON() : "") + "&";
        if (minCreateDateFilter !== undefined)
            url_ += "MinCreateDateFilter=" + encodeURIComponent(minCreateDateFilter ? "" + minCreateDateFilter.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCPRToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCPRToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCPRToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
    getMaxCprId(): Observable<number> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/CPR/GetMaxID";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMaxCprId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxCprId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxCprId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

}
@Injectable()
export class BatchListPreviewsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param bookIDFilter (optional)
     * @param maxDocMonthFilter (optional)
     * @param minDocMonthFilter (optional)
     * @param maxDocDateFilter (optional)
     * @param minDocDateFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, locationFilter: string | null | undefined, referenceFilter: string | null | undefined, narrationFilter: string | null | undefined, maxAmountFilter: number | null | undefined, minAmountFilter: number | null | undefined, bookIDFilter: string | null | undefined, maxDocMonthFilter: number | null | undefined, minDocMonthFilter: number | null | undefined, maxDocDateFilter: moment.Moment | null | undefined, minDocDateFilter: moment.Moment | null | undefined, minVoucherNoFilter: number | null | undefined, maxVoucherNoFilter: number | null | undefined, approvedFilter: number | null | undefined, postedFilter: number | null | undefined, statusFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBatchListPreviewForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchListPreviews/GetAll?";
        debugger;
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&";
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&";
        if (narrationFilter !== undefined)
            url_ += "NarrationFilter=" + encodeURIComponent("" + narrationFilter) + "&";
        if (maxAmountFilter !== undefined)
            url_ += "MaxAmountFilter=" + encodeURIComponent("" + maxAmountFilter) + "&";
        if (minAmountFilter !== undefined)
            url_ += "MinAmountFilter=" + encodeURIComponent("" + minAmountFilter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (maxDocMonthFilter !== undefined)
            url_ += "MaxDocMonthFilter=" + encodeURIComponent("" + maxDocMonthFilter) + "&";
        if (minDocMonthFilter !== undefined)
            url_ += "MinDocMonthFilter=" + encodeURIComponent("" + minDocMonthFilter) + "&";
        if (maxDocDateFilter !== undefined)
            url_ += "MaxDocDateFilter=" + encodeURIComponent(maxDocDateFilter ? "" + maxDocDateFilter.toJSON() : "") + "&";
        if (minDocDateFilter !== undefined)
            url_ += "MinDocDateFilter=" + encodeURIComponent(minDocDateFilter ? "" + minDocDateFilter.toJSON() : "") + "&";
        if (minVoucherNoFilter !== undefined)
            url_ += "MinVoucherNoFilter=" + encodeURIComponent("" + minVoucherNoFilter) + "&";
        if (maxVoucherNoFilter !== undefined)
            url_ += "MaxVoucherNoFilter=" + encodeURIComponent("" + maxVoucherNoFilter) + "&";
        if (approvedFilter !== undefined)
            url_ += "Status=" + encodeURIComponent("" + approvedFilter) + "&";
        if (postedFilter !== undefined)
            url_ += "PostedFilter=" + encodeURIComponent("" + postedFilter) + "&";
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");


        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBatchListPreviewForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBatchListPreviewForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBatchListPreviewForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetBatchListPreviewForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetBatchListPreviewForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBatchListPreviewForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @param bookpID (optional)
     * @return Success
     */
    getBatchListPreviewForView(id: number | null | undefined, bookpID: string | null | undefined, docDate: moment.Moment): Observable<GetBatchListPreviewForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/BatchListPreviews/GetBatchListPreviewForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (bookpID !== undefined)
            url_ += "bookpID=" + encodeURIComponent("" + bookpID) + "&";
        if (docDate !== undefined)
            url_ += "docDate=" + encodeURIComponent("" + docDate.format("MM DD YYYY")) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBatchListPreviewForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchListPreviewForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBatchListPreviewForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBatchListPreviewForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchListPreviewForView(response: HttpResponseBase): Observable<GetBatchListPreviewForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(GetBatchListPreviewForViewDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBatchListPreviewForViewDto[]>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getBatchListPreviewForEdit(id: number | null | undefined): Observable<GetBatchListPreviewForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BatchListPreviews/GetBatchListPreviewForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBatchListPreviewForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchListPreviewForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBatchListPreviewForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBatchListPreviewForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchListPreviewForEdit(response: HttpResponseBase): Observable<GetBatchListPreviewForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetBatchListPreviewForEditOutput.fromJS(resultData200) : new GetBatchListPreviewForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBatchListPreviewForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditBatchListPreviewDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BatchListPreviews/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BatchListPreviews/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @return Success
     */
    getBatchListPreviewsToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BatchListPreviews/GetBatchListPreviewsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBatchListPreviewsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBatchListPreviewsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBatchListPreviewsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BkTransfersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param maxDOCIDFilter (optional)
     * @param minDOCIDFilter (optional)
     * @param maxDOCDATEFilter (optional)
     * @param minDOCDATEFilter (optional)
     * @param maxTRANSFERDATEFilter (optional)
     * @param minTRANSFERDATEFilter (optional)
     * @param dESCRIPTIONFilter (optional)
     * @param maxFROMBANKIDFilter (optional)
     * @param minFROMBANKIDFilter (optional)
     * @param maxFROMCONFIGIDFilter (optional)
     * @param minFROMCONFIGIDFilter (optional)
     * @param maxTOBANKIDFilter (optional)
     * @param minTOBANKIDFilter (optional)
     * @param maxTOCONFIGIDFilter (optional)
     * @param minTOCONFIGIDFilter (optional)
     * @param maxAVAILLIMITFilter (optional)
     * @param minAVAILLIMITFilter (optional)
     * @param maxTRANSFERAMOUNTFilter (optional)
     * @param minTRANSFERAMOUNTFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param bankBANKNAMEFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, cMPIDFilter: string | null | undefined, maxDOCIDFilter: number | null | undefined, minDOCIDFilter: number | null | undefined, maxDOCDATEFilter: moment.Moment | null | undefined, minDOCDATEFilter: moment.Moment | null | undefined, maxTRANSFERDATEFilter: moment.Moment | null | undefined, minTRANSFERDATEFilter: moment.Moment | null | undefined, dESCRIPTIONFilter: string | null | undefined, maxFROMBANKIDFilter: number | null | undefined, minFROMBANKIDFilter: number | null | undefined, maxFROMCONFIGIDFilter: number | null | undefined, minFROMCONFIGIDFilter: number | null | undefined, maxTOBANKIDFilter: number | null | undefined, minTOBANKIDFilter: number | null | undefined, maxTOCONFIGIDFilter: number | null | undefined, minTOCONFIGIDFilter: number | null | undefined, maxAVAILLIMITFilter: number | null | undefined, minAVAILLIMITFilter: number | null | undefined, maxTRANSFERAMOUNTFilter: number | null | undefined, minTRANSFERAMOUNTFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, bankBANKNAMEFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBkTransferForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (maxDOCIDFilter !== undefined)
            url_ += "MaxDOCIDFilter=" + encodeURIComponent("" + maxDOCIDFilter) + "&";
        if (minDOCIDFilter !== undefined)
            url_ += "MinDOCIDFilter=" + encodeURIComponent("" + minDOCIDFilter) + "&";
        if (maxDOCDATEFilter !== undefined)
            url_ += "MaxDOCDATEFilter=" + encodeURIComponent(maxDOCDATEFilter ? "" + maxDOCDATEFilter.toJSON() : "") + "&";
        if (minDOCDATEFilter !== undefined)
            url_ += "MinDOCDATEFilter=" + encodeURIComponent(minDOCDATEFilter ? "" + minDOCDATEFilter.toJSON() : "") + "&";
        if (maxTRANSFERDATEFilter !== undefined)
            url_ += "MaxTRANSFERDATEFilter=" + encodeURIComponent(maxTRANSFERDATEFilter ? "" + maxTRANSFERDATEFilter.toJSON() : "") + "&";
        if (minTRANSFERDATEFilter !== undefined)
            url_ += "MinTRANSFERDATEFilter=" + encodeURIComponent(minTRANSFERDATEFilter ? "" + minTRANSFERDATEFilter.toJSON() : "") + "&";
        if (dESCRIPTIONFilter !== undefined)
            url_ += "DESCRIPTIONFilter=" + encodeURIComponent("" + dESCRIPTIONFilter) + "&";
        if (maxFROMBANKIDFilter !== undefined)
            url_ += "MaxFROMBANKIDFilter=" + encodeURIComponent("" + maxFROMBANKIDFilter) + "&";
        if (minFROMBANKIDFilter !== undefined)
            url_ += "MinFROMBANKIDFilter=" + encodeURIComponent("" + minFROMBANKIDFilter) + "&";
        if (maxFROMCONFIGIDFilter !== undefined)
            url_ += "MaxFROMCONFIGIDFilter=" + encodeURIComponent("" + maxFROMCONFIGIDFilter) + "&";
        if (minFROMCONFIGIDFilter !== undefined)
            url_ += "MinFROMCONFIGIDFilter=" + encodeURIComponent("" + minFROMCONFIGIDFilter) + "&";
        if (maxTOBANKIDFilter !== undefined)
            url_ += "MaxTOBANKIDFilter=" + encodeURIComponent("" + maxTOBANKIDFilter) + "&";
        if (minTOBANKIDFilter !== undefined)
            url_ += "MinTOBANKIDFilter=" + encodeURIComponent("" + minTOBANKIDFilter) + "&";
        if (maxTOCONFIGIDFilter !== undefined)
            url_ += "MaxTOCONFIGIDFilter=" + encodeURIComponent("" + maxTOCONFIGIDFilter) + "&";
        if (minTOCONFIGIDFilter !== undefined)
            url_ += "MinTOCONFIGIDFilter=" + encodeURIComponent("" + minTOCONFIGIDFilter) + "&";
        if (maxAVAILLIMITFilter !== undefined)
            url_ += "MaxAVAILLIMITFilter=" + encodeURIComponent("" + maxAVAILLIMITFilter) + "&";
        if (minAVAILLIMITFilter !== undefined)
            url_ += "MinAVAILLIMITFilter=" + encodeURIComponent("" + minAVAILLIMITFilter) + "&";
        if (maxTRANSFERAMOUNTFilter !== undefined)
            url_ += "MaxTRANSFERAMOUNTFilter=" + encodeURIComponent("" + maxTRANSFERAMOUNTFilter) + "&";
        if (minTRANSFERAMOUNTFilter !== undefined)
            url_ += "MinTRANSFERAMOUNTFilter=" + encodeURIComponent("" + minTRANSFERAMOUNTFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (bankBANKNAMEFilter !== undefined)
            url_ += "BankBANKNAMEFilter=" + encodeURIComponent("" + bankBANKNAMEFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        debugger
        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    debugger
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBkTransferForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBkTransferForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBkTransferForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetBkTransferForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetBkTransferForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBkTransferForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getBkTransferForView(id: number | null | undefined): Observable<GetBkTransferForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/GetBkTransferForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBkTransferForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBkTransferForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBkTransferForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBkTransferForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBkTransferForView(response: HttpResponseBase): Observable<GetBkTransferForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetBkTransferForViewDto.fromJS(resultData200) : new GetBkTransferForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBkTransferForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getBkTransferForEdit(id: number | null | undefined): Observable<GetBkTransferForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/GetBkTransferForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBkTransferForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBkTransferForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBkTransferForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBkTransferForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBkTransferForEdit(response: HttpResponseBase): Observable<GetBkTransferForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetBkTransferForEditOutput.fromJS(resultData200) : new GetBkTransferForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBkTransferForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDataForCreateForm(): Observable<DataForCreateFormDto> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/GetDataForCreateForm";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDataForCreateForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataForCreateForm(<any>response_);
                } catch (e) {
                    return <Observable<DataForCreateFormDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataForCreateFormDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataForCreateForm(response: HttpResponseBase): Observable<DataForCreateFormDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DataForCreateFormDto.fromJS(resultData200) : new DataForCreateFormDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataForCreateFormDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditBkTransferDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    processBkTransfer(input: CreateOrEditBkTransferDto | null | undefined): Observable<string> {

        let url_ = this.baseUrl + "/api/services/app/BkTransfers/ProcessBkTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPBKTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPBKTransfer(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processPBKTransfer(response: HttpResponseBase): Observable<string> {

        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param maxDOCIDFilter (optional)
     * @param minDOCIDFilter (optional)
     * @param maxDOCDATEFilter (optional)
     * @param minDOCDATEFilter (optional)
     * @param maxTRANSFERDATEFilter (optional)
     * @param minTRANSFERDATEFilter (optional)
     * @param dESCRIPTIONFilter (optional)
     * @param maxFROMBANKIDFilter (optional)
     * @param minFROMBANKIDFilter (optional)
     * @param maxFROMCONFIGIDFilter (optional)
     * @param minFROMCONFIGIDFilter (optional)
     * @param maxTOBANKIDFilter (optional)
     * @param minTOBANKIDFilter (optional)
     * @param maxTOCONFIGIDFilter (optional)
     * @param minTOCONFIGIDFilter (optional)
     * @param maxAVAILLIMITFilter (optional)
     * @param minAVAILLIMITFilter (optional)
     * @param maxTRANSFERAMOUNTFilter (optional)
     * @param minTRANSFERAMOUNTFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param bankBANKNAMEFilter (optional)
     * @return Success
     */
    getBkTransfersToExcel(filter: string | null | undefined, cMPIDFilter: string | null | undefined, maxDOCIDFilter: number | null | undefined, minDOCIDFilter: number | null | undefined, maxDOCDATEFilter: moment.Moment | null | undefined, minDOCDATEFilter: moment.Moment | null | undefined, maxTRANSFERDATEFilter: moment.Moment | null | undefined, minTRANSFERDATEFilter: moment.Moment | null | undefined, dESCRIPTIONFilter: string | null | undefined, maxFROMBANKIDFilter: number | null | undefined, minFROMBANKIDFilter: number | null | undefined, maxFROMCONFIGIDFilter: number | null | undefined, minFROMCONFIGIDFilter: number | null | undefined, maxTOBANKIDFilter: number | null | undefined, minTOBANKIDFilter: number | null | undefined, maxTOCONFIGIDFilter: number | null | undefined, minTOCONFIGIDFilter: number | null | undefined, maxAVAILLIMITFilter: number | null | undefined, minAVAILLIMITFilter: number | null | undefined, maxTRANSFERAMOUNTFilter: number | null | undefined, minTRANSFERAMOUNTFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, bankBANKNAMEFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/GetBkTransfersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (maxDOCIDFilter !== undefined)
            url_ += "MaxDOCIDFilter=" + encodeURIComponent("" + maxDOCIDFilter) + "&";
        if (minDOCIDFilter !== undefined)
            url_ += "MinDOCIDFilter=" + encodeURIComponent("" + minDOCIDFilter) + "&";
        if (maxDOCDATEFilter !== undefined)
            url_ += "MaxDOCDATEFilter=" + encodeURIComponent(maxDOCDATEFilter ? "" + maxDOCDATEFilter.toJSON() : "") + "&";
        if (minDOCDATEFilter !== undefined)
            url_ += "MinDOCDATEFilter=" + encodeURIComponent(minDOCDATEFilter ? "" + minDOCDATEFilter.toJSON() : "") + "&";
        if (maxTRANSFERDATEFilter !== undefined)
            url_ += "MaxTRANSFERDATEFilter=" + encodeURIComponent(maxTRANSFERDATEFilter ? "" + maxTRANSFERDATEFilter.toJSON() : "") + "&";
        if (minTRANSFERDATEFilter !== undefined)
            url_ += "MinTRANSFERDATEFilter=" + encodeURIComponent(minTRANSFERDATEFilter ? "" + minTRANSFERDATEFilter.toJSON() : "") + "&";
        if (dESCRIPTIONFilter !== undefined)
            url_ += "DESCRIPTIONFilter=" + encodeURIComponent("" + dESCRIPTIONFilter) + "&";
        if (maxFROMBANKIDFilter !== undefined)
            url_ += "MaxFROMBANKIDFilter=" + encodeURIComponent("" + maxFROMBANKIDFilter) + "&";
        if (minFROMBANKIDFilter !== undefined)
            url_ += "MinFROMBANKIDFilter=" + encodeURIComponent("" + minFROMBANKIDFilter) + "&";
        if (maxFROMCONFIGIDFilter !== undefined)
            url_ += "MaxFROMCONFIGIDFilter=" + encodeURIComponent("" + maxFROMCONFIGIDFilter) + "&";
        if (minFROMCONFIGIDFilter !== undefined)
            url_ += "MinFROMCONFIGIDFilter=" + encodeURIComponent("" + minFROMCONFIGIDFilter) + "&";
        if (maxTOBANKIDFilter !== undefined)
            url_ += "MaxTOBANKIDFilter=" + encodeURIComponent("" + maxTOBANKIDFilter) + "&";
        if (minTOBANKIDFilter !== undefined)
            url_ += "MinTOBANKIDFilter=" + encodeURIComponent("" + minTOBANKIDFilter) + "&";
        if (maxTOCONFIGIDFilter !== undefined)
            url_ += "MaxTOCONFIGIDFilter=" + encodeURIComponent("" + maxTOCONFIGIDFilter) + "&";
        if (minTOCONFIGIDFilter !== undefined)
            url_ += "MinTOCONFIGIDFilter=" + encodeURIComponent("" + minTOCONFIGIDFilter) + "&";
        if (maxAVAILLIMITFilter !== undefined)
            url_ += "MaxAVAILLIMITFilter=" + encodeURIComponent("" + maxAVAILLIMITFilter) + "&";
        if (minAVAILLIMITFilter !== undefined)
            url_ += "MinAVAILLIMITFilter=" + encodeURIComponent("" + minAVAILLIMITFilter) + "&";
        if (maxTRANSFERAMOUNTFilter !== undefined)
            url_ += "MaxTRANSFERAMOUNTFilter=" + encodeURIComponent("" + maxTRANSFERAMOUNTFilter) + "&";
        if (minTRANSFERAMOUNTFilter !== undefined)
            url_ += "MinTRANSFERAMOUNTFilter=" + encodeURIComponent("" + minTRANSFERAMOUNTFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (bankBANKNAMEFilter !== undefined)
            url_ += "BankBANKNAMEFilter=" + encodeURIComponent("" + bankBANKNAMEFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBkTransfersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBkTransfersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBkTransfersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllBankForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBkTransferBankLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BkTransfers/GetAllBankForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllBankForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBankForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBkTransferBankLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBkTransferBankLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBankForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBkTransferBankLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfBkTransferBankLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfBkTransferBankLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBkTransferBankLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CashBookReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param fromAccount (optional)
     * @param toAccount (optional)
     * @param tenantID (optional)
     * @return Success
     */
    getAll(fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, fromAccount: string | null | undefined, toAccount: string | null | undefined, tenantID: number | null | undefined): Observable<CashBookForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CashBookReport/GetAll?";
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (fromAccount !== undefined)
            url_ += "FromAccount=" + encodeURIComponent("" + fromAccount) + "&";
        if (toAccount !== undefined)
            url_ += "ToAccount=" + encodeURIComponent("" + toAccount) + "&";
        if (tenantID !== undefined)
            url_ += "TenantID=" + encodeURIComponent("" + tenantID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CashBookForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashBookForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CashBookForViewDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CashBookForViewDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashBookForViewDto[]>(<any>null);
    }
}

@Injectable()
export class CashReceiptReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional)
     * @param bookId (optional)
     * @param year (optional)
     * @param month (optional)
     * @param fromConfigId (optional)
     * @param toConfigId (optional)
     * @param fromDoc (optional)
     * @param toDoc (optional)
     * @param locId (optional)
     * @return Success
     */
    getCashReceipt(tenantId: number | null | undefined, bookId: string | null | undefined, year: number | null | undefined, month: number | null | undefined, fromConfigId: number | null | undefined, toConfigId: number | null | undefined, fromDoc: number | null | undefined, toDoc: number | null | undefined, locId: number | null | undefined): Observable<CashReceiptModel[]> {
        let url_ = this.baseUrl + "/api/services/app/CashReceiptReport/GetCashReceipt?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (fromConfigId !== undefined)
            url_ += "fromConfigId=" + encodeURIComponent("" + fromConfigId) + "&";
        if (toConfigId !== undefined)
            url_ += "toConfigId=" + encodeURIComponent("" + toConfigId) + "&";
        if (fromDoc !== undefined)
            url_ += "fromDoc=" + encodeURIComponent("" + fromDoc) + "&";
        if (toDoc !== undefined)
            url_ += "toDoc=" + encodeURIComponent("" + toDoc) + "&";
        if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCashReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCashReceipt(<any>response_);
                } catch (e) {
                    return <Observable<CashReceiptModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CashReceiptModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCashReceipt(response: HttpResponseBase): Observable<CashReceiptModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CashReceiptModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CashReceiptModel[]>(<any>null);
    }
}

@Injectable()
export class ChartOfACListingReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional)
     * @return Success
     */
    getChartOfAccountsData(tenantId: number | null | undefined): Observable<ChartOfAccountListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfACListingReport/GetChartOfAccountsData?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChartOfAccountsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartOfAccountsData(<any>response_);
                } catch (e) {
                    return <Observable<ChartOfAccountListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartOfAccountListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChartOfAccountsData(response: HttpResponseBase): Observable<ChartOfAccountListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ChartOfAccountListDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartOfAccountListDto[]>(<any>null);
    }

    /**
     * @param tenantId (optional)
     * @return Success
     */
    getSubLedgerData(tenantId: number | null | undefined): Observable<SubledgerListDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ChartOfACListingReport/GetSubLedgerData?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubLedgerData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubLedgerData(<any>response_);
                } catch (e) {
                    return <Observable<SubledgerListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubledgerListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubLedgerData(response: HttpResponseBase): Observable<SubledgerListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SubledgerListDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubledgerListDto[]>(<any>null);
    }
}

@Injectable()
export class ChartofControlsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param accountIDFilter (optional)
     * @param accountNameFilter (optional)
     * @param subLedgerFilter (optional)
     * @param maxOptFldFilter (optional)
     * @param minOptFldFilter (optional)
     * @param maxSLTypeFilter (optional)
     * @param minSLTypeFilter (optional)
     * @param inactiveFilter (optional)
     * @param maxCreationDateFilter (optional)
     * @param minCreationDateFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditTimeFilter (optional)
     * @param minAuditTimeFilter (optional)
     * @param oldCodeFilter (optional)
     * @param controlDetailSegmentNameFilter (optional)
     * @param subControlDetailSegmentNameFilter (optional)
     * @param segmentlevel3SegmentNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, accountIDFilter: string | null | undefined, accountNameFilter: string | null | undefined, subLedgerFilter: number | null | undefined, maxOptFldFilter: number | null | undefined, minOptFldFilter: number | null | undefined, maxSLTypeFilter: number | null | undefined, minSLTypeFilter: number | null | undefined, inactiveFilter: number | null | undefined, maxCreationDateFilter: moment.Moment | null | undefined, minCreationDateFilter: moment.Moment | null | undefined, auditUserFilter: string | null | undefined, maxAuditTimeFilter: moment.Moment | null | undefined, minAuditTimeFilter: moment.Moment | null | undefined, oldCodeFilter: string | null | undefined, controlDetailSegmentNameFilter: string | null | undefined, subControlDetailSegmentNameFilter: string | null | undefined, segmentlevel3SegmentNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetChartofControlForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&";
        if (subLedgerFilter !== undefined)
            url_ += "SubLedgerFilter=" + encodeURIComponent("" + subLedgerFilter) + "&";
        if (maxOptFldFilter !== undefined)
            url_ += "MaxOptFldFilter=" + encodeURIComponent("" + maxOptFldFilter) + "&";
        if (minOptFldFilter !== undefined)
            url_ += "MinOptFldFilter=" + encodeURIComponent("" + minOptFldFilter) + "&";
        if (maxSLTypeFilter !== undefined)
            url_ += "MaxSLTypeFilter=" + encodeURIComponent("" + maxSLTypeFilter) + "&";
        if (minSLTypeFilter !== undefined)
            url_ += "MinSLTypeFilter=" + encodeURIComponent("" + minSLTypeFilter) + "&";
        if (inactiveFilter !== undefined)
            url_ += "InactiveFilter=" + encodeURIComponent("" + inactiveFilter) + "&";
        if (maxCreationDateFilter !== undefined)
            url_ += "MaxCreationDateFilter=" + encodeURIComponent(maxCreationDateFilter ? "" + maxCreationDateFilter.toJSON() : "") + "&";
        if (minCreationDateFilter !== undefined)
            url_ += "MinCreationDateFilter=" + encodeURIComponent(minCreationDateFilter ? "" + minCreationDateFilter.toJSON() : "") + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditTimeFilter !== undefined)
            url_ += "MaxAuditTimeFilter=" + encodeURIComponent(maxAuditTimeFilter ? "" + maxAuditTimeFilter.toJSON() : "") + "&";
        if (minAuditTimeFilter !== undefined)
            url_ += "MinAuditTimeFilter=" + encodeURIComponent(minAuditTimeFilter ? "" + minAuditTimeFilter.toJSON() : "") + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (controlDetailSegmentNameFilter !== undefined)
            url_ += "ControlDetailSegmentNameFilter=" + encodeURIComponent("" + controlDetailSegmentNameFilter) + "&";
        if (subControlDetailSegmentNameFilter !== undefined)
            url_ += "SubControlDetailSegmentNameFilter=" + encodeURIComponent("" + subControlDetailSegmentNameFilter) + "&";
        if (segmentlevel3SegmentNameFilter !== undefined)
            url_ += "Segmentlevel3SegmentNameFilter=" + encodeURIComponent("" + segmentlevel3SegmentNameFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetChartofControlForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetChartofControlForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetChartofControlForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetChartofControlForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetChartofControlForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetChartofControlForViewDto>(<any>null);
    }
    updateAccountList(input: CreateOrEditSubControlDetailDto | null | undefined){
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/updateaccount";
       
        return this.http.post(url_,input);
    }
    updateAccount(input:  CreateOrEditChartofControlDto | null | undefined){
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/updateSettingschartofAccount";
       
        return this.http.post(url_,input);
    }
    getBSCategoryList(input: string | null | undefined){
        let url_ = this.baseUrl + "/api/services/app/GLBSCtg/getBSCategoryList?";
        if (input !== undefined)
        url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }
    getCFCategoryList(input: string | null | undefined){
        let url_ = this.baseUrl + "/api/services/app/GLBSCtg/getCFCategoryList?";
        if (input !== undefined)
        url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }
    /**
     * @param id (optional)
     * @return Success
     */
    getChartofControlForView(id: string | null | undefined): Observable<GetChartofControlForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetChartofControlForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChartofControlForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartofControlForView(<any>response_);
                } catch (e) {
                    return <Observable<GetChartofControlForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetChartofControlForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChartofControlForView(response: HttpResponseBase): Observable<GetChartofControlForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetChartofControlForViewDto.fromJS(resultData200) : new GetChartofControlForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetChartofControlForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getChartofControlForEdit(id: string | null | undefined): Observable<GetChartofControlForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetChartofControlForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChartofControlForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartofControlForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetChartofControlForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetChartofControlForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetChartofControlForEdit(response: HttpResponseBase): Observable<GetChartofControlForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetChartofControlForEditOutput.fromJS(resultData200) : new GetChartofControlForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetChartofControlForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditChartofControlDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param iD (optional)
     * @return Success
     */
    getListAccountCode(iD: string | null | undefined): Observable<ListResultDtoOfSegmentCodeDtoView> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetListAccountCode?";
        if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetListAccountCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAccountCode(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSegmentCodeDtoView>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSegmentCodeDtoView>><any>_observableThrow(response_);
        }));
    }

    protected processGetListAccountCode(response: HttpResponseBase): Observable<ListResultDtoOfSegmentCodeDtoView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfSegmentCodeDtoView.fromJS(resultData200) : new ListResultDtoOfSegmentCodeDtoView();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSegmentCodeDtoView>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param iDFilter (optional)
     * @param accountNameFilter (optional)
     * @param subLedgerFilter (optional)
     * @param maxOptFldFilter (optional)
     * @param minOptFldFilter (optional)
     * @param maxSLTypeFilter (optional)
     * @param minSLTypeFilter (optional)
     * @param inactiveFilter (optional)
     * @param maxCreationDateFilter (optional)
     * @param minCreationDateFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditTimeFilter (optional)
     * @param minAuditTimeFilter (optional)
     * @param oldCodeFilter (optional)
     * @param controlDetailSegmentNameFilter (optional)
     * @param subControlDetailSegmentNameFilter (optional)
     * @param segmentlevel3SegmentNameFilter (optional)
     * @return Success
     */
    getChartofControlsToExcel(filter: string | null | undefined, iDFilter: string | null | undefined, accountNameFilter: string | null | undefined, subLedgerFilter: number | null | undefined, maxOptFldFilter: number | null | undefined, minOptFldFilter: number | null | undefined, maxSLTypeFilter: number | null | undefined, minSLTypeFilter: number | null | undefined, inactiveFilter: number | null | undefined, maxCreationDateFilter: moment.Moment | null | undefined, minCreationDateFilter: moment.Moment | null | undefined, auditUserFilter: string | null | undefined, maxAuditTimeFilter: moment.Moment | null | undefined, minAuditTimeFilter: moment.Moment | null | undefined, oldCodeFilter: string | null | undefined, controlDetailSegmentNameFilter: string | null | undefined, subControlDetailSegmentNameFilter: string | null | undefined, segmentlevel3SegmentNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetChartofControlsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (iDFilter !== undefined)
            url_ += "IDFilter=" + encodeURIComponent("" + iDFilter) + "&";
        if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&";
        if (subLedgerFilter !== undefined)
            url_ += "SubLedgerFilter=" + encodeURIComponent("" + subLedgerFilter) + "&";
        if (maxOptFldFilter !== undefined)
            url_ += "MaxOptFldFilter=" + encodeURIComponent("" + maxOptFldFilter) + "&";
        if (minOptFldFilter !== undefined)
            url_ += "MinOptFldFilter=" + encodeURIComponent("" + minOptFldFilter) + "&";
        if (maxSLTypeFilter !== undefined)
            url_ += "MaxSLTypeFilter=" + encodeURIComponent("" + maxSLTypeFilter) + "&";
        if (minSLTypeFilter !== undefined)
            url_ += "MinSLTypeFilter=" + encodeURIComponent("" + minSLTypeFilter) + "&";
        if (inactiveFilter !== undefined)
            url_ += "InactiveFilter=" + encodeURIComponent("" + inactiveFilter) + "&";
        if (maxCreationDateFilter !== undefined)
            url_ += "MaxCreationDateFilter=" + encodeURIComponent(maxCreationDateFilter ? "" + maxCreationDateFilter.toJSON() : "") + "&";
        if (minCreationDateFilter !== undefined)
            url_ += "MinCreationDateFilter=" + encodeURIComponent(minCreationDateFilter ? "" + minCreationDateFilter.toJSON() : "") + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditTimeFilter !== undefined)
            url_ += "MaxAuditTimeFilter=" + encodeURIComponent(maxAuditTimeFilter ? "" + maxAuditTimeFilter.toJSON() : "") + "&";
        if (minAuditTimeFilter !== undefined)
            url_ += "MinAuditTimeFilter=" + encodeURIComponent(minAuditTimeFilter ? "" + minAuditTimeFilter.toJSON() : "") + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (controlDetailSegmentNameFilter !== undefined)
            url_ += "ControlDetailSegmentNameFilter=" + encodeURIComponent("" + controlDetailSegmentNameFilter) + "&";
        if (subControlDetailSegmentNameFilter !== undefined)
            url_ += "SubControlDetailSegmentNameFilter=" + encodeURIComponent("" + subControlDetailSegmentNameFilter) + "&";
        if (segmentlevel3SegmentNameFilter !== undefined)
            url_ += "Segmentlevel3SegmentNameFilter=" + encodeURIComponent("" + segmentlevel3SegmentNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChartofControlsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartofControlsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChartofControlsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllControlDetailForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfChartofControlControlDetailLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetAllControlDetailForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllControlDetailForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllControlDetailForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfChartofControlControlDetailLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfChartofControlControlDetailLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllControlDetailForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfChartofControlControlDetailLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfChartofControlControlDetailLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfChartofControlControlDetailLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfChartofControlControlDetailLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @param seg1ID (optional)
     * @return Success
     */
    getAllSubControlDetailForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, seg1ID: string | null | undefined): Observable<PagedResultDtoOfChartofControlSubControlDetailLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetAllSubControlDetailForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (seg1ID !== undefined)
            url_ += "Seg1ID=" + encodeURIComponent("" + seg1ID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllSubControlDetailForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubControlDetailForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfChartofControlSubControlDetailLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfChartofControlSubControlDetailLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubControlDetailForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfChartofControlSubControlDetailLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfChartofControlSubControlDetailLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfChartofControlSubControlDetailLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfChartofControlSubControlDetailLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @param seg2ID (optional)
     * @return Success
     */
    getAllSegmentlevel3ForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, seg2ID: string | null | undefined): Observable<PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetAllSegmentlevel3ForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (seg2ID !== undefined)
            url_ += "Seg2ID=" + encodeURIComponent("" + seg2ID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllSegmentlevel3ForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSegmentlevel3ForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSegmentlevel3ForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto.fromJS(resultData200) : new PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getMaxAcccountID(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetMaxAcccountID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMaxAcccountID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxAcccountID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxAcccountID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getSegmentName(): Observable<PagedResultDtoOfGetGLOptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetSegmentName";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSegmentName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentName(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLOptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLOptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentName(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLOptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLOptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLOptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLOptionForViewDto>(<any>null);
    }


    getAccountsForDropdown(filter: string | null | undefined): Observable<NameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/ChartofControls/GetAccountsForDropdown";
        if (filter !== undefined)
            url_ += "id=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountsForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsForDropdown(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountsForDropdown(response: HttpResponseBase): Observable<NameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLOptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLOptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto>(<any>null);
    }

}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional)
     * @param userId (optional)
     * @param minMessageId (optional)
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional)
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }

    // findICSegment1(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto>{
    //     let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindICSegment1";
    //     url_ = url_.replace(/[?&]$/, "");
    //     const content_ = JSON.stringify(input);

    //     let options_: any ={
    //         body: content_,
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Content-Type": "application/json",
    //             "Accept": "application/json"
    //         })
    //     }

    //     return this.http.request("post",options_).pipe(_observableMergeMap((response_:any) => {
    //         return this.processFindICSegment1(response_);
    //         })).pipe(_observableCatch((response_: any) => {
    //             if (response_ instanceof HttpResponseBase) {
    //                 try {
    //                     return this.processFindICSegment1(<any>response_);
    //                 } catch (e) {
    //                     return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
    //                 }
    //             } else {
    //                 return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
    //             }
    //         }))


    // }

    // protected processFindICSegment1(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    // }


    // findICSegment2(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto>{
    //     let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindICSegment1";
    //     url_ = url_.replace(/[?&]$/, "");
    //     const content_ = JSON.stringify(input);

    //     let options_: any ={
    //         body: content_,
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Content-Type": "application/json",
    //             "Accept": "application/json"
    //         })
    //     }

    //     return this.http.request("post",options_).pipe(_observableMergeMap((response_:any) => {
    //         return this.processFindICSegment2(response_);
    //         })).pipe(_observableCatch((response_: any) => {
    //             if (response_ instanceof HttpResponseBase) {
    //                 try {
    //                     return this.processFindICSegment2(<any>response_);
    //                 } catch (e) {
    //                     return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
    //                 }
    //             } else {
    //                 return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
    //             }
    //         }))


    // }

    // protected processFindICSegment2(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    // }

    // findICSegment3(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto>{
    //     let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindICSegment1";
    //     url_ = url_.replace(/[?&]$/, "");
    //     const content_ = JSON.stringify(input);

    //     let options_: any ={
    //         body: content_,
    //         observe: "response",
    //         responseType: "blob",
    //         headers: new HttpHeaders({
    //             "Content-Type": "application/json",
    //             "Accept": "application/json"
    //         })
    //     }

    //     return this.http.request("post",options_).pipe(_observableMergeMap((response_:any) => {
    //         return this.processFindICSegment3(response_);
    //         })).pipe(_observableCatch((response_: any) => {
    //             if (response_ instanceof HttpResponseBase) {
    //                 try {
    //                     return this.processFindICSegment3(<any>response_);
    //                 } catch (e) {
    //                     return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
    //                 }
    //             } else {
    //                 return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
    //             }
    //         }))


    // }

    // protected processFindICSegment3(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
    //     const status = response.status;
    //     const responseBlob =
    //         response instanceof HttpResponse ? response.body :
    //         (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    //     let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
    //     if (status === 200) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         let result200: any = null;
    //         let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
    //         result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
    //         return _observableOf(result200);
    //         }));
    //     } else if (status !== 200 && status !== 204) {
    //         return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
    //         return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    //         }));
    //     }
    //     return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    // }
}

@Injectable()
export class CommonReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCommonReportData(): Observable<CommonReportData[]> {
        let url_ = this.baseUrl + "/api/services/app/CommonReport/GetCommonReportData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCommonReportData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCommonReportData(<any>response_);
                } catch (e) {
                    return <Observable<CommonReportData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CommonReportData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCommonReportData(response: HttpResponseBase): Observable<CommonReportData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(CommonReportData.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommonReportData[]>(<any>null);
    }
}

@Injectable()
export class CompanyProfilesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param companyNameFilter (optional)
     * @param phoneFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, companyNameFilter: string | null | undefined, phoneFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCompanyProfileForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyProfiles/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (companyNameFilter !== undefined)
            url_ += "CompanyNameFilter=" + encodeURIComponent("" + companyNameFilter) + "&";
        if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCompanyProfileForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCompanyProfileForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCompanyProfileForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetCompanyProfileForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetCompanyProfileForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCompanyProfileForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getCompanyProfileForView(id: string | null | undefined): Observable<GetCompanyProfileForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyProfiles/GetCompanyProfileForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCompanyProfileForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyProfileForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCompanyProfileForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCompanyProfileForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyProfileForView(response: HttpResponseBase): Observable<GetCompanyProfileForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCompanyProfileForViewDto.fromJS(resultData200) : new GetCompanyProfileForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCompanyProfileForViewDto>(<any>null);
    }

    getImage(appID: number, docID: number): Observable<List<BinaryData>> {

        debugger;
        let url_ = this.baseUrl + "/DemoUiComponents/GetImageData?";
        if (appID !== undefined)
            url_ += "AppID=" + encodeURIComponent("" + appID) + "&";
        if (docID !== undefined)
            url_ += "DocID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImage(<any>response_);
                } catch (e) {
                    return <Observable<List<BinaryData>>><any>_observableThrow(e);
                }
            } else
                return <Observable<List<BinaryData>>><any>_observableThrow(response_);
        }));
    }

    protected processGetImage(response: HttpResponseBase): Observable<List<BinaryData>> {
        debugger;
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<List<BinaryData>>(<any>null);

    }
    /**
     * @param id (optional)
     * @return Success
     */
    getCompanyProfileForEdit(id: string | null | undefined): Observable<GetCompanyProfileForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CompanyProfiles/GetCompanyProfileForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCompanyProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCompanyProfileForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCompanyProfileForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyProfileForEdit(response: HttpResponseBase): Observable<GetCompanyProfileForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCompanyProfileForEditOutput.fromJS(resultData200) : new GetCompanyProfileForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCompanyProfileForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditCompanyProfileDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyProfiles/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CompanyProfiles/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param companyNameFilter (optional)
     * @param phoneFilter (optional)
     * @return Success
     */
    getCompanyProfilesToExcel(filter: string | null | undefined, companyNameFilter: string | null | undefined, phoneFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyProfiles/GetCompanyProfilesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (companyNameFilter !== undefined)
            url_ += "CompanyNameFilter=" + encodeURIComponent("" + companyNameFilter) + "&";
        if (phoneFilter !== undefined)
            url_ += "PhoneFilter=" + encodeURIComponent("" + phoneFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCompanyProfilesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyProfilesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyProfilesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    GetReportPath() {
        return this.http.request("get", this.baseUrl + "/api/services/app/CompanyProfiles/GetReportPath");
    }
}

@Injectable()
export class ControlDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param seg1IDFilter (optional)
     * @param segmentNameFilter (optional)
     * @param familyFilter (optional)
     * @param oldCodeFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, seg1IDFilter: string | null | undefined, segmentNameFilter: string | null | undefined, familyFilter: string | null | undefined, oldCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetControlDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (seg1IDFilter !== undefined)
            url_ += "Seg1IDFilter=" + encodeURIComponent("" + seg1IDFilter) + "&";
        if (segmentNameFilter !== undefined)
            url_ += "SegmentNameFilter=" + encodeURIComponent("" + segmentNameFilter) + "&";
        if (familyFilter !== undefined)
            url_ += "FamilyFilter=" + encodeURIComponent("" + familyFilter) + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetControlDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetControlDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetControlDetailForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetControlDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetControlDetailForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetControlDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getControlDetailForView(id: number | null | undefined): Observable<GetControlDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/GetControlDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetControlDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetControlDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetControlDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetControlDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetControlDetailForView(response: HttpResponseBase): Observable<GetControlDetailForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetControlDetailForViewDto.fromJS(resultData200) : new GetControlDetailForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetControlDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getControlDetailForEdit(id: number | null | undefined): Observable<GetControlDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/GetControlDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetControlDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetControlDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetControlDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetControlDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetControlDetailForEdit(response: HttpResponseBase): Observable<GetControlDetailForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetControlDetailForEditOutput.fromJS(resultData200) : new GetControlDetailForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetControlDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditControlDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param seg1IDFilter (optional)
     * @param segmentNameFilter (optional)
     * @param familyFilter (optional)
     * @param oldCodeFilter (optional)
     * @return Success
     */
    getControlDetailsToExcel(filter: string | null | undefined, seg1IDFilter: string | null | undefined, segmentNameFilter: string | null | undefined, familyFilter: string | null | undefined, oldCodeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/GetControlDetailsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (seg1IDFilter !== undefined)
            url_ += "Seg1IDFilter=" + encodeURIComponent("" + seg1IDFilter) + "&";
        if (segmentNameFilter !== undefined)
            url_ += "SegmentNameFilter=" + encodeURIComponent("" + segmentNameFilter) + "&";
        if (familyFilter !== undefined)
            url_ += "FamilyFilter=" + encodeURIComponent("" + familyFilter) + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetControlDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetControlDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetControlDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    conDetailMaxid(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/ControlDetails/ConDetailMaxid";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processConDetailMaxid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConDetailMaxid(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processConDetailMaxid(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CurrencyRatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param cURIDFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param cURNAMEFilter (optional)
     * @param sYMBOLFilter (optional)
     * @param maxRATEDATEFilter (optional)
     * @param minRATEDATEFilter (optional)
     * @param maxCURRATEFilter (optional)
     * @param minCURRATEFilter (optional)
     * @param companyProfileCompanyNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, cMPIDFilter: string | null | undefined, cURIDFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, cURNAMEFilter: string | null | undefined, sYMBOLFilter: string | null | undefined, maxRATEDATEFilter: moment.Moment | null | undefined, minRATEDATEFilter: moment.Moment | null | undefined, maxCURRATEFilter: number | null | undefined, minCURRATEFilter: number | null | undefined, companyProfileCompanyNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCurrencyRateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (cURIDFilter !== undefined)
            url_ += "CURIDFilter=" + encodeURIComponent("" + cURIDFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (cURNAMEFilter !== undefined)
            url_ += "CURNAMEFilter=" + encodeURIComponent("" + cURNAMEFilter) + "&";
        if (sYMBOLFilter !== undefined)
            url_ += "SYMBOLFilter=" + encodeURIComponent("" + sYMBOLFilter) + "&";
        if (maxRATEDATEFilter !== undefined)
            url_ += "MaxRATEDATEFilter=" + encodeURIComponent(maxRATEDATEFilter ? "" + maxRATEDATEFilter.toJSON() : "") + "&";
        if (minRATEDATEFilter !== undefined)
            url_ += "MinRATEDATEFilter=" + encodeURIComponent(minRATEDATEFilter ? "" + minRATEDATEFilter.toJSON() : "") + "&";
        if (maxCURRATEFilter !== undefined)
            url_ += "MaxCURRATEFilter=" + encodeURIComponent("" + maxCURRATEFilter) + "&";
        if (minCURRATEFilter !== undefined)
            url_ += "MinCURRATEFilter=" + encodeURIComponent("" + minCURRATEFilter) + "&";
        if (companyProfileCompanyNameFilter !== undefined)
            url_ += "CompanyProfileCompanyNameFilter=" + encodeURIComponent("" + companyProfileCompanyNameFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCurrencyRateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCurrencyRateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCurrencyRateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetCurrencyRateForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetCurrencyRateForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCurrencyRateForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getCurrencyRateForView(id: string | null | undefined): Observable<GetCurrencyRateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/GetCurrencyRateForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrencyRateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyRateForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrencyRateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrencyRateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyRateForView(response: HttpResponseBase): Observable<GetCurrencyRateForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCurrencyRateForViewDto.fromJS(resultData200) : new GetCurrencyRateForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyRateForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getCurrencyRateForEdit(id: string | null | undefined): Observable<GetCurrencyRateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/GetCurrencyRateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrencyRateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyRateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrencyRateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrencyRateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyRateForEdit(response: HttpResponseBase): Observable<GetCurrencyRateForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCurrencyRateForEditOutput.fromJS(resultData200) : new GetCurrencyRateForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyRateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditCurrencyRateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param cURIDFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param cURNAMEFilter (optional)
     * @param sYMBOLFilter (optional)
     * @param maxRATEDATEFilter (optional)
     * @param minRATEDATEFilter (optional)
     * @param maxCURRATEFilter (optional)
     * @param minCURRATEFilter (optional)
     * @param companyProfileCompanyNameFilter (optional)
     * @return Success
     */
    getCurrencyRatesToExcel(filter: string | null | undefined, cMPIDFilter: string | null | undefined, cURIDFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, cURNAMEFilter: string | null | undefined, sYMBOLFilter: string | null | undefined, maxRATEDATEFilter: moment.Moment | null | undefined, minRATEDATEFilter: moment.Moment | null | undefined, maxCURRATEFilter: number | null | undefined, minCURRATEFilter: number | null | undefined, companyProfileCompanyNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/GetCurrencyRatesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (cURIDFilter !== undefined)
            url_ += "CURIDFilter=" + encodeURIComponent("" + cURIDFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (cURNAMEFilter !== undefined)
            url_ += "CURNAMEFilter=" + encodeURIComponent("" + cURNAMEFilter) + "&";
        if (sYMBOLFilter !== undefined)
            url_ += "SYMBOLFilter=" + encodeURIComponent("" + sYMBOLFilter) + "&";
        if (maxRATEDATEFilter !== undefined)
            url_ += "MaxRATEDATEFilter=" + encodeURIComponent(maxRATEDATEFilter ? "" + maxRATEDATEFilter.toJSON() : "") + "&";
        if (minRATEDATEFilter !== undefined)
            url_ += "MinRATEDATEFilter=" + encodeURIComponent(minRATEDATEFilter ? "" + minRATEDATEFilter.toJSON() : "") + "&";
        if (maxCURRATEFilter !== undefined)
            url_ += "MaxCURRATEFilter=" + encodeURIComponent("" + maxCURRATEFilter) + "&";
        if (minCURRATEFilter !== undefined)
            url_ += "MinCURRATEFilter=" + encodeURIComponent("" + minCURRATEFilter) + "&";
        if (companyProfileCompanyNameFilter !== undefined)
            url_ += "CompanyProfileCompanyNameFilter=" + encodeURIComponent("" + companyProfileCompanyNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrencyRatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyRatesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyRatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllCompanyProfileForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CurrencyRates/GetAllCompanyProfileForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllCompanyProfileForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompanyProfileForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCompanyProfileForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional)
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional)
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional)
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(NameValueOfString.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional)
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(NameValueOfString.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createEdition(input: CreateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateEdition(input: UpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional)
     * @param addAllItem (optional)
     * @param onlyFreeItems (optional)
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional)
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class FiscalCalendarsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param maxPERIODSFilter (optional)
     * @param minPERIODSFilter (optional)
     * @param maxQTR4PERDFilter (optional)
     * @param minQTR4PERDFilter (optional)
     * @param maxACTIVEFilter (optional)
     * @param minACTIVEFilter (optional)
     * @param maxBGNDATE1Filter (optional)
     * @param minBGNDATE1Filter (optional)
     * @param maxBGNDATE2Filter (optional)
     * @param minBGNDATE2Filter (optional)
     * @param maxBGNDATE3Filter (optional)
     * @param minBGNDATE3Filter (optional)
     * @param maxBGNDATE4Filter (optional)
     * @param minBGNDATE4Filter (optional)
     * @param maxBGNDATE5Filter (optional)
     * @param minBGNDATE5Filter (optional)
     * @param maxBGNDATE6Filter (optional)
     * @param minBGNDATE6Filter (optional)
     * @param maxBGNDATE7Filter (optional)
     * @param minBGNDATE7Filter (optional)
     * @param maxBGNDATE8Filter (optional)
     * @param minBGNDATE8Filter (optional)
     * @param maxBGNDATE9Filter (optional)
     * @param minBGNDATE9Filter (optional)
     * @param maxBGNDATE10Filter (optional)
     * @param minBGNDATE10Filter (optional)
     * @param maxBGNDATE11Filter (optional)
     * @param minBGNDATE11Filter (optional)
     * @param maxBGNDATE12Filter (optional)
     * @param minBGNDATE12Filter (optional)
     * @param maxBGNDATE13Filter (optional)
     * @param minBGNDATE13Filter (optional)
     * @param maxENDDATE1Filter (optional)
     * @param minENDDATE1Filter (optional)
     * @param maxENDDATE2Filter (optional)
     * @param minENDDATE2Filter (optional)
     * @param maxENDDATE3Filter (optional)
     * @param minENDDATE3Filter (optional)
     * @param maxENDDATE4Filter (optional)
     * @param minENDDATE4Filter (optional)
     * @param maxENDDATE5Filter (optional)
     * @param minENDDATE5Filter (optional)
     * @param maxENDDATE6Filter (optional)
     * @param minENDDATE6Filter (optional)
     * @param maxENDDATE7Filter (optional)
     * @param minENDDATE7Filter (optional)
     * @param maxENDDATE8Filter (optional)
     * @param minENDDATE8Filter (optional)
     * @param maxENDDATE9Filter (optional)
     * @param minENDDATE9Filter (optional)
     * @param maxENDDATE10Filter (optional)
     * @param minENDDATE10Filter (optional)
     * @param maxENDDATE11Filter (optional)
     * @param minENDDATE11Filter (optional)
     * @param maxENDDATE12Filter (optional)
     * @param minENDDATE12Filter (optional)
     * @param maxENDDATE13Filter (optional)
     * @param minENDDATE13Filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, maxPERIODSFilter: number | null | undefined, minPERIODSFilter: number | null | undefined, maxQTR4PERDFilter: number | null | undefined, minQTR4PERDFilter: number | null | undefined, maxACTIVEFilter: number | null | undefined, minACTIVEFilter: number | null | undefined, maxBGNDATE1Filter: moment.Moment | null | undefined, minBGNDATE1Filter: moment.Moment | null | undefined, maxBGNDATE2Filter: moment.Moment | null | undefined, minBGNDATE2Filter: moment.Moment | null | undefined, maxBGNDATE3Filter: moment.Moment | null | undefined, minBGNDATE3Filter: moment.Moment | null | undefined, maxBGNDATE4Filter: moment.Moment | null | undefined, minBGNDATE4Filter: moment.Moment | null | undefined, maxBGNDATE5Filter: moment.Moment | null | undefined, minBGNDATE5Filter: moment.Moment | null | undefined, maxBGNDATE6Filter: moment.Moment | null | undefined, minBGNDATE6Filter: moment.Moment | null | undefined, maxBGNDATE7Filter: moment.Moment | null | undefined, minBGNDATE7Filter: moment.Moment | null | undefined, maxBGNDATE8Filter: moment.Moment | null | undefined, minBGNDATE8Filter: moment.Moment | null | undefined, maxBGNDATE9Filter: moment.Moment | null | undefined, minBGNDATE9Filter: moment.Moment | null | undefined, maxBGNDATE10Filter: moment.Moment | null | undefined, minBGNDATE10Filter: moment.Moment | null | undefined, maxBGNDATE11Filter: moment.Moment | null | undefined, minBGNDATE11Filter: moment.Moment | null | undefined, maxBGNDATE12Filter: moment.Moment | null | undefined, minBGNDATE12Filter: moment.Moment | null | undefined, maxBGNDATE13Filter: moment.Moment | null | undefined, minBGNDATE13Filter: moment.Moment | null | undefined, maxENDDATE1Filter: moment.Moment | null | undefined, minENDDATE1Filter: moment.Moment | null | undefined, maxENDDATE2Filter: moment.Moment | null | undefined, minENDDATE2Filter: moment.Moment | null | undefined, maxENDDATE3Filter: moment.Moment | null | undefined, minENDDATE3Filter: moment.Moment | null | undefined, maxENDDATE4Filter: moment.Moment | null | undefined, minENDDATE4Filter: moment.Moment | null | undefined, maxENDDATE5Filter: moment.Moment | null | undefined, minENDDATE5Filter: moment.Moment | null | undefined, maxENDDATE6Filter: moment.Moment | null | undefined, minENDDATE6Filter: moment.Moment | null | undefined, maxENDDATE7Filter: moment.Moment | null | undefined, minENDDATE7Filter: moment.Moment | null | undefined, maxENDDATE8Filter: moment.Moment | null | undefined, minENDDATE8Filter: moment.Moment | null | undefined, maxENDDATE9Filter: moment.Moment | null | undefined, minENDDATE9Filter: moment.Moment | null | undefined, maxENDDATE10Filter: moment.Moment | null | undefined, minENDDATE10Filter: moment.Moment | null | undefined, maxENDDATE11Filter: moment.Moment | null | undefined, minENDDATE11Filter: moment.Moment | null | undefined, maxENDDATE12Filter: moment.Moment | null | undefined, minENDDATE12Filter: moment.Moment | null | undefined, maxENDDATE13Filter: moment.Moment | null | undefined, minENDDATE13Filter: moment.Moment | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetFiscalCalendarForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalendars/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (maxPERIODSFilter !== undefined)
            url_ += "MaxPERIODSFilter=" + encodeURIComponent("" + maxPERIODSFilter) + "&";
        if (minPERIODSFilter !== undefined)
            url_ += "MinPERIODSFilter=" + encodeURIComponent("" + minPERIODSFilter) + "&";
        if (maxQTR4PERDFilter !== undefined)
            url_ += "MaxQTR4PERDFilter=" + encodeURIComponent("" + maxQTR4PERDFilter) + "&";
        if (minQTR4PERDFilter !== undefined)
            url_ += "MinQTR4PERDFilter=" + encodeURIComponent("" + minQTR4PERDFilter) + "&";
        if (maxACTIVEFilter !== undefined)
            url_ += "MaxACTIVEFilter=" + encodeURIComponent("" + maxACTIVEFilter) + "&";
        if (minACTIVEFilter !== undefined)
            url_ += "MinACTIVEFilter=" + encodeURIComponent("" + minACTIVEFilter) + "&";
        if (maxBGNDATE1Filter !== undefined)
            url_ += "MaxBGNDATE1Filter=" + encodeURIComponent(maxBGNDATE1Filter ? "" + maxBGNDATE1Filter.toJSON() : "") + "&";
        if (minBGNDATE1Filter !== undefined)
            url_ += "MinBGNDATE1Filter=" + encodeURIComponent(minBGNDATE1Filter ? "" + minBGNDATE1Filter.toJSON() : "") + "&";
        if (maxBGNDATE2Filter !== undefined)
            url_ += "MaxBGNDATE2Filter=" + encodeURIComponent(maxBGNDATE2Filter ? "" + maxBGNDATE2Filter.toJSON() : "") + "&";
        if (minBGNDATE2Filter !== undefined)
            url_ += "MinBGNDATE2Filter=" + encodeURIComponent(minBGNDATE2Filter ? "" + minBGNDATE2Filter.toJSON() : "") + "&";
        if (maxBGNDATE3Filter !== undefined)
            url_ += "MaxBGNDATE3Filter=" + encodeURIComponent(maxBGNDATE3Filter ? "" + maxBGNDATE3Filter.toJSON() : "") + "&";
        if (minBGNDATE3Filter !== undefined)
            url_ += "MinBGNDATE3Filter=" + encodeURIComponent(minBGNDATE3Filter ? "" + minBGNDATE3Filter.toJSON() : "") + "&";
        if (maxBGNDATE4Filter !== undefined)
            url_ += "MaxBGNDATE4Filter=" + encodeURIComponent(maxBGNDATE4Filter ? "" + maxBGNDATE4Filter.toJSON() : "") + "&";
        if (minBGNDATE4Filter !== undefined)
            url_ += "MinBGNDATE4Filter=" + encodeURIComponent(minBGNDATE4Filter ? "" + minBGNDATE4Filter.toJSON() : "") + "&";
        if (maxBGNDATE5Filter !== undefined)
            url_ += "MaxBGNDATE5Filter=" + encodeURIComponent(maxBGNDATE5Filter ? "" + maxBGNDATE5Filter.toJSON() : "") + "&";
        if (minBGNDATE5Filter !== undefined)
            url_ += "MinBGNDATE5Filter=" + encodeURIComponent(minBGNDATE5Filter ? "" + minBGNDATE5Filter.toJSON() : "") + "&";
        if (maxBGNDATE6Filter !== undefined)
            url_ += "MaxBGNDATE6Filter=" + encodeURIComponent(maxBGNDATE6Filter ? "" + maxBGNDATE6Filter.toJSON() : "") + "&";
        if (minBGNDATE6Filter !== undefined)
            url_ += "MinBGNDATE6Filter=" + encodeURIComponent(minBGNDATE6Filter ? "" + minBGNDATE6Filter.toJSON() : "") + "&";
        if (maxBGNDATE7Filter !== undefined)
            url_ += "MaxBGNDATE7Filter=" + encodeURIComponent(maxBGNDATE7Filter ? "" + maxBGNDATE7Filter.toJSON() : "") + "&";
        if (minBGNDATE7Filter !== undefined)
            url_ += "MinBGNDATE7Filter=" + encodeURIComponent(minBGNDATE7Filter ? "" + minBGNDATE7Filter.toJSON() : "") + "&";
        if (maxBGNDATE8Filter !== undefined)
            url_ += "MaxBGNDATE8Filter=" + encodeURIComponent(maxBGNDATE8Filter ? "" + maxBGNDATE8Filter.toJSON() : "") + "&";
        if (minBGNDATE8Filter !== undefined)
            url_ += "MinBGNDATE8Filter=" + encodeURIComponent(minBGNDATE8Filter ? "" + minBGNDATE8Filter.toJSON() : "") + "&";
        if (maxBGNDATE9Filter !== undefined)
            url_ += "MaxBGNDATE9Filter=" + encodeURIComponent(maxBGNDATE9Filter ? "" + maxBGNDATE9Filter.toJSON() : "") + "&";
        if (minBGNDATE9Filter !== undefined)
            url_ += "MinBGNDATE9Filter=" + encodeURIComponent(minBGNDATE9Filter ? "" + minBGNDATE9Filter.toJSON() : "") + "&";
        if (maxBGNDATE10Filter !== undefined)
            url_ += "MaxBGNDATE10Filter=" + encodeURIComponent(maxBGNDATE10Filter ? "" + maxBGNDATE10Filter.toJSON() : "") + "&";
        if (minBGNDATE10Filter !== undefined)
            url_ += "MinBGNDATE10Filter=" + encodeURIComponent(minBGNDATE10Filter ? "" + minBGNDATE10Filter.toJSON() : "") + "&";
        if (maxBGNDATE11Filter !== undefined)
            url_ += "MaxBGNDATE11Filter=" + encodeURIComponent(maxBGNDATE11Filter ? "" + maxBGNDATE11Filter.toJSON() : "") + "&";
        if (minBGNDATE11Filter !== undefined)
            url_ += "MinBGNDATE11Filter=" + encodeURIComponent(minBGNDATE11Filter ? "" + minBGNDATE11Filter.toJSON() : "") + "&";
        if (maxBGNDATE12Filter !== undefined)
            url_ += "MaxBGNDATE12Filter=" + encodeURIComponent(maxBGNDATE12Filter ? "" + maxBGNDATE12Filter.toJSON() : "") + "&";
        if (minBGNDATE12Filter !== undefined)
            url_ += "MinBGNDATE12Filter=" + encodeURIComponent(minBGNDATE12Filter ? "" + minBGNDATE12Filter.toJSON() : "") + "&";
        if (maxBGNDATE13Filter !== undefined)
            url_ += "MaxBGNDATE13Filter=" + encodeURIComponent(maxBGNDATE13Filter ? "" + maxBGNDATE13Filter.toJSON() : "") + "&";
        if (minBGNDATE13Filter !== undefined)
            url_ += "MinBGNDATE13Filter=" + encodeURIComponent(minBGNDATE13Filter ? "" + minBGNDATE13Filter.toJSON() : "") + "&";
        if (maxENDDATE1Filter !== undefined)
            url_ += "MaxENDDATE1Filter=" + encodeURIComponent(maxENDDATE1Filter ? "" + maxENDDATE1Filter.toJSON() : "") + "&";
        if (minENDDATE1Filter !== undefined)
            url_ += "MinENDDATE1Filter=" + encodeURIComponent(minENDDATE1Filter ? "" + minENDDATE1Filter.toJSON() : "") + "&";
        if (maxENDDATE2Filter !== undefined)
            url_ += "MaxENDDATE2Filter=" + encodeURIComponent(maxENDDATE2Filter ? "" + maxENDDATE2Filter.toJSON() : "") + "&";
        if (minENDDATE2Filter !== undefined)
            url_ += "MinENDDATE2Filter=" + encodeURIComponent(minENDDATE2Filter ? "" + minENDDATE2Filter.toJSON() : "") + "&";
        if (maxENDDATE3Filter !== undefined)
            url_ += "MaxENDDATE3Filter=" + encodeURIComponent(maxENDDATE3Filter ? "" + maxENDDATE3Filter.toJSON() : "") + "&";
        if (minENDDATE3Filter !== undefined)
            url_ += "MinENDDATE3Filter=" + encodeURIComponent(minENDDATE3Filter ? "" + minENDDATE3Filter.toJSON() : "") + "&";
        if (maxENDDATE4Filter !== undefined)
            url_ += "MaxENDDATE4Filter=" + encodeURIComponent(maxENDDATE4Filter ? "" + maxENDDATE4Filter.toJSON() : "") + "&";
        if (minENDDATE4Filter !== undefined)
            url_ += "MinENDDATE4Filter=" + encodeURIComponent(minENDDATE4Filter ? "" + minENDDATE4Filter.toJSON() : "") + "&";
        if (maxENDDATE5Filter !== undefined)
            url_ += "MaxENDDATE5Filter=" + encodeURIComponent(maxENDDATE5Filter ? "" + maxENDDATE5Filter.toJSON() : "") + "&";
        if (minENDDATE5Filter !== undefined)
            url_ += "MinENDDATE5Filter=" + encodeURIComponent(minENDDATE5Filter ? "" + minENDDATE5Filter.toJSON() : "") + "&";
        if (maxENDDATE6Filter !== undefined)
            url_ += "MaxENDDATE6Filter=" + encodeURIComponent(maxENDDATE6Filter ? "" + maxENDDATE6Filter.toJSON() : "") + "&";
        if (minENDDATE6Filter !== undefined)
            url_ += "MinENDDATE6Filter=" + encodeURIComponent(minENDDATE6Filter ? "" + minENDDATE6Filter.toJSON() : "") + "&";
        if (maxENDDATE7Filter !== undefined)
            url_ += "MaxENDDATE7Filter=" + encodeURIComponent(maxENDDATE7Filter ? "" + maxENDDATE7Filter.toJSON() : "") + "&";
        if (minENDDATE7Filter !== undefined)
            url_ += "MinENDDATE7Filter=" + encodeURIComponent(minENDDATE7Filter ? "" + minENDDATE7Filter.toJSON() : "") + "&";
        if (maxENDDATE8Filter !== undefined)
            url_ += "MaxENDDATE8Filter=" + encodeURIComponent(maxENDDATE8Filter ? "" + maxENDDATE8Filter.toJSON() : "") + "&";
        if (minENDDATE8Filter !== undefined)
            url_ += "MinENDDATE8Filter=" + encodeURIComponent(minENDDATE8Filter ? "" + minENDDATE8Filter.toJSON() : "") + "&";
        if (maxENDDATE9Filter !== undefined)
            url_ += "MaxENDDATE9Filter=" + encodeURIComponent(maxENDDATE9Filter ? "" + maxENDDATE9Filter.toJSON() : "") + "&";
        if (minENDDATE9Filter !== undefined)
            url_ += "MinENDDATE9Filter=" + encodeURIComponent(minENDDATE9Filter ? "" + minENDDATE9Filter.toJSON() : "") + "&";
        if (maxENDDATE10Filter !== undefined)
            url_ += "MaxENDDATE10Filter=" + encodeURIComponent(maxENDDATE10Filter ? "" + maxENDDATE10Filter.toJSON() : "") + "&";
        if (minENDDATE10Filter !== undefined)
            url_ += "MinENDDATE10Filter=" + encodeURIComponent(minENDDATE10Filter ? "" + minENDDATE10Filter.toJSON() : "") + "&";
        if (maxENDDATE11Filter !== undefined)
            url_ += "MaxENDDATE11Filter=" + encodeURIComponent(maxENDDATE11Filter ? "" + maxENDDATE11Filter.toJSON() : "") + "&";
        if (minENDDATE11Filter !== undefined)
            url_ += "MinENDDATE11Filter=" + encodeURIComponent(minENDDATE11Filter ? "" + minENDDATE11Filter.toJSON() : "") + "&";
        if (maxENDDATE12Filter !== undefined)
            url_ += "MaxENDDATE12Filter=" + encodeURIComponent(maxENDDATE12Filter ? "" + maxENDDATE12Filter.toJSON() : "") + "&";
        if (minENDDATE12Filter !== undefined)
            url_ += "MinENDDATE12Filter=" + encodeURIComponent(minENDDATE12Filter ? "" + minENDDATE12Filter.toJSON() : "") + "&";
        if (maxENDDATE13Filter !== undefined)
            url_ += "MaxENDDATE13Filter=" + encodeURIComponent(maxENDDATE13Filter ? "" + maxENDDATE13Filter.toJSON() : "") + "&";
        if (minENDDATE13Filter !== undefined)
            url_ += "MinENDDATE13Filter=" + encodeURIComponent(minENDDATE13Filter ? "" + minENDDATE13Filter.toJSON() : "") + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetFiscalCalendarForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetFiscalCalendarForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetFiscalCalendarForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetFiscalCalendarForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetFiscalCalendarForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetFiscalCalendarForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getFiscalCalendarForView(id: number | null | undefined): Observable<GetFiscalCalendarForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalendars/GetFiscalCalendarForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalCalendarForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalCalendarForView(<any>response_);
                } catch (e) {
                    return <Observable<GetFiscalCalendarForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFiscalCalendarForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalCalendarForView(response: HttpResponseBase): Observable<GetFiscalCalendarForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetFiscalCalendarForViewDto.fromJS(resultData200) : new GetFiscalCalendarForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFiscalCalendarForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getFiscalCalendarForEdit(id: number | null | undefined): Observable<GetFiscalCalendarForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalendars/GetFiscalCalendarForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalCalendarForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalCalendarForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFiscalCalendarForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFiscalCalendarForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalCalendarForEdit(response: HttpResponseBase): Observable<GetFiscalCalendarForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetFiscalCalendarForEditOutput.fromJS(resultData200) : new GetFiscalCalendarForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFiscalCalendarForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditFiscalCalendarDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalendars/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalendars/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param maxPERIODSFilter (optional)
     * @param minPERIODSFilter (optional)
     * @param maxQTR4PERDFilter (optional)
     * @param minQTR4PERDFilter (optional)
     * @param maxACTIVEFilter (optional)
     * @param minACTIVEFilter (optional)
     * @param maxBGNDATE1Filter (optional)
     * @param minBGNDATE1Filter (optional)
     * @param maxBGNDATE2Filter (optional)
     * @param minBGNDATE2Filter (optional)
     * @param maxBGNDATE3Filter (optional)
     * @param minBGNDATE3Filter (optional)
     * @param maxBGNDATE4Filter (optional)
     * @param minBGNDATE4Filter (optional)
     * @param maxBGNDATE5Filter (optional)
     * @param minBGNDATE5Filter (optional)
     * @param maxBGNDATE6Filter (optional)
     * @param minBGNDATE6Filter (optional)
     * @param maxBGNDATE7Filter (optional)
     * @param minBGNDATE7Filter (optional)
     * @param maxBGNDATE8Filter (optional)
     * @param minBGNDATE8Filter (optional)
     * @param maxBGNDATE9Filter (optional)
     * @param minBGNDATE9Filter (optional)
     * @param maxBGNDATE10Filter (optional)
     * @param minBGNDATE10Filter (optional)
     * @param maxBGNDATE11Filter (optional)
     * @param minBGNDATE11Filter (optional)
     * @param maxBGNDATE12Filter (optional)
     * @param minBGNDATE12Filter (optional)
     * @param maxBGNDATE13Filter (optional)
     * @param minBGNDATE13Filter (optional)
     * @param maxENDDATE1Filter (optional)
     * @param minENDDATE1Filter (optional)
     * @param maxENDDATE2Filter (optional)
     * @param minENDDATE2Filter (optional)
     * @param maxENDDATE3Filter (optional)
     * @param minENDDATE3Filter (optional)
     * @param maxENDDATE4Filter (optional)
     * @param minENDDATE4Filter (optional)
     * @param maxENDDATE5Filter (optional)
     * @param minENDDATE5Filter (optional)
     * @param maxENDDATE6Filter (optional)
     * @param minENDDATE6Filter (optional)
     * @param maxENDDATE7Filter (optional)
     * @param minENDDATE7Filter (optional)
     * @param maxENDDATE8Filter (optional)
     * @param minENDDATE8Filter (optional)
     * @param maxENDDATE9Filter (optional)
     * @param minENDDATE9Filter (optional)
     * @param maxENDDATE10Filter (optional)
     * @param minENDDATE10Filter (optional)
     * @param maxENDDATE11Filter (optional)
     * @param minENDDATE11Filter (optional)
     * @param maxENDDATE12Filter (optional)
     * @param minENDDATE12Filter (optional)
     * @param maxENDDATE13Filter (optional)
     * @param minENDDATE13Filter (optional)
     * @return Success
     */
    getFiscalCalendarsToExcel(filter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, maxPERIODSFilter: number | null | undefined, minPERIODSFilter: number | null | undefined, maxQTR4PERDFilter: number | null | undefined, minQTR4PERDFilter: number | null | undefined, maxACTIVEFilter: number | null | undefined, minACTIVEFilter: number | null | undefined, maxBGNDATE1Filter: moment.Moment | null | undefined, minBGNDATE1Filter: moment.Moment | null | undefined, maxBGNDATE2Filter: moment.Moment | null | undefined, minBGNDATE2Filter: moment.Moment | null | undefined, maxBGNDATE3Filter: moment.Moment | null | undefined, minBGNDATE3Filter: moment.Moment | null | undefined, maxBGNDATE4Filter: moment.Moment | null | undefined, minBGNDATE4Filter: moment.Moment | null | undefined, maxBGNDATE5Filter: moment.Moment | null | undefined, minBGNDATE5Filter: moment.Moment | null | undefined, maxBGNDATE6Filter: moment.Moment | null | undefined, minBGNDATE6Filter: moment.Moment | null | undefined, maxBGNDATE7Filter: moment.Moment | null | undefined, minBGNDATE7Filter: moment.Moment | null | undefined, maxBGNDATE8Filter: moment.Moment | null | undefined, minBGNDATE8Filter: moment.Moment | null | undefined, maxBGNDATE9Filter: moment.Moment | null | undefined, minBGNDATE9Filter: moment.Moment | null | undefined, maxBGNDATE10Filter: moment.Moment | null | undefined, minBGNDATE10Filter: moment.Moment | null | undefined, maxBGNDATE11Filter: moment.Moment | null | undefined, minBGNDATE11Filter: moment.Moment | null | undefined, maxBGNDATE12Filter: moment.Moment | null | undefined, minBGNDATE12Filter: moment.Moment | null | undefined, maxBGNDATE13Filter: moment.Moment | null | undefined, minBGNDATE13Filter: moment.Moment | null | undefined, maxENDDATE1Filter: moment.Moment | null | undefined, minENDDATE1Filter: moment.Moment | null | undefined, maxENDDATE2Filter: moment.Moment | null | undefined, minENDDATE2Filter: moment.Moment | null | undefined, maxENDDATE3Filter: moment.Moment | null | undefined, minENDDATE3Filter: moment.Moment | null | undefined, maxENDDATE4Filter: moment.Moment | null | undefined, minENDDATE4Filter: moment.Moment | null | undefined, maxENDDATE5Filter: moment.Moment | null | undefined, minENDDATE5Filter: moment.Moment | null | undefined, maxENDDATE6Filter: moment.Moment | null | undefined, minENDDATE6Filter: moment.Moment | null | undefined, maxENDDATE7Filter: moment.Moment | null | undefined, minENDDATE7Filter: moment.Moment | null | undefined, maxENDDATE8Filter: moment.Moment | null | undefined, minENDDATE8Filter: moment.Moment | null | undefined, maxENDDATE9Filter: moment.Moment | null | undefined, minENDDATE9Filter: moment.Moment | null | undefined, maxENDDATE10Filter: moment.Moment | null | undefined, minENDDATE10Filter: moment.Moment | null | undefined, maxENDDATE11Filter: moment.Moment | null | undefined, minENDDATE11Filter: moment.Moment | null | undefined, maxENDDATE12Filter: moment.Moment | null | undefined, minENDDATE12Filter: moment.Moment | null | undefined, maxENDDATE13Filter: moment.Moment | null | undefined, minENDDATE13Filter: moment.Moment | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalendars/GetFiscalCalendarsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (maxPERIODSFilter !== undefined)
            url_ += "MaxPERIODSFilter=" + encodeURIComponent("" + maxPERIODSFilter) + "&";
        if (minPERIODSFilter !== undefined)
            url_ += "MinPERIODSFilter=" + encodeURIComponent("" + minPERIODSFilter) + "&";
        if (maxQTR4PERDFilter !== undefined)
            url_ += "MaxQTR4PERDFilter=" + encodeURIComponent("" + maxQTR4PERDFilter) + "&";
        if (minQTR4PERDFilter !== undefined)
            url_ += "MinQTR4PERDFilter=" + encodeURIComponent("" + minQTR4PERDFilter) + "&";
        if (maxACTIVEFilter !== undefined)
            url_ += "MaxACTIVEFilter=" + encodeURIComponent("" + maxACTIVEFilter) + "&";
        if (minACTIVEFilter !== undefined)
            url_ += "MinACTIVEFilter=" + encodeURIComponent("" + minACTIVEFilter) + "&";
        if (maxBGNDATE1Filter !== undefined)
            url_ += "MaxBGNDATE1Filter=" + encodeURIComponent(maxBGNDATE1Filter ? "" + maxBGNDATE1Filter.toJSON() : "") + "&";
        if (minBGNDATE1Filter !== undefined)
            url_ += "MinBGNDATE1Filter=" + encodeURIComponent(minBGNDATE1Filter ? "" + minBGNDATE1Filter.toJSON() : "") + "&";
        if (maxBGNDATE2Filter !== undefined)
            url_ += "MaxBGNDATE2Filter=" + encodeURIComponent(maxBGNDATE2Filter ? "" + maxBGNDATE2Filter.toJSON() : "") + "&";
        if (minBGNDATE2Filter !== undefined)
            url_ += "MinBGNDATE2Filter=" + encodeURIComponent(minBGNDATE2Filter ? "" + minBGNDATE2Filter.toJSON() : "") + "&";
        if (maxBGNDATE3Filter !== undefined)
            url_ += "MaxBGNDATE3Filter=" + encodeURIComponent(maxBGNDATE3Filter ? "" + maxBGNDATE3Filter.toJSON() : "") + "&";
        if (minBGNDATE3Filter !== undefined)
            url_ += "MinBGNDATE3Filter=" + encodeURIComponent(minBGNDATE3Filter ? "" + minBGNDATE3Filter.toJSON() : "") + "&";
        if (maxBGNDATE4Filter !== undefined)
            url_ += "MaxBGNDATE4Filter=" + encodeURIComponent(maxBGNDATE4Filter ? "" + maxBGNDATE4Filter.toJSON() : "") + "&";
        if (minBGNDATE4Filter !== undefined)
            url_ += "MinBGNDATE4Filter=" + encodeURIComponent(minBGNDATE4Filter ? "" + minBGNDATE4Filter.toJSON() : "") + "&";
        if (maxBGNDATE5Filter !== undefined)
            url_ += "MaxBGNDATE5Filter=" + encodeURIComponent(maxBGNDATE5Filter ? "" + maxBGNDATE5Filter.toJSON() : "") + "&";
        if (minBGNDATE5Filter !== undefined)
            url_ += "MinBGNDATE5Filter=" + encodeURIComponent(minBGNDATE5Filter ? "" + minBGNDATE5Filter.toJSON() : "") + "&";
        if (maxBGNDATE6Filter !== undefined)
            url_ += "MaxBGNDATE6Filter=" + encodeURIComponent(maxBGNDATE6Filter ? "" + maxBGNDATE6Filter.toJSON() : "") + "&";
        if (minBGNDATE6Filter !== undefined)
            url_ += "MinBGNDATE6Filter=" + encodeURIComponent(minBGNDATE6Filter ? "" + minBGNDATE6Filter.toJSON() : "") + "&";
        if (maxBGNDATE7Filter !== undefined)
            url_ += "MaxBGNDATE7Filter=" + encodeURIComponent(maxBGNDATE7Filter ? "" + maxBGNDATE7Filter.toJSON() : "") + "&";
        if (minBGNDATE7Filter !== undefined)
            url_ += "MinBGNDATE7Filter=" + encodeURIComponent(minBGNDATE7Filter ? "" + minBGNDATE7Filter.toJSON() : "") + "&";
        if (maxBGNDATE8Filter !== undefined)
            url_ += "MaxBGNDATE8Filter=" + encodeURIComponent(maxBGNDATE8Filter ? "" + maxBGNDATE8Filter.toJSON() : "") + "&";
        if (minBGNDATE8Filter !== undefined)
            url_ += "MinBGNDATE8Filter=" + encodeURIComponent(minBGNDATE8Filter ? "" + minBGNDATE8Filter.toJSON() : "") + "&";
        if (maxBGNDATE9Filter !== undefined)
            url_ += "MaxBGNDATE9Filter=" + encodeURIComponent(maxBGNDATE9Filter ? "" + maxBGNDATE9Filter.toJSON() : "") + "&";
        if (minBGNDATE9Filter !== undefined)
            url_ += "MinBGNDATE9Filter=" + encodeURIComponent(minBGNDATE9Filter ? "" + minBGNDATE9Filter.toJSON() : "") + "&";
        if (maxBGNDATE10Filter !== undefined)
            url_ += "MaxBGNDATE10Filter=" + encodeURIComponent(maxBGNDATE10Filter ? "" + maxBGNDATE10Filter.toJSON() : "") + "&";
        if (minBGNDATE10Filter !== undefined)
            url_ += "MinBGNDATE10Filter=" + encodeURIComponent(minBGNDATE10Filter ? "" + minBGNDATE10Filter.toJSON() : "") + "&";
        if (maxBGNDATE11Filter !== undefined)
            url_ += "MaxBGNDATE11Filter=" + encodeURIComponent(maxBGNDATE11Filter ? "" + maxBGNDATE11Filter.toJSON() : "") + "&";
        if (minBGNDATE11Filter !== undefined)
            url_ += "MinBGNDATE11Filter=" + encodeURIComponent(minBGNDATE11Filter ? "" + minBGNDATE11Filter.toJSON() : "") + "&";
        if (maxBGNDATE12Filter !== undefined)
            url_ += "MaxBGNDATE12Filter=" + encodeURIComponent(maxBGNDATE12Filter ? "" + maxBGNDATE12Filter.toJSON() : "") + "&";
        if (minBGNDATE12Filter !== undefined)
            url_ += "MinBGNDATE12Filter=" + encodeURIComponent(minBGNDATE12Filter ? "" + minBGNDATE12Filter.toJSON() : "") + "&";
        if (maxBGNDATE13Filter !== undefined)
            url_ += "MaxBGNDATE13Filter=" + encodeURIComponent(maxBGNDATE13Filter ? "" + maxBGNDATE13Filter.toJSON() : "") + "&";
        if (minBGNDATE13Filter !== undefined)
            url_ += "MinBGNDATE13Filter=" + encodeURIComponent(minBGNDATE13Filter ? "" + minBGNDATE13Filter.toJSON() : "") + "&";
        if (maxENDDATE1Filter !== undefined)
            url_ += "MaxENDDATE1Filter=" + encodeURIComponent(maxENDDATE1Filter ? "" + maxENDDATE1Filter.toJSON() : "") + "&";
        if (minENDDATE1Filter !== undefined)
            url_ += "MinENDDATE1Filter=" + encodeURIComponent(minENDDATE1Filter ? "" + minENDDATE1Filter.toJSON() : "") + "&";
        if (maxENDDATE2Filter !== undefined)
            url_ += "MaxENDDATE2Filter=" + encodeURIComponent(maxENDDATE2Filter ? "" + maxENDDATE2Filter.toJSON() : "") + "&";
        if (minENDDATE2Filter !== undefined)
            url_ += "MinENDDATE2Filter=" + encodeURIComponent(minENDDATE2Filter ? "" + minENDDATE2Filter.toJSON() : "") + "&";
        if (maxENDDATE3Filter !== undefined)
            url_ += "MaxENDDATE3Filter=" + encodeURIComponent(maxENDDATE3Filter ? "" + maxENDDATE3Filter.toJSON() : "") + "&";
        if (minENDDATE3Filter !== undefined)
            url_ += "MinENDDATE3Filter=" + encodeURIComponent(minENDDATE3Filter ? "" + minENDDATE3Filter.toJSON() : "") + "&";
        if (maxENDDATE4Filter !== undefined)
            url_ += "MaxENDDATE4Filter=" + encodeURIComponent(maxENDDATE4Filter ? "" + maxENDDATE4Filter.toJSON() : "") + "&";
        if (minENDDATE4Filter !== undefined)
            url_ += "MinENDDATE4Filter=" + encodeURIComponent(minENDDATE4Filter ? "" + minENDDATE4Filter.toJSON() : "") + "&";
        if (maxENDDATE5Filter !== undefined)
            url_ += "MaxENDDATE5Filter=" + encodeURIComponent(maxENDDATE5Filter ? "" + maxENDDATE5Filter.toJSON() : "") + "&";
        if (minENDDATE5Filter !== undefined)
            url_ += "MinENDDATE5Filter=" + encodeURIComponent(minENDDATE5Filter ? "" + minENDDATE5Filter.toJSON() : "") + "&";
        if (maxENDDATE6Filter !== undefined)
            url_ += "MaxENDDATE6Filter=" + encodeURIComponent(maxENDDATE6Filter ? "" + maxENDDATE6Filter.toJSON() : "") + "&";
        if (minENDDATE6Filter !== undefined)
            url_ += "MinENDDATE6Filter=" + encodeURIComponent(minENDDATE6Filter ? "" + minENDDATE6Filter.toJSON() : "") + "&";
        if (maxENDDATE7Filter !== undefined)
            url_ += "MaxENDDATE7Filter=" + encodeURIComponent(maxENDDATE7Filter ? "" + maxENDDATE7Filter.toJSON() : "") + "&";
        if (minENDDATE7Filter !== undefined)
            url_ += "MinENDDATE7Filter=" + encodeURIComponent(minENDDATE7Filter ? "" + minENDDATE7Filter.toJSON() : "") + "&";
        if (maxENDDATE8Filter !== undefined)
            url_ += "MaxENDDATE8Filter=" + encodeURIComponent(maxENDDATE8Filter ? "" + maxENDDATE8Filter.toJSON() : "") + "&";
        if (minENDDATE8Filter !== undefined)
            url_ += "MinENDDATE8Filter=" + encodeURIComponent(minENDDATE8Filter ? "" + minENDDATE8Filter.toJSON() : "") + "&";
        if (maxENDDATE9Filter !== undefined)
            url_ += "MaxENDDATE9Filter=" + encodeURIComponent(maxENDDATE9Filter ? "" + maxENDDATE9Filter.toJSON() : "") + "&";
        if (minENDDATE9Filter !== undefined)
            url_ += "MinENDDATE9Filter=" + encodeURIComponent(minENDDATE9Filter ? "" + minENDDATE9Filter.toJSON() : "") + "&";
        if (maxENDDATE10Filter !== undefined)
            url_ += "MaxENDDATE10Filter=" + encodeURIComponent(maxENDDATE10Filter ? "" + maxENDDATE10Filter.toJSON() : "") + "&";
        if (minENDDATE10Filter !== undefined)
            url_ += "MinENDDATE10Filter=" + encodeURIComponent(minENDDATE10Filter ? "" + minENDDATE10Filter.toJSON() : "") + "&";
        if (maxENDDATE11Filter !== undefined)
            url_ += "MaxENDDATE11Filter=" + encodeURIComponent(maxENDDATE11Filter ? "" + maxENDDATE11Filter.toJSON() : "") + "&";
        if (minENDDATE11Filter !== undefined)
            url_ += "MinENDDATE11Filter=" + encodeURIComponent(minENDDATE11Filter ? "" + minENDDATE11Filter.toJSON() : "") + "&";
        if (maxENDDATE12Filter !== undefined)
            url_ += "MaxENDDATE12Filter=" + encodeURIComponent(maxENDDATE12Filter ? "" + maxENDDATE12Filter.toJSON() : "") + "&";
        if (minENDDATE12Filter !== undefined)
            url_ += "MinENDDATE12Filter=" + encodeURIComponent(minENDDATE12Filter ? "" + minENDDATE12Filter.toJSON() : "") + "&";
        if (maxENDDATE13Filter !== undefined)
            url_ += "MaxENDDATE13Filter=" + encodeURIComponent(maxENDDATE13Filter ? "" + maxENDDATE13Filter.toJSON() : "") + "&";
        if (minENDDATE13Filter !== undefined)
            url_ += "MinENDDATE13Filter=" + encodeURIComponent(minENDDATE13Filter ? "" + minENDDATE13Filter.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalCalendarsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalCalendarsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalCalendarsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}
///////////////////////////////Fiscal Calendar/////////////////////////////////////////////////
@Injectable()
export class FiscalCalendersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxPeriodFilter (optional)
     * @param minPeriodFilter (optional)
     * @param maxStartDateFilter (optional)
     * @param minStartDateFilter (optional)
     * @param maxEndDateFilter (optional)
     * @param minEndDateFilter (optional)
     * @param gLFilter (optional)
     * @param aPFilter (optional)
     * @param aRFilter (optional)
     * @param iNFilter (optional)
     * @param pOFilter (optional)
     * @param oEFilter (optional)
     * @param bKFilter (optional)
     * @param hRFilter (optional)
     * @param pRFilter (optional)
     * @param maxCreatedByFilter (optional)
     * @param minCreatedByFilter (optional)
     * @param maxCreatedDateFilter (optional)
     * @param minCreatedDateFilter (optional)
     * @param maxEditDateFilter (optional)
     * @param minEditDateFilter (optional)
     * @param maxEditUserFilter (optional)
     * @param minEditUserFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, maxPeriodFilter: number | null | undefined, minPeriodFilter: number | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, gLFilter: number | null | undefined, aPFilter: number | null | undefined, aRFilter: number | null | undefined, iNFilter: number | null | undefined, pOFilter: number | null | undefined, oEFilter: number | null | undefined, bKFilter: number | null | undefined, hRFilter: number | null | undefined, pRFilter: number | null | undefined, maxCreatedByFilter: number | null | undefined, minCreatedByFilter: number | null | undefined, maxCreatedDateFilter: moment.Moment | null | undefined, minCreatedDateFilter: moment.Moment | null | undefined, maxEditDateFilter: moment.Moment | null | undefined, minEditDateFilter: moment.Moment | null | undefined, maxEditUserFilter: number | null | undefined, minEditUserFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetFiscalCalenderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxPeriodFilter !== undefined)
            url_ += "MaxPeriodFilter=" + encodeURIComponent("" + maxPeriodFilter) + "&";
        if (minPeriodFilter !== undefined)
            url_ += "MinPeriodFilter=" + encodeURIComponent("" + minPeriodFilter) + "&";
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&";
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&";
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&";
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&";
        if (gLFilter !== undefined)
            url_ += "GLFilter=" + encodeURIComponent("" + gLFilter) + "&";
        if (aPFilter !== undefined)
            url_ += "APFilter=" + encodeURIComponent("" + aPFilter) + "&";
        if (aRFilter !== undefined)
            url_ += "ARFilter=" + encodeURIComponent("" + aRFilter) + "&";
        if (iNFilter !== undefined)
            url_ += "INFilter=" + encodeURIComponent("" + iNFilter) + "&";
        if (pOFilter !== undefined)
            url_ += "POFilter=" + encodeURIComponent("" + pOFilter) + "&";
        if (oEFilter !== undefined)
            url_ += "OEFilter=" + encodeURIComponent("" + oEFilter) + "&";
        if (bKFilter !== undefined)
            url_ += "BKFilter=" + encodeURIComponent("" + bKFilter) + "&";
        if (hRFilter !== undefined)
            url_ += "HRFilter=" + encodeURIComponent("" + hRFilter) + "&";
        if (pRFilter !== undefined)
            url_ += "PRFilter=" + encodeURIComponent("" + pRFilter) + "&";
        if (maxCreatedByFilter !== undefined)
            url_ += "MaxCreatedByFilter=" + encodeURIComponent("" + maxCreatedByFilter) + "&";
        if (minCreatedByFilter !== undefined)
            url_ += "MinCreatedByFilter=" + encodeURIComponent("" + minCreatedByFilter) + "&";
        if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toJSON() : "") + "&";
        if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toJSON() : "") + "&";
        if (maxEditDateFilter !== undefined)
            url_ += "MaxEditDateFilter=" + encodeURIComponent(maxEditDateFilter ? "" + maxEditDateFilter.toJSON() : "") + "&";
        if (minEditDateFilter !== undefined)
            url_ += "MinEditDateFilter=" + encodeURIComponent(minEditDateFilter ? "" + minEditDateFilter.toJSON() : "") + "&";
        if (maxEditUserFilter !== undefined)
            url_ += "MaxEditUserFilter=" + encodeURIComponent("" + maxEditUserFilter) + "&";
        if (minEditUserFilter !== undefined)
            url_ += "MinEditUserFilter=" + encodeURIComponent("" + minEditUserFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetFiscalCalenderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetFiscalCalenderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetFiscalCalenderForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetFiscalCalenderForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetFiscalCalenderForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetFiscalCalenderForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getFiscalCalenderForView(id: number | null | undefined): Observable<GetFiscalCalenderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/GetFiscalCalenderForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalCalenderForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalCalenderForView(<any>response_);
                } catch (e) {
                    return <Observable<GetFiscalCalenderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFiscalCalenderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalCalenderForView(response: HttpResponseBase): Observable<GetFiscalCalenderForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetFiscalCalenderForViewDto.fromJS(resultData200) : new GetFiscalCalenderForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFiscalCalenderForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getFiscalCalenderForEdit(id: number | null | undefined): Observable<GetFiscalCalenderForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/GetFiscalCalenderForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalCalenderForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalCalenderForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFiscalCalenderForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFiscalCalenderForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalCalenderForEdit(response: HttpResponseBase): Observable<GetFiscalCalenderForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetFiscalCalenderForEditOutput.fromJS(resultData200) : new GetFiscalCalenderForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFiscalCalenderForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditFiscalCalenderDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param maxPeriodFilter (optional)
     * @param minPeriodFilter (optional)
     * @param maxStartDateFilter (optional)
     * @param minStartDateFilter (optional)
     * @param maxEndDateFilter (optional)
     * @param minEndDateFilter (optional)
     * @param gLFilter (optional)
     * @param aPFilter (optional)
     * @param aRFilter (optional)
     * @param iNFilter (optional)
     * @param pOFilter (optional)
     * @param oEFilter (optional)
     * @param bKFilter (optional)
     * @param hRFilter (optional)
     * @param pRFilter (optional)
     * @param maxCreatedByFilter (optional)
     * @param minCreatedByFilter (optional)
     * @param maxCreatedDateFilter (optional)
     * @param minCreatedDateFilter (optional)
     * @param maxEditDateFilter (optional)
     * @param minEditDateFilter (optional)
     * @param maxEditUserFilter (optional)
     * @param minEditUserFilter (optional)
     * @return Success
     */
    getFiscalCalendersToExcel(filter: string | null | undefined, maxPeriodFilter: number | null | undefined, minPeriodFilter: number | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, gLFilter: number | null | undefined, aPFilter: number | null | undefined, aRFilter: number | null | undefined, iNFilter: number | null | undefined, pOFilter: number | null | undefined, oEFilter: number | null | undefined, bKFilter: number | null | undefined, hRFilter: number | null | undefined, pRFilter: number | null | undefined, maxCreatedByFilter: number | null | undefined, minCreatedByFilter: number | null | undefined, maxCreatedDateFilter: moment.Moment | null | undefined, minCreatedDateFilter: moment.Moment | null | undefined, maxEditDateFilter: moment.Moment | null | undefined, minEditDateFilter: moment.Moment | null | undefined, maxEditUserFilter: number | null | undefined, minEditUserFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/GetFiscalCalendersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxPeriodFilter !== undefined)
            url_ += "MaxPeriodFilter=" + encodeURIComponent("" + maxPeriodFilter) + "&";
        if (minPeriodFilter !== undefined)
            url_ += "MinPeriodFilter=" + encodeURIComponent("" + minPeriodFilter) + "&";
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&";
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&";
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&";
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&";
        if (gLFilter !== undefined)
            url_ += "GLFilter=" + encodeURIComponent("" + gLFilter) + "&";
        if (aPFilter !== undefined)
            url_ += "APFilter=" + encodeURIComponent("" + aPFilter) + "&";
        if (aRFilter !== undefined)
            url_ += "ARFilter=" + encodeURIComponent("" + aRFilter) + "&";
        if (iNFilter !== undefined)
            url_ += "INFilter=" + encodeURIComponent("" + iNFilter) + "&";
        if (pOFilter !== undefined)
            url_ += "POFilter=" + encodeURIComponent("" + pOFilter) + "&";
        if (oEFilter !== undefined)
            url_ += "OEFilter=" + encodeURIComponent("" + oEFilter) + "&";
        if (bKFilter !== undefined)
            url_ += "BKFilter=" + encodeURIComponent("" + bKFilter) + "&";
        if (hRFilter !== undefined)
            url_ += "HRFilter=" + encodeURIComponent("" + hRFilter) + "&";
        if (pRFilter !== undefined)
            url_ += "PRFilter=" + encodeURIComponent("" + pRFilter) + "&";
        if (maxCreatedByFilter !== undefined)
            url_ += "MaxCreatedByFilter=" + encodeURIComponent("" + maxCreatedByFilter) + "&";
        if (minCreatedByFilter !== undefined)
            url_ += "MinCreatedByFilter=" + encodeURIComponent("" + minCreatedByFilter) + "&";
        if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toJSON() : "") + "&";
        if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toJSON() : "") + "&";
        if (maxEditDateFilter !== undefined)
            url_ += "MaxEditDateFilter=" + encodeURIComponent(maxEditDateFilter ? "" + maxEditDateFilter.toJSON() : "") + "&";
        if (minEditDateFilter !== undefined)
            url_ += "MinEditDateFilter=" + encodeURIComponent(minEditDateFilter ? "" + minEditDateFilter.toJSON() : "") + "&";
        if (maxEditUserFilter !== undefined)
            url_ += "MaxEditUserFilter=" + encodeURIComponent("" + maxEditUserFilter) + "&";
        if (minEditUserFilter !== undefined)
            url_ += "MinEditUserFilter=" + encodeURIComponent("" + minEditUserFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalCalendersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalCalendersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalCalendersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastYear(): Observable<GetFiscalCalenderForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/GetLastYear";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLastYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastYear(<any>response_);
                } catch (e) {
                    return <Observable<GetFiscalCalenderForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFiscalCalenderForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastYear(response: HttpResponseBase): Observable<GetFiscalCalenderForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetFiscalCalenderForEditOutput.fromJS(resultData200) : new GetFiscalCalenderForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFiscalCalenderForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    deleteCalendar(input: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/DeleteCalendar?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCalendar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCalendar(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCalendar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateCalender(input: CreateOrEditFiscalCalenderDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/UpdateCalender";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateCalender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCalender(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCalender(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    checkAll(period: number | null | undefined, check: boolean | null | undefined): Observable<void> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/CheckAll?";

        if (period !== undefined)
            url_ += "period=" + encodeURIComponent("" + period) + "&";
        if (check !== undefined)
            url_ += "check=" + encodeURIComponent("" + check) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAll(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckAll(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    checkCalendarStatus(input: number | null | undefined): Observable<number> {
        debugger;
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/CheckCalendarStatus?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckCalendarStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCalendarStatus(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCalendarStatus(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param period (optional)
     * @return Success
     */
    calendarStatus(period: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/CalendarStatus?";
        if (period !== undefined)
            url_ += "period=" + encodeURIComponent("" + period) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCalendarStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalendarStatus(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCalendarStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param date (optional)
     * @param fiscalYear (optional)
     * @return Success
     */
    getFiscalYearStatus(date: moment.Moment | null | undefined, fiscalYear: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FiscalCalenders/GetFiscalYearStatus?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        if (fiscalYear !== undefined)
            url_ += "fiscalYear=" + encodeURIComponent("" + fiscalYear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFiscalYearStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFiscalYearStatus(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetFiscalYearStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}
///////////////////////////////Fiscal Calendar/////////////////////////////////////////////////
@Injectable()

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GeneralLedgerReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional)
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param fromAC (optional)
     * @param toAC (optional)
     * @param status (optional)
     * @param locId (optional)
     * @return Success
     */
    getGeneralLedger(tenantId: number | null | undefined, fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, fromAC: string | null | undefined, toAC: string | null | undefined, status: string | null | undefined, locId: number | null | undefined): Observable<GeneralLedgerModel[]> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerReport/GetGeneralLedger?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (fromAC !== undefined)
            url_ += "fromAC=" + encodeURIComponent("" + fromAC) + "&";
        if (toAC !== undefined)
            url_ += "toAC=" + encodeURIComponent("" + toAC) + "&";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGeneralLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedger(<any>response_);
                } catch (e) {
                    return <Observable<GeneralLedgerModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralLedgerModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralLedger(response: HttpResponseBase): Observable<GeneralLedgerModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(GeneralLedgerModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralLedgerModel[]>(<any>null);
    }
}

@Injectable()
export class GLBOOKSServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param bookIDFilter (optional)
     * @param bookNameFilter (optional)
     * @param maxNormalEntryFilter (optional)
     * @param minNormalEntryFilter (optional)
     * @param integratedFilter (optional)
     * @param iNACTIVEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param maxRestrictedFilter (optional)
     * @param minRestrictedFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, bookIDFilter: string | null | undefined, bookNameFilter: string | null | undefined, maxNormalEntryFilter: number | null | undefined, minNormalEntryFilter: number | null | undefined, integratedFilter: number | null | undefined, iNACTIVEFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, maxRestrictedFilter: number | null | undefined, minRestrictedFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGLBOOKSForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (bookNameFilter !== undefined)
            url_ += "BookNameFilter=" + encodeURIComponent("" + bookNameFilter) + "&";
        if (maxNormalEntryFilter !== undefined)
            url_ += "MaxNormalEntryFilter=" + encodeURIComponent("" + maxNormalEntryFilter) + "&";
        if (minNormalEntryFilter !== undefined)
            url_ += "MinNormalEntryFilter=" + encodeURIComponent("" + minNormalEntryFilter) + "&";
        if (integratedFilter !== undefined)
            url_ += "IntegratedFilter=" + encodeURIComponent("" + integratedFilter) + "&";
        if (iNACTIVEFilter !== undefined)
            url_ += "INACTIVEFilter=" + encodeURIComponent("" + iNACTIVEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (maxRestrictedFilter !== undefined)
            url_ += "MaxRestrictedFilter=" + encodeURIComponent("" + maxRestrictedFilter) + "&";
        if (minRestrictedFilter !== undefined)
            url_ += "MinRestrictedFilter=" + encodeURIComponent("" + minRestrictedFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLBOOKSForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLBOOKSForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLBOOKSForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLBOOKSForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLBOOKSForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLBOOKSForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLBOOKSForView(id: string | null | undefined): Observable<GetGLBOOKSForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/GetGLBOOKSForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLBOOKSForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLBOOKSForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGLBOOKSForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLBOOKSForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLBOOKSForView(response: HttpResponseBase): Observable<GetGLBOOKSForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLBOOKSForViewDto.fromJS(resultData200) : new GetGLBOOKSForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLBOOKSForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLBOOKSForEdit(id: number | null | undefined): Observable<GetGLBOOKSForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/GetGLBOOKSForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLBOOKSForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLBOOKSForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGLBOOKSForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLBOOKSForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLBOOKSForEdit(response: HttpResponseBase): Observable<GetGLBOOKSForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLBOOKSForEditOutput.fromJS(resultData200) : new GetGLBOOKSForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLBOOKSForEditOutput>(<any>null);
    }

    /**
     * @param bookid (optional)
     * @return Success
     */
    bookIdExists(bookid: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/BookIdExists?";
        if (bookid !== undefined)
            url_ += "bookid=" + encodeURIComponent("" + bookid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processBookIdExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookIdExists(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processBookIdExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGLBOOKSDto | null | undefined): Observable<void> {

        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param bookIDFilter (optional)
     * @param bookNameFilter (optional)
     * @param maxNormalEntryFilter (optional)
     * @param minNormalEntryFilter (optional)
     * @param integratedFilter (optional)
     * @param iNACTIVEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param maxRestrictedFilter (optional)
     * @param minRestrictedFilter (optional)
     * @return Success
     */
    getGLBOOKSToExcel(filter: string | null | undefined, bookIDFilter: string | null | undefined, bookNameFilter: string | null | undefined, maxNormalEntryFilter: number | null | undefined, minNormalEntryFilter: number | null | undefined, integratedFilter: number | null | undefined, iNACTIVEFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, maxRestrictedFilter: number | null | undefined, minRestrictedFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GLBOOKS/GetGLBOOKSToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (bookNameFilter !== undefined)
            url_ += "BookNameFilter=" + encodeURIComponent("" + bookNameFilter) + "&";
        if (maxNormalEntryFilter !== undefined)
            url_ += "MaxNormalEntryFilter=" + encodeURIComponent("" + maxNormalEntryFilter) + "&";
        if (minNormalEntryFilter !== undefined)
            url_ += "MinNormalEntryFilter=" + encodeURIComponent("" + minNormalEntryFilter) + "&";
        if (integratedFilter !== undefined)
            url_ += "IntegratedFilter=" + encodeURIComponent("" + integratedFilter) + "&";
        if (iNACTIVEFilter !== undefined)
            url_ += "INACTIVEFilter=" + encodeURIComponent("" + iNACTIVEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (maxRestrictedFilter !== undefined)
            url_ += "MaxRestrictedFilter=" + encodeURIComponent("" + maxRestrictedFilter) + "&";
        if (minRestrictedFilter !== undefined)
            url_ += "MinRestrictedFilter=" + encodeURIComponent("" + minRestrictedFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLBOOKSToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLBOOKSToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLBOOKSToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class GLCONFIGServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param accountIDFilter (optional)
     * @param maxSubAccIDFilter (optional)
     * @param minSubAccIDFilter (optional)
     * @param maxConfigIDFilter (optional)
     * @param minConfigIDFilter (optional)
     * @param bookIDFilter (optional)
     * @param postingOnFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param gLBOOKSBookNameFilter (optional)
     * @param chartofControlAccountNameFilter (optional)
     * @param accountSubLedgerSubAccNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, accountIDFilter: string | null | undefined, maxSubAccIDFilter: number | null | undefined, minSubAccIDFilter: number | null | undefined, maxConfigIDFilter: number | null | undefined, minConfigIDFilter: number | null | undefined, bookIDFilter: string | null | undefined, postingOnFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, gLBOOKSBookNameFilter: string | null | undefined, chartofControlAccountNameFilter: string | null | undefined, accountSubLedgerSubAccNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGLCONFIGForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (maxSubAccIDFilter !== undefined)
            url_ += "MaxSubAccIDFilter=" + encodeURIComponent("" + maxSubAccIDFilter) + "&";
        if (minSubAccIDFilter !== undefined)
            url_ += "MinSubAccIDFilter=" + encodeURIComponent("" + minSubAccIDFilter) + "&";
        if (maxConfigIDFilter !== undefined)
            url_ += "MaxConfigIDFilter=" + encodeURIComponent("" + maxConfigIDFilter) + "&";
        if (minConfigIDFilter !== undefined)
            url_ += "MinConfigIDFilter=" + encodeURIComponent("" + minConfigIDFilter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (postingOnFilter !== undefined)
            url_ += "PostingOnFilter=" + encodeURIComponent("" + postingOnFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (gLBOOKSBookNameFilter !== undefined)
            url_ += "GLBOOKSBookNameFilter=" + encodeURIComponent("" + gLBOOKSBookNameFilter) + "&";
        if (chartofControlAccountNameFilter !== undefined)
            url_ += "ChartofControlAccountNameFilter=" + encodeURIComponent("" + chartofControlAccountNameFilter) + "&";
        if (accountSubLedgerSubAccNameFilter !== undefined)
            url_ += "AccountSubLedgerSubAccNameFilter=" + encodeURIComponent("" + accountSubLedgerSubAccNameFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLCONFIGForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLCONFIGForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLCONFIGForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLCONFIGForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLCONFIGForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLCONFIGForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLCONFIGForView(id: string | null | undefined): Observable<GetGLCONFIGForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetGLCONFIGForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLCONFIGForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLCONFIGForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGLCONFIGForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLCONFIGForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLCONFIGForView(response: HttpResponseBase): Observable<GetGLCONFIGForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLCONFIGForViewDto.fromJS(resultData200) : new GetGLCONFIGForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLCONFIGForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLCONFIGForEdit(id: string | null | undefined): Observable<GetGLCONFIGForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetGLCONFIGForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLCONFIGForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLCONFIGForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGLCONFIGForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLCONFIGForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLCONFIGForEdit(response: HttpResponseBase): Observable<GetGLCONFIGForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLCONFIGForEditOutput.fromJS(resultData200) : new GetGLCONFIGForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLCONFIGForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGLCONFIGDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param accountIDFilter (optional)
     * @param maxSubAccIDFilter (optional)
     * @param minSubAccIDFilter (optional)
     * @param maxConfigIDFilter (optional)
     * @param minConfigIDFilter (optional)
     * @param bookIDFilter (optional)
     * @param postingOnFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param gLBOOKSBookNameFilter (optional)
     * @param chartofControlAccountNameFilter (optional)
     * @param accountSubLedgerSubAccNameFilter (optional)
     * @return Success
     */
    getGLCONFIGToExcel(filter: string | null | undefined, accountIDFilter: string | null | undefined, maxSubAccIDFilter: number | null | undefined, minSubAccIDFilter: number | null | undefined, maxConfigIDFilter: number | null | undefined, minConfigIDFilter: number | null | undefined, bookIDFilter: string | null | undefined, postingOnFilter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, gLBOOKSBookNameFilter: string | null | undefined, chartofControlAccountNameFilter: string | null | undefined, accountSubLedgerSubAccNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetGLCONFIGToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (maxSubAccIDFilter !== undefined)
            url_ += "MaxSubAccIDFilter=" + encodeURIComponent("" + maxSubAccIDFilter) + "&";
        if (minSubAccIDFilter !== undefined)
            url_ += "MinSubAccIDFilter=" + encodeURIComponent("" + minSubAccIDFilter) + "&";
        if (maxConfigIDFilter !== undefined)
            url_ += "MaxConfigIDFilter=" + encodeURIComponent("" + maxConfigIDFilter) + "&";
        if (minConfigIDFilter !== undefined)
            url_ += "MinConfigIDFilter=" + encodeURIComponent("" + minConfigIDFilter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (postingOnFilter !== undefined)
            url_ += "PostingOnFilter=" + encodeURIComponent("" + postingOnFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (gLBOOKSBookNameFilter !== undefined)
            url_ += "GLBOOKSBookNameFilter=" + encodeURIComponent("" + gLBOOKSBookNameFilter) + "&";
        if (chartofControlAccountNameFilter !== undefined)
            url_ += "ChartofControlAccountNameFilter=" + encodeURIComponent("" + chartofControlAccountNameFilter) + "&";
        if (accountSubLedgerSubAccNameFilter !== undefined)
            url_ += "AccountSubLedgerSubAccNameFilter=" + encodeURIComponent("" + accountSubLedgerSubAccNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLCONFIGToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLCONFIGToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLCONFIGToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllGLBOOKSForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetAllGLBOOKSForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllGLBOOKSForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGLBOOKSForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGLBOOKSForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto>(<any>null);
    }

    /**
     * @param bookId (optional)
     * @return Success
     */
    maxidConfig(bookId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/MaxidConfig?";
        if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMaxidConfig(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxidConfig(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMaxidConfig(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllChartofControlForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGLCONFIGChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetAllChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGLCONFIGChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGLCONFIGChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGLCONFIGChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGLCONFIGChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfGLCONFIGChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGLCONFIGChartofControlLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @param accountid (optional)
     * @return Success
     */
    getAllAccountSubLedgerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, accountid: string | null | undefined): Observable<PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GLCONFIG/GetAllAccountSubLedgerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (accountid !== undefined)
            url_ += "accountid=" + encodeURIComponent("" + accountid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllAccountSubLedgerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountSubLedgerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccountSubLedgerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto>(<any>null);
    }
}

@Injectable()
export class GLLocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param locDescFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditDateFilter (optional)
     * @param minAuditDateFilter (optional)
     * @param maxLocIdFilter (optional)
     * @param minLocIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, locDescFilter: string | null | undefined, auditUserFilter: string | null | undefined, maxAuditDateFilter: moment.Moment | null | undefined, minAuditDateFilter: moment.Moment | null | undefined, maxLocIdFilter: number | null | undefined, minLocIdFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGLLocationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (locDescFilter !== undefined)
            url_ += "LocDescFilter=" + encodeURIComponent("" + locDescFilter) + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditDateFilter !== undefined)
            url_ += "MaxAuditDateFilter=" + encodeURIComponent(maxAuditDateFilter ? "" + maxAuditDateFilter.toJSON() : "") + "&";
        if (minAuditDateFilter !== undefined)
            url_ += "MinAuditDateFilter=" + encodeURIComponent(minAuditDateFilter ? "" + minAuditDateFilter.toJSON() : "") + "&";
        if (maxLocIdFilter !== undefined)
            url_ += "MaxLocIdFilter=" + encodeURIComponent("" + maxLocIdFilter) + "&";
        if (minLocIdFilter !== undefined)
            url_ += "MinLocIdFilter=" + encodeURIComponent("" + minLocIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLLocationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLLocationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLLocationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLLocationForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLLocationForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLLocationForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLLocationForView(id: number | null | undefined): Observable<GetGLLocationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/GetGLLocationForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLLocationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLLocationForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGLLocationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLLocationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLLocationForView(response: HttpResponseBase): Observable<GetGLLocationForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLLocationForViewDto.fromJS(resultData200) : new GetGLLocationForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLLocationForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLLocationForEdit(id: number | null | undefined): Observable<GetGLLocationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/GetGLLocationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLLocationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLLocationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGLLocationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLLocationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLLocationForEdit(response: HttpResponseBase): Observable<GetGLLocationForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLLocationForEditOutput.fromJS(resultData200) : new GetGLLocationForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLLocationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGLLocationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param locDescFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditDateFilter (optional)
     * @param minAuditDateFilter (optional)
     * @param maxLocIdFilter (optional)
     * @param minLocIdFilter (optional)
     * @return Success
     */
    getGLLocationsToExcel(filter: string | null | undefined, locDescFilter: string | null | undefined, auditUserFilter: string | null | undefined, maxAuditDateFilter: moment.Moment | null | undefined, minAuditDateFilter: moment.Moment | null | undefined, maxLocIdFilter: number | null | undefined, minLocIdFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/GetGLLocationsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (locDescFilter !== undefined)
            url_ += "LocDescFilter=" + encodeURIComponent("" + locDescFilter) + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditDateFilter !== undefined)
            url_ += "MaxAuditDateFilter=" + encodeURIComponent(maxAuditDateFilter ? "" + maxAuditDateFilter.toJSON() : "") + "&";
        if (minAuditDateFilter !== undefined)
            url_ += "MinAuditDateFilter=" + encodeURIComponent(minAuditDateFilter ? "" + minAuditDateFilter.toJSON() : "") + "&";
        if (maxLocIdFilter !== undefined)
            url_ += "MaxLocIdFilter=" + encodeURIComponent("" + maxLocIdFilter) + "&";
        if (minLocIdFilter !== undefined)
            url_ += "MinLocIdFilter=" + encodeURIComponent("" + minLocIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLLocationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLLocationsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLLocationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getMaxLocId(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/GLLocations/GetMaxLocId";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMaxLocId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxLocId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxLocId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class GLOptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param dEFAULTCLACCFilter (optional)
     * @param seg1NameFilter (optional)
     * @param seg2NameFilter (optional)
     * @param seg3NameFilter (optional)
     * @param directPostFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, dEFAULTCLACCFilter: string | null | undefined, sTOCKCTRLACCFilter: string | null | undefined, seg1NameFilter: string | null | undefined, seg2NameFilter: string | null | undefined, seg3NameFilter: string | null | undefined, directPostFilter: number | null | undefined, autoSeg3Filter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGLOptionForViewDto> {

        let url_ = this.baseUrl + "/api/services/app/GLOptions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dEFAULTCLACCFilter !== undefined)
            url_ += "DEFAULTCLACCFilter=" + encodeURIComponent("" + dEFAULTCLACCFilter) + "&";
        if (sTOCKCTRLACCFilter !== undefined)
            url_ += "STOCKCTRLACCFilter=" + encodeURIComponent("" + sTOCKCTRLACCFilter) + "&";
        if (seg1NameFilter !== undefined)
            url_ += "Seg1NameFilter=" + encodeURIComponent("" + seg1NameFilter) + "&";
        if (seg2NameFilter !== undefined)
            url_ += "Seg2NameFilter=" + encodeURIComponent("" + seg2NameFilter) + "&";
        if (seg3NameFilter !== undefined)
            url_ += "Seg3NameFilter=" + encodeURIComponent("" + seg3NameFilter) + "&";
        if (directPostFilter !== undefined)
            url_ += "DirectPostFilter=" + encodeURIComponent("" + directPostFilter) + "&";
        if (autoSeg3Filter !== undefined)
            url_ += "AutoSeg3Filter=" + encodeURIComponent("" + autoSeg3Filter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {

            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLOptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLOptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLOptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLOptionForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLOptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLOptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLOptionForView(id: number | null | undefined): Observable<GetGLOptionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLOptions/GetGLOptionForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLOptionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLOptionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGLOptionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLOptionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLOptionForView(response: HttpResponseBase): Observable<GetGLOptionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLOptionForViewDto.fromJS(resultData200) : new GetGLOptionForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLOptionForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLOptionForEdit(id: number | null | undefined): Observable<GetGLOptionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GLOptions/GetGLOptionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLOptionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLOptionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGLOptionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLOptionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLOptionForEdit(response: HttpResponseBase): Observable<GetGLOptionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLOptionForEditOutput.fromJS(resultData200) : new GetGLOptionForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLOptionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGLOptionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLOptions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLOptions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param dEFAULTCLACCFilter (optional)
     * @param seg1NameFilter (optional)
     * @param seg2NameFilter (optional)
     * @param seg3NameFilter (optional)
     * @param directPostFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param chartofControlIdFilter (optional)
     * @return Success
     */
    getGLOptionsToExcel(filter: string | null | undefined, dEFAULTCLACCFilter: string | null | undefined, sTOCKCTRLACCFilter: string | null | undefined, seg1NameFilter: string | null | undefined, seg2NameFilter: string | null | undefined, seg3NameFilter: string | null | undefined, directPostFilter: number | null | undefined, autoSeg3Filter: number | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, chartofControlIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GLOptions/GetGLOptionsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (dEFAULTCLACCFilter !== undefined)
            url_ += "DEFAULTCLACCFilter=" + encodeURIComponent("" + dEFAULTCLACCFilter) + "&";
        if (sTOCKCTRLACCFilter !== undefined)
            url_ += "STOCKCTRLACCFilter=" + encodeURIComponent("" + sTOCKCTRLACCFilter) + "&";
        if (seg1NameFilter !== undefined)
            url_ += "Seg1NameFilter=" + encodeURIComponent("" + seg1NameFilter) + "&";
        if (seg2NameFilter !== undefined)
            url_ += "Seg2NameFilter=" + encodeURIComponent("" + seg2NameFilter) + "&";
        if (seg3NameFilter !== undefined)
            url_ += "Seg3NameFilter=" + encodeURIComponent("" + seg3NameFilter) + "&";
        if (directPostFilter !== undefined)
            url_ += "DirectPostFilter=" + encodeURIComponent("" + directPostFilter) + "&";
        if (autoSeg3Filter !== undefined)
            url_ += "AutoSeg3Filter=" + encodeURIComponent("" + autoSeg3Filter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (chartofControlIdFilter !== undefined)
            url_ += "ChartofControlIdFilter=" + encodeURIComponent("" + chartofControlIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLOptionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLOptionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLOptionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllChartofControlForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGLOptionChartofControlLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GLOptions/GetAllChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGLOptionChartofControlLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGLOptionChartofControlLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGLOptionChartofControlLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGLOptionChartofControlLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfGLOptionChartofControlLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGLOptionChartofControlLookupTableDto>(<any>null);
    }

}

@Injectable()
export class GLTRDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    filterGLTRDData(input: number | null | undefined): Observable<PagedResultDtoOfGetGLTRDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLTRDetails/FilterGLTRDData?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processFilterGLTRDData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFilterGLTRDData(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLTRDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLTRDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    filterGLTRDDataForSalarySheet(Year: number | null | undefined,month:number | null | undefined) {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetJVForsalarySheet?";
        if (Year !== undefined)
            url_ += "Years=" + encodeURIComponent("" + Year) + "&";
        if (month !== undefined)
            url_ += "months=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_).pipe(map((response: any) => {
           
            return response["result"];
        }));
    }

    protected processFilterGLTRDData(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLTRDetailForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLTRDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLTRDetailForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLTRDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLTRDetailForEdit(id: number | null | undefined): Observable<GetGLTRDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GLTRDetails/GetGLTRDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLTRDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLTRDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGLTRDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLTRDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLTRDetailForEdit(response: HttpResponseBase): Observable<GetGLTRDetailForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLTRDetailForEditOutput.fromJS(resultData200) : new GetGLTRDetailForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLTRDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGLTRDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLTRDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLTRDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GLTRHeadersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param bookIDFilter (optional)
     * @param locationFilter (optional)
     * @param maxConfigIDFilter (optional)
     * @param minConfigIDFilter (optional)
     * @param maxDocNoFilter (optional)
     * @param minDocNoFilter (optional)
     * @param maxDocMonthFilter (optional)
     * @param minDocMonthFilter (optional)
     * @param maxDocDateFilter (optional)
     * @param minDocDateFilter (optional)
     * @param nARRATIONFilter (optional)
     * @param postedFilter (optional)
     * @param approvedFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditTimeFilter (optional)
     * @param minAuditTimeFilter (optional)
     * @param oldCodeFilter (optional)
     * @param gLCONFIGConfigIDFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, bookIDFilter: string | null | undefined, locationFilter: number | null | undefined, chNumberFilter: string | null | undefined ,maxConfigIDFilter: number | null | undefined, minConfigIDFilter: number | null | undefined, maxDocNoFilter: number | null | undefined, minDocNoFilter: number | null | undefined, maxDocMonthFilter: number | null | undefined, minDocMonthFilter: number | null | undefined, maxDocDateFilter: moment.Moment | null | undefined, minDocDateFilter: moment.Moment | null | undefined, nARRATIONFilter: string | null | undefined, accountIDFilter: string | null | undefined, accountDescFilter: string | null | undefined, postedFilter: number | null | undefined, approvedFilter: number | null | undefined, auditUserFilter: string | null | undefined, maxAuditTimeFilter: moment.Moment | null | undefined, minAuditTimeFilter: moment.Moment | null | undefined, oldCodeFilter: string | null | undefined, gLCONFIGConfigIDFilter: string | null | undefined, transactionVoucher: boolean | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGLTRHeaderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&";
        if (chNumberFilter !== undefined)
            url_ += "ChNumberFilter=" + encodeURIComponent("" + chNumberFilter) + "&";
        if (maxConfigIDFilter !== undefined)
            url_ += "MaxConfigIDFilter=" + encodeURIComponent("" + maxConfigIDFilter) + "&";
        if (minConfigIDFilter !== undefined)
            url_ += "MinConfigIDFilter=" + encodeURIComponent("" + minConfigIDFilter) + "&";
        if (maxDocNoFilter !== undefined)
            url_ += "MaxDocNoFilter=" + encodeURIComponent("" + maxDocNoFilter) + "&";
        if (minDocNoFilter !== undefined)
            url_ += "MinDocNoFilter=" + encodeURIComponent("" + minDocNoFilter) + "&";
        if (maxDocMonthFilter !== undefined)
            url_ += "MaxDocMonthFilter=" + encodeURIComponent("" + maxDocMonthFilter) + "&";
        if (minDocMonthFilter !== undefined)
            url_ += "MinDocMonthFilter=" + encodeURIComponent("" + minDocMonthFilter) + "&";
        if (maxDocDateFilter !== undefined)
            url_ += "MaxDocDateFilter=" + encodeURIComponent(maxDocDateFilter ? "" + maxDocDateFilter.toJSON() : "") + "&";
        if (minDocDateFilter !== undefined)
            url_ += "MinDocDateFilter=" + encodeURIComponent(minDocDateFilter ? "" + minDocDateFilter.toJSON() : "") + "&";
        if (nARRATIONFilter !== undefined)
            url_ += "NARRATIONFilter=" + encodeURIComponent("" + nARRATIONFilter) + "&";
        if (accountIDFilter !== undefined)
            url_ += "AccountIDFilter=" + encodeURIComponent("" + accountIDFilter) + "&";
        if (accountDescFilter !== undefined)
            url_ += "AccountDescFilter=" + encodeURIComponent("" + accountDescFilter) + "&";
        if (postedFilter !== undefined)
            url_ += "PostedFilter=" + encodeURIComponent("" + postedFilter) + "&";
        if (approvedFilter !== undefined)
            url_ += "ApprovedFilter=" + encodeURIComponent("" + approvedFilter) + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditTimeFilter !== undefined)
            url_ += "MaxAuditTimeFilter=" + encodeURIComponent(maxAuditTimeFilter ? "" + maxAuditTimeFilter.toJSON() : "") + "&";
        if (minAuditTimeFilter !== undefined)
            url_ += "MinAuditTimeFilter=" + encodeURIComponent(minAuditTimeFilter ? "" + minAuditTimeFilter.toJSON() : "") + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (gLCONFIGConfigIDFilter !== undefined)
            url_ += "GLCONFIGConfigIDFilter=" + encodeURIComponent("" + gLCONFIGConfigIDFilter) + "&";
        if (transactionVoucher !== undefined)
            url_ += "transactionVoucher=" + encodeURIComponent("" + transactionVoucher) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGLTRHeaderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGLTRHeaderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGLTRHeaderForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGLTRHeaderForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGLTRHeaderForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGLTRHeaderForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGLTRHeaderForView(id: number | null | undefined): Observable<GetGLTRHeaderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/GetGLTRHeaderForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLTRHeaderForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLTRHeaderForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGLTRHeaderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLTRHeaderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLTRHeaderForView(response: HttpResponseBase): Observable<GetGLTRHeaderForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLTRHeaderForViewDto.fromJS(resultData200) : new GetGLTRHeaderForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLTRHeaderForViewDto>(<any>null);
    }


    getInstrumentNoChk() {
        return this.http.get(this.baseUrl + "/api/services/app/GLOptions/GetInstrumentNoChk");
    }



    /**
     * @param id (optional)
     * @return Success
     */
    getGLTRHeaderForEdit(id: number | null | undefined): Observable<GetGLTRHeaderForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/GetGLTRHeaderForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLTRHeaderForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLTRHeaderForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGLTRHeaderForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGLTRHeaderForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLTRHeaderForEdit(response: HttpResponseBase): Observable<GetGLTRHeaderForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGLTRHeaderForEditOutput.fromJS(resultData200) : new GetGLTRHeaderForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGLTRHeaderForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGLTRHeaderDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getImage(appID: number, docID: number): Observable<List<BinaryData>> {

        debugger;
        let url_ = this.baseUrl + "/DemoUiComponents/GetImageData?";
        if (appID !== undefined)
            url_ += "AppID=" + encodeURIComponent("" + appID) + "&";
        if (docID !== undefined)
            url_ += "DocID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImage(<any>response_);
                } catch (e) {
                    return <Observable<List<BinaryData>>><any>_observableThrow(e);
                }
            } else
                return <Observable<List<BinaryData>>><any>_observableThrow(response_);
        }));
    }

    protected processGetImage(response: HttpResponseBase): Observable<List<BinaryData>> {
        debugger;
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<List<BinaryData>>(<any>null);

    }

    getFile(appID: number, docID: number): Observable<List<BinaryData>> {
        debugger;
        let url_ = this.baseUrl + "/DemoUiComponents/GetFileData?";
        if (appID !== undefined)
            url_ += "AppID=" + encodeURIComponent("" + appID) + "&";
        if (docID !== undefined)
            url_ += "DocID=" + encodeURIComponent("" + docID) + "&";
        url_ = url_.replace(/[?&]$/, "");
        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };
        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<List<BinaryData>>><any>_observableThrow(e);
                }
            } else
                return <Observable<List<BinaryData>>><any>_observableThrow(response_);
        }));
    }
    protected processGetFile(response: HttpResponseBase): Observable<List<BinaryData>> {
        debugger;
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;
        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<List<BinaryData>>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param bookIDFilter (optional)
     * @param maxConfigIDFilter (optional)
     * @param minConfigIDFilter (optional)
     * @param maxDocNoFilter (optional)
     * @param minDocNoFilter (optional)
     * @param maxDocMonthFilter (optional)
     * @param minDocMonthFilter (optional)
     * @param maxDocDateFilter (optional)
     * @param minDocDateFilter (optional)
     * @param nARRATIONFilter (optional)
     * @param postedFilter (optional)
     * @param auditUserFilter (optional)
     * @param maxAuditTimeFilter (optional)
     * @param minAuditTimeFilter (optional)
     * @param oldCodeFilter (optional)
     * @param gLCONFIGConfigIDFilter (optional)
     * @return Success
     */
    getGLTRHeadersToExcel(filter: string | null | undefined, bookIDFilter: string | null | undefined, maxConfigIDFilter: number | null | undefined, minConfigIDFilter: number | null | undefined, maxDocNoFilter: number | null | undefined, minDocNoFilter: number | null | undefined, maxDocMonthFilter: number | null | undefined, minDocMonthFilter: number | null | undefined, maxDocDateFilter: moment.Moment | null | undefined, minDocDateFilter: moment.Moment | null | undefined, nARRATIONFilter: string | null | undefined, postedFilter: number | null | undefined, auditUserFilter: string | null | undefined, maxAuditTimeFilter: moment.Moment | null | undefined, minAuditTimeFilter: moment.Moment | null | undefined, oldCodeFilter: string | null | undefined, gLCONFIGConfigIDFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/GetGLTRHeadersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (bookIDFilter !== undefined)
            url_ += "BookIDFilter=" + encodeURIComponent("" + bookIDFilter) + "&";
        if (maxConfigIDFilter !== undefined)
            url_ += "MaxConfigIDFilter=" + encodeURIComponent("" + maxConfigIDFilter) + "&";
        if (minConfigIDFilter !== undefined)
            url_ += "MinConfigIDFilter=" + encodeURIComponent("" + minConfigIDFilter) + "&";
        if (maxDocNoFilter !== undefined)
            url_ += "MaxDocNoFilter=" + encodeURIComponent("" + maxDocNoFilter) + "&";
        if (minDocNoFilter !== undefined)
            url_ += "MinDocNoFilter=" + encodeURIComponent("" + minDocNoFilter) + "&";
        if (maxDocMonthFilter !== undefined)
            url_ += "MaxDocMonthFilter=" + encodeURIComponent("" + maxDocMonthFilter) + "&";
        if (minDocMonthFilter !== undefined)
            url_ += "MinDocMonthFilter=" + encodeURIComponent("" + minDocMonthFilter) + "&";
        if (maxDocDateFilter !== undefined)
            url_ += "MaxDocDateFilter=" + encodeURIComponent(maxDocDateFilter ? "" + maxDocDateFilter.toJSON() : "") + "&";
        if (minDocDateFilter !== undefined)
            url_ += "MinDocDateFilter=" + encodeURIComponent(minDocDateFilter ? "" + minDocDateFilter.toJSON() : "") + "&";
        if (nARRATIONFilter !== undefined)
            url_ += "NARRATIONFilter=" + encodeURIComponent("" + nARRATIONFilter) + "&";
        if (postedFilter !== undefined)
            url_ += "PostedFilter=" + encodeURIComponent("" + postedFilter) + "&";
        if (auditUserFilter !== undefined)
            url_ += "AuditUserFilter=" + encodeURIComponent("" + auditUserFilter) + "&";
        if (maxAuditTimeFilter !== undefined)
            url_ += "MaxAuditTimeFilter=" + encodeURIComponent(maxAuditTimeFilter ? "" + maxAuditTimeFilter.toJSON() : "") + "&";
        if (minAuditTimeFilter !== undefined)
            url_ += "MinAuditTimeFilter=" + encodeURIComponent(minAuditTimeFilter ? "" + minAuditTimeFilter.toJSON() : "") + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (gLCONFIGConfigIDFilter !== undefined)
            url_ += "GLCONFIGConfigIDFilter=" + encodeURIComponent("" + gLCONFIGConfigIDFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLTRHeadersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLTRHeadersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLTRHeadersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param targetFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllGLCONFIGForLookupTable(filter: string | null | undefined, targetFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/GetAllGLCONFIGForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (targetFilter !== undefined)
            url_ += "TargetFilter=" + encodeURIComponent("" + targetFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllGLCONFIGForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGLCONFIGForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGLCONFIGForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param targetFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllGLSubledgerForLookupTable(filter: string | null | undefined, targetFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/GetAllGLSubledgerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (targetFilter !== undefined)
            url_ += "TargetFilter=" + encodeURIComponent("" + targetFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllGLSubledgerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGLSubledgerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllGLSubledgerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto>(<any>null);
    }

    /**
     * @param accountId (optional)
     * @param date (optional)
     * @param subAccId (optional)
     * @return Success
     */
    closingBalance(accountId: string | null | undefined, date: moment.Moment | null | undefined, subAccId?: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/GLTRHeaders/ClosingBalance?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        if (subAccId !== undefined)
            url_ += "subAccId=" + encodeURIComponent("" + subAccId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processClosingBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClosingBalance(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processClosingBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class GroupCategoriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param gRPCTDESCFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, gRPCTDESCFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGroupCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (gRPCTDESCFilter !== undefined)
            url_ += "GRPCTDESCFilter=" + encodeURIComponent("" + gRPCTDESCFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGroupCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGroupCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGroupCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGroupCategoryForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGroupCategoryForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGroupCategoryForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGroupCategoryForView(id: number | null | undefined): Observable<GetGroupCategoryForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/GetGroupCategoryForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCategoryForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCategoryForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGroupCategoryForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGroupCategoryForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCategoryForView(response: HttpResponseBase): Observable<GetGroupCategoryForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGroupCategoryForViewDto.fromJS(resultData200) : new GetGroupCategoryForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGroupCategoryForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGroupCategoryForEdit(id: number | null | undefined): Observable<GetGroupCategoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/GetGroupCategoryForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCategoryForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCategoryForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGroupCategoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGroupCategoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCategoryForEdit(response: HttpResponseBase): Observable<GetGroupCategoryForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGroupCategoryForEditOutput.fromJS(resultData200) : new GetGroupCategoryForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGroupCategoryForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGroupCategoryDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param gRPCTDESCFilter (optional)
     * @return Success
     */
    getGroupCategoriesToExcel(filter: string | null | undefined, gRPCTDESCFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/GetGroupCategoriesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (gRPCTDESCFilter !== undefined)
            url_ += "GRPCTDESCFilter=" + encodeURIComponent("" + gRPCTDESCFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCategoriesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCategoriesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCategoriesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    maxid(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/GroupCategories/Maxid";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMaxid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxid(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMaxid(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class GroupCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param maxGRPCODEFilter (optional)
     * @param minGRPCODEFilter (optional)
     * @param gRPDESCFilter (optional)
     * @param gRPCTDESCFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, maxGRPCODEFilter: number | null | undefined, minGRPCODEFilter: number | null | undefined, gRPDESCFilter: string | null | undefined, gRPCTDESCFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetGroupCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxGRPCODEFilter !== undefined)
            url_ += "MaxGRPCODEFilter=" + encodeURIComponent("" + maxGRPCODEFilter) + "&";
        if (minGRPCODEFilter !== undefined)
            url_ += "MinGRPCODEFilter=" + encodeURIComponent("" + minGRPCODEFilter) + "&";
        if (gRPDESCFilter !== undefined)
            url_ += "GRPDESCFilter=" + encodeURIComponent("" + gRPDESCFilter) + "&";
        if (gRPCTDESCFilter !== undefined)
            url_ += "GRPCTDESCFilter=" + encodeURIComponent("" + gRPCTDESCFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetGroupCodeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetGroupCodeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGroupCodeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetGroupCodeForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetGroupCodeForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetGroupCodeForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGroupCodeForView(id: number | null | undefined): Observable<GetGroupCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/GetGroupCodeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCodeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCodeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetGroupCodeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGroupCodeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCodeForView(response: HttpResponseBase): Observable<GetGroupCodeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGroupCodeForViewDto.fromJS(resultData200) : new GetGroupCodeForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGroupCodeForViewDto>(<any>null);
    }

    /**
     * @return Success
     */
    maxid(): Observable<GetMaxIDGroupCodes> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/Maxid";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMaxid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxid(<any>response_);
                } catch (e) {
                    return <Observable<GetMaxIDGroupCodes>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaxIDGroupCodes>><any>_observableThrow(response_);
        }));
    }

    protected processMaxid(response: HttpResponseBase): Observable<GetMaxIDGroupCodes> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetMaxIDGroupCodes.fromJS(resultData200) : new GetMaxIDGroupCodes();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaxIDGroupCodes>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getGroupCodeForEdit(id: number | null | undefined): Observable<GetGroupCodeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/GetGroupCodeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCodeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCodeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGroupCodeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGroupCodeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCodeForEdit(response: HttpResponseBase): Observable<GetGroupCodeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGroupCodeForEditOutput.fromJS(resultData200) : new GetGroupCodeForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGroupCodeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditGroupCodeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param maxGRPCODEFilter (optional)
     * @param minGRPCODEFilter (optional)
     * @param gRPDESCFilter (optional)
     * @param gRPCTCODEFilter (optional)
     * @return Success
     */
    getGroupCodesToExcel(filter: string | null | undefined, maxGRPCODEFilter: number | null | undefined, minGRPCODEFilter: number | null | undefined, gRPDESCFilter: string | null | undefined, gRPCTCODEFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/GetGroupCodesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (maxGRPCODEFilter !== undefined)
            url_ += "MaxGRPCODEFilter=" + encodeURIComponent("" + maxGRPCODEFilter) + "&";
        if (minGRPCODEFilter !== undefined)
            url_ += "MinGRPCODEFilter=" + encodeURIComponent("" + minGRPCODEFilter) + "&";
        if (gRPDESCFilter !== undefined)
            url_ += "GRPDESCFilter=" + encodeURIComponent("" + gRPDESCFilter) + "&";
        if (gRPCTCODEFilter !== undefined)
            url_ += "GRPCTCODEFilter=" + encodeURIComponent("" + gRPCTCODEFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCodesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCodesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCodesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getGroupCategoryForCombobox(): Observable<ListResultDtoOfGroupCategoryForComboboxDto> {
        let url_ = this.baseUrl + "/api/services/app/GroupCodes/GetGroupCategoryForCombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGroupCategoryForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupCategoryForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGroupCategoryForComboboxDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGroupCategoryForComboboxDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupCategoryForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfGroupCategoryForComboboxDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfGroupCategoryForComboboxDto.fromJS(resultData200) : new ListResultDtoOfGroupCategoryForComboboxDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGroupCategoryForComboboxDto>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional)
     * @param endDate (optional)
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}


@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @param sorting (optional)
     * @param baseLanguageName (optional)
     * @param targetValueFilter (optional)
     * @param filterText (optional)
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LedgerReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param iD (optional)
     * @param name (optional)
     * @return Success
     */
    getUserDTOs(iD: number | null | undefined, name: string | null | undefined): Observable<UserDTO[]> {
        let url_ = this.baseUrl + "/api/services/app/LedgerReports/GetUserDTOs?";
        if (iD !== undefined)
            url_ += "ID=" + encodeURIComponent("" + iD) + "&";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserDTOs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDTOs(<any>response_);
                } catch (e) {
                    return <Observable<UserDTO[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDTO[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDTOs(response: HttpResponseBase): Observable<UserDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UserDTO.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDTO[]>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getLogsDetails(){
      let url_ = this.baseUrl + "/api/services/app/AuditPostingLogs/GetLogsDetails";
      return this.http.get(url_);
    }

    /**
     * @param state (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getOrganizationUnitRoles(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional)
     * @param organizationUnitId (optional)
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional)
     * @param organizationUnitId (optional)
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    addRolesToOrganizationUnit(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    findRoles(input: FindOrganizationUnitRolesInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PartyBalancesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param fromAcc (optional)
     * @param toAcc (optional)
     * @param tenantId (optional)
     * @param status (optional)
     * @param locId (optional)
     * @return Success
     */
    getData(fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, fromAcc: string | null | undefined, toAcc: string | null | undefined, tenantId: number | null | undefined, status: string | null | undefined, locId: number | null | undefined): Observable<PartyBalances[]> {
        let url_ = this.baseUrl + "/api/services/app/PartyBalances/GetData?";
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (fromAcc !== undefined)
            url_ += "FromAcc=" + encodeURIComponent("" + fromAcc) + "&";
        if (toAcc !== undefined)
            url_ += "ToAcc=" + encodeURIComponent("" + toAcc) + "&";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(<any>response_);
                } catch (e) {
                    return <Observable<PartyBalances[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartyBalances[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<PartyBalances[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(PartyBalances.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartyBalances[]>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional)
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional)
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(PaymentGatewayModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional)
     * @return Success
     */
    getPayment(paymentId: number | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentAsync?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SubscriptionPaymentDto.fromJS(resultData200) : new SubscriptionPaymentDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional)
     * @return Success
     */
    buyNowSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional)
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional)
     * @return Success
     */
    upgradeSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional)
     * @return Success
     */
    extendSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional)
     * @return Success
     */
    paymentFailed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional)
     * @param paypalPaymentId (optional)
     * @param paypalPayerId (optional)
     * @return Success
     */
    confirmPayment(paymentId: number | null | undefined, paypalPaymentId: string | null | undefined, paypalPayerId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalPaymentId !== undefined)
            url_ += "paypalPaymentId=" + encodeURIComponent("" + paypalPaymentId) + "&";
        if (paypalPayerId !== undefined)
            url_ += "paypalPayerId=" + encodeURIComponent("" + paypalPayerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PayPalConfigurationDto.fromJS(resultData200) : new PayPalConfigurationDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    sendVerificationSms(input: SendVerificationSmsInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional)
     * @param userId (optional)
     * @param tenantId (optional)
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional)
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ReportFilterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getLoanTypes(){
        let url_ = this.baseUrl + "/api/services/app/ReportFilter/GetLoanTypes";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

getPaymentModeTypes(){
        let url_ = this.baseUrl + "/api/services/app/ReportFilter/GetLoanTypes";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    /**
     * @return Success
     */
    getAllChartofControlList(): Observable<ListResultDtoOfChartOfControlLookupDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilter/GetAllChartofControlList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllChartofControlList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChartofControlList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChartOfControlLookupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChartOfControlLookupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChartofControlList(response: HttpResponseBase): Observable<ListResultDtoOfChartOfControlLookupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfChartOfControlLookupDto.fromJS(resultData200) : new ListResultDtoOfChartOfControlLookupDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChartOfControlLookupDto>(<any>null);
    }

    /**
     * @param accountid (optional)
     * @return Success
     */
    getAllAccountSubLedgerAccountList(accountid: string | null | undefined): Observable<PagedResultDtoOfAccountSubLedgerListDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilter/GetAllAccountSubLedgerAccountList?";
        if (accountid !== undefined)
            url_ += "accountid=" + encodeURIComponent("" + accountid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllAccountSubLedgerAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccountSubLedgerAccountList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountSubLedgerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountSubLedgerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAccountSubLedgerAccountList(response: HttpResponseBase): Observable<PagedResultDtoOfAccountSubLedgerListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAccountSubLedgerListDto.fromJS(resultData200) : new PagedResultDtoOfAccountSubLedgerListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountSubLedgerListDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param targetFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getSubledgerForLookupTable(filter: string | null | undefined, targetFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAccountSubLedgerListDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilter/GetSubledgerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (targetFilter !== undefined)
            url_ += "TargetFilter=" + encodeURIComponent("" + targetFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubledgerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubledgerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountSubLedgerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountSubLedgerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubledgerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAccountSubLedgerListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfAccountSubLedgerListDto.fromJS(resultData200) : new PagedResultDtoOfAccountSubLedgerListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountSubLedgerListDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param targetFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getChartofControlForLookupTable(filter: string | null | undefined, targetFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLookupDto> {
        let url_ = this.baseUrl + "/api/services/app/ReportFilter/GetChartofControlForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (targetFilter !== undefined)
            url_ += "TargetFilter=" + encodeURIComponent("" + targetFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChartofControlForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartofControlForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLookupDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLookupDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetChartofControlForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLookupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfLookupDto.fromJS(resultData200) : new PagedResultDtoOfLookupDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLookupDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permission (optional)
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class Segmentlevel3sServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param seg3IDFilter (optional)
     * @param segmentNameFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, seg1Filter: string | null | undefined, seg2Filter: string | null | undefined, seg3IDFilter: string | null | undefined, segmentNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSegmentlevel3ForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (seg1Filter !== undefined)
            url_ += "Seg1Filter=" + encodeURIComponent("" + seg1Filter) + "&";
        if (seg2Filter !== undefined)
            url_ += "Seg2Filter=" + encodeURIComponent("" + seg2Filter) + "&";
        if (seg3IDFilter !== undefined)
            url_ += "Seg3IDFilter=" + encodeURIComponent("" + seg3IDFilter) + "&";
        if (segmentNameFilter !== undefined)
            url_ += "SegmentNameFilter=" + encodeURIComponent("" + segmentNameFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSegmentlevel3ForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSegmentlevel3ForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSegmentlevel3ForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetSegmentlevel3ForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSegmentlevel3ForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSegmentlevel3ForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getSegmentlevel3ForView(id: number | null | undefined): Observable<GetSegmentlevel3ForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetSegmentlevel3ForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSegmentlevel3ForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentlevel3ForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSegmentlevel3ForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSegmentlevel3ForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentlevel3ForView(response: HttpResponseBase): Observable<GetSegmentlevel3ForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetSegmentlevel3ForViewDto.fromJS(resultData200) : new GetSegmentlevel3ForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSegmentlevel3ForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getSegmentlevel3ForEdit(id: number | null | undefined): Observable<GetSegmentlevel3ForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetSegmentlevel3ForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSegmentlevel3ForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentlevel3ForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSegmentlevel3ForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSegmentlevel3ForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentlevel3ForEdit(response: HttpResponseBase): Observable<GetSegmentlevel3ForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetSegmentlevel3ForEditOutput.fromJS(resultData200) : new GetSegmentlevel3ForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSegmentlevel3ForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditSegmentlevel3Dto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param seg3IDFilter (optional)
     * @param segmentNameFilter (optional)
     * @return Success
     */
    getSegmentlevel3sToExcel(filter: string | null | undefined, seg3IDFilter: string | null | undefined, segmentNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetSegmentlevel3sToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (seg3IDFilter !== undefined)
            url_ += "Seg3IDFilter=" + encodeURIComponent("" + seg3IDFilter) + "&";
        if (segmentNameFilter !== undefined)
            url_ += "SegmentNameFilter=" + encodeURIComponent("" + segmentNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSegmentlevel3sToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSegmentlevel3sToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSegmentlevel3sToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllControlDetailForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetAllControlDetailForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllControlDetailForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllControlDetailForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllControlDetailForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @param seg1ID (optional)
     * @return Success
     */
    getAllSubControlDetailForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, seg1ID: string | null | undefined): Observable<PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetAllSubControlDetailForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (seg1ID !== undefined)
            url_ += "Seg1ID=" + encodeURIComponent("" + seg1ID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllSubControlDetailForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubControlDetailForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubControlDetailForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getMaxSeg3ID(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Segmentlevel3s/GetMaxSeg3ID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMaxSeg3ID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxSeg3ID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxSeg3ID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    confirmPayment(input: StripeConfirmPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createSubscription(input: StripeCreateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateSubscription(input: StripeUpdateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? StripeConfigurationDto.fromJS(resultData200) : new StripeConfigurationDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubControlDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param seg2IDFilter (optional)
     * @param segmentNameFilter (optional)
     * @param oldCodeFilter (optional)
     * @param controlDetailIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, seg2IDFilter: string | null | undefined, segmentNameFilter: string | null | undefined, oldCodeFilter: string | null | undefined, controlDetailIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSubControlDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (seg2IDFilter !== undefined)
            url_ += "Seg2IDFilter=" + encodeURIComponent("" + seg2IDFilter) + "&";
        if (segmentNameFilter !== undefined)
            url_ += "SegmentNameFilter=" + encodeURIComponent("" + segmentNameFilter) + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (controlDetailIdFilter !== undefined)
            url_ += "ControlDetailIdFilter=" + encodeURIComponent("" + controlDetailIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSubControlDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSubControlDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSubControlDetailForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetSubControlDetailForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetSubControlDetailForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSubControlDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getSubControlDetailForView(id: number | null | undefined): Observable<GetSubControlDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/GetSubControlDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubControlDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubControlDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSubControlDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSubControlDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubControlDetailForView(response: HttpResponseBase): Observable<GetSubControlDetailForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetSubControlDetailForViewDto.fromJS(resultData200) : new GetSubControlDetailForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSubControlDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getSubControlDetailForEdit(id: number | null | undefined): Observable<GetSubControlDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/GetSubControlDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubControlDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubControlDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSubControlDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSubControlDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubControlDetailForEdit(response: HttpResponseBase): Observable<GetSubControlDetailForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetSubControlDetailForEditOutput.fromJS(resultData200) : new GetSubControlDetailForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSubControlDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditSubControlDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param seg2IDFilter (optional)
     * @param segmentNameFilter (optional)
     * @param oldCodeFilter (optional)
     * @param controlDetailIdFilter (optional)
     * @return Success
     */
    getSubControlDetailsToExcel(filter: string | null | undefined, seg2IDFilter: string | null | undefined, segmentNameFilter: string | null | undefined, oldCodeFilter: string | null | undefined, controlDetailIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/GetSubControlDetailsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (seg2IDFilter !== undefined)
            url_ += "Seg2IDFilter=" + encodeURIComponent("" + seg2IDFilter) + "&";
        if (segmentNameFilter !== undefined)
            url_ += "SegmentNameFilter=" + encodeURIComponent("" + segmentNameFilter) + "&";
        if (oldCodeFilter !== undefined)
            url_ += "OldCodeFilter=" + encodeURIComponent("" + oldCodeFilter) + "&";
        if (controlDetailIdFilter !== undefined)
            url_ += "ControlDetailIdFilter=" + encodeURIComponent("" + controlDetailIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubControlDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubControlDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubControlDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllControlDetailForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSubControlDetailControlDetailLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/GetAllControlDetailForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllControlDetailForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllControlDetailForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubControlDetailControlDetailLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubControlDetailControlDetailLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllControlDetailForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSubControlDetailControlDetailLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfSubControlDetailControlDetailLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfSubControlDetailControlDetailLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubControlDetailControlDetailLookupTableDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getSubControlID(id: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/SubControlDetails/GetSubControlID?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubControlID(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubControlID(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubControlID(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class SubledgerReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional)
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param fromAC (optional)
     * @param toAC (optional)
     * @param fromSubledgerId (optional)
     * @param toSubledgerId (optional)
     * @param locId (optional)
     * @return Success
     */
    getSubledger(tenantId: number | null | undefined, fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, fromAC: string | null | undefined, toAC: string | null | undefined, fromSubledgerId: number | null | undefined, toSubledgerId: number | null | undefined, locId: number | null | undefined): Observable<SubedgerModel[]> {
        let url_ = this.baseUrl + "/api/services/app/SubledgerReport/GetSubledger?";
        if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (fromAC !== undefined)
            url_ += "fromAC=" + encodeURIComponent("" + fromAC) + "&";
        if (toAC !== undefined)
            url_ += "toAC=" + encodeURIComponent("" + toAC) + "&";
        if (fromSubledgerId !== undefined)
            url_ += "fromSubledgerId=" + encodeURIComponent("" + fromSubledgerId) + "&";
        if (toSubledgerId !== undefined)
            url_ += "toSubledgerId=" + encodeURIComponent("" + toSubledgerId) + "&";
        if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubledger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubledger(<any>response_);
                } catch (e) {
                    return <Observable<SubedgerModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubedgerModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubledger(response: HttpResponseBase): Observable<SubedgerModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SubedgerModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubedgerModel[]>(<any>null);
    }
}

@Injectable()
export class SubLedgerTrailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param fromAccountID (optional)
     * @param toAccountID (optional)
     * @param fromSubAccID (optional)
     * @param toSubAccID (optional)
     * @param tenantID (optional)
     * @return Success
     */
    getAll(fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, fromAccountID: string | null | undefined, toAccountID: string | null | undefined, fromSubAccID: number | null | undefined, toSubAccID: number | null | undefined, tenantID: number | null | undefined): Observable<SubLedgerTrial[]> {
        let url_ = this.baseUrl + "/api/services/app/SubLedgerTrail/GetAll?";
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (fromAccountID !== undefined)
            url_ += "FromAccountID=" + encodeURIComponent("" + fromAccountID) + "&";
        if (toAccountID !== undefined)
            url_ += "ToAccountID=" + encodeURIComponent("" + toAccountID) + "&";
        if (fromSubAccID !== undefined)
            url_ += "FromSubAccID=" + encodeURIComponent("" + fromSubAccID) + "&";
        if (toSubAccID !== undefined)
            url_ += "ToSubAccID=" + encodeURIComponent("" + toSubAccID) + "&";
        if (tenantID !== undefined)
            url_ += "TenantID=" + encodeURIComponent("" + tenantID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<SubLedgerTrial[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubLedgerTrial[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<SubLedgerTrial[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(SubLedgerTrial.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubLedgerTrial[]>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional)
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TaxAuthoritiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param tAXAUTHFilter (optional)
     * @param tAXAUTHDESCFilter (optional)
     * @param aCCLIABILITYFilter (optional)
     * @param aCCRECOVERABLEFilter (optional)
     * @param maxRECOVERRATEFilter (optional)
     * @param minRECOVERRATEFilter (optional)
     * @param aCCEXPENSEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param companyProfileIdFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, tAXAUTHFilter: string | null | undefined, tAXAUTHDESCFilter: string | null | undefined, aCCLIABILITYFilter: string | null | undefined, aCCRECOVERABLEFilter: string | null | undefined, maxRECOVERRATEFilter: number | null | undefined, minRECOVERRATEFilter: number | null | undefined, aCCEXPENSEFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, companyProfileIdFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTaxAuthorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (tAXAUTHFilter !== undefined)
            url_ += "TAXAUTHFilter=" + encodeURIComponent("" + tAXAUTHFilter) + "&";
        if (tAXAUTHDESCFilter !== undefined)
            url_ += "TAXAUTHDESCFilter=" + encodeURIComponent("" + tAXAUTHDESCFilter) + "&";
        if (aCCLIABILITYFilter !== undefined)
            url_ += "ACCLIABILITYFilter=" + encodeURIComponent("" + aCCLIABILITYFilter) + "&";
        if (aCCRECOVERABLEFilter !== undefined)
            url_ += "ACCRECOVERABLEFilter=" + encodeURIComponent("" + aCCRECOVERABLEFilter) + "&";
        if (maxRECOVERRATEFilter !== undefined)
            url_ += "MaxRECOVERRATEFilter=" + encodeURIComponent("" + maxRECOVERRATEFilter) + "&";
        if (minRECOVERRATEFilter !== undefined)
            url_ += "MinRECOVERRATEFilter=" + encodeURIComponent("" + minRECOVERRATEFilter) + "&";
        if (aCCEXPENSEFilter !== undefined)
            url_ += "ACCEXPENSEFilter=" + encodeURIComponent("" + aCCEXPENSEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (companyProfileIdFilter !== undefined)
            url_ += "CompanyProfileIdFilter=" + encodeURIComponent("" + companyProfileIdFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTaxAuthorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTaxAuthorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTaxAuthorityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetTaxAuthorityForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTaxAuthorityForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTaxAuthorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getTaxAuthorityForView(id: string | null | undefined): Observable<GetTaxAuthorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/GetTaxAuthorityForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTaxAuthorityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxAuthorityForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTaxAuthorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaxAuthorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxAuthorityForView(response: HttpResponseBase): Observable<GetTaxAuthorityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetTaxAuthorityForViewDto.fromJS(resultData200) : new GetTaxAuthorityForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaxAuthorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    checkTaxAuthExist(id: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/CheckTaxAuthExist?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCheckTaxAuthExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckTaxAuthExist(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckTaxAuthExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getTaxAuthorityForEdit(id: string | null | undefined): Observable<GetTaxAuthorityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/GetTaxAuthorityForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTaxAuthorityForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxAuthorityForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTaxAuthorityForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaxAuthorityForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxAuthorityForEdit(response: HttpResponseBase): Observable<GetTaxAuthorityForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetTaxAuthorityForEditOutput.fromJS(resultData200) : new GetTaxAuthorityForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaxAuthorityForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditTaxAuthorityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param cMPIDFilter (optional)
     * @param tAXAUTHFilter (optional)
     * @param tAXAUTHDESCFilter (optional)
     * @param aCCLIABILITYFilter (optional)
     * @param aCCRECOVERABLEFilter (optional)
     * @param maxRECOVERRATEFilter (optional)
     * @param minRECOVERRATEFilter (optional)
     * @param aCCEXPENSEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param companyProfileIdFilter (optional)
     * @return Success
     */
    getTaxAuthoritiesToExcel(filter: string | null | undefined, cMPIDFilter: string | null | undefined, tAXAUTHFilter: string | null | undefined, tAXAUTHDESCFilter: string | null | undefined, aCCLIABILITYFilter: string | null | undefined, aCCRECOVERABLEFilter: string | null | undefined, maxRECOVERRATEFilter: number | null | undefined, minRECOVERRATEFilter: number | null | undefined, aCCEXPENSEFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, companyProfileIdFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/GetTaxAuthoritiesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (cMPIDFilter !== undefined)
            url_ += "CMPIDFilter=" + encodeURIComponent("" + cMPIDFilter) + "&";
        if (tAXAUTHFilter !== undefined)
            url_ += "TAXAUTHFilter=" + encodeURIComponent("" + tAXAUTHFilter) + "&";
        if (tAXAUTHDESCFilter !== undefined)
            url_ += "TAXAUTHDESCFilter=" + encodeURIComponent("" + tAXAUTHDESCFilter) + "&";
        if (aCCLIABILITYFilter !== undefined)
            url_ += "ACCLIABILITYFilter=" + encodeURIComponent("" + aCCLIABILITYFilter) + "&";
        if (aCCRECOVERABLEFilter !== undefined)
            url_ += "ACCRECOVERABLEFilter=" + encodeURIComponent("" + aCCRECOVERABLEFilter) + "&";
        if (maxRECOVERRATEFilter !== undefined)
            url_ += "MaxRECOVERRATEFilter=" + encodeURIComponent("" + maxRECOVERRATEFilter) + "&";
        if (minRECOVERRATEFilter !== undefined)
            url_ += "MinRECOVERRATEFilter=" + encodeURIComponent("" + minRECOVERRATEFilter) + "&";
        if (aCCEXPENSEFilter !== undefined)
            url_ += "ACCEXPENSEFilter=" + encodeURIComponent("" + aCCEXPENSEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (companyProfileIdFilter !== undefined)
            url_ += "CompanyProfileIdFilter=" + encodeURIComponent("" + companyProfileIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTaxAuthoritiesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxAuthoritiesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxAuthoritiesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllCompanyProfileForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxAuthorities/GetAllCompanyProfileForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllCompanyProfileForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompanyProfileForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCompanyProfileForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto>(<any>null);
    }
}

@Injectable()
export class TaxClassesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }


    getTaxClassExists(accId:string,taxAuth:string){
		let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetTaxClassExists?";
		if (accId !== undefined)
		url_ += "accId=" + encodeURIComponent("" + accId) + "&";
	    if (taxAuth !== undefined)
		url_ += "taxAuth=" + encodeURIComponent("" + taxAuth);

		return this.http.request("get", url_);
	}
    /**
     * @param filter (optional)
     * @param tAXAUTHFilter (optional)
     * @param cLASSDESCFilter (optional)
     * @param maxCLASSRATEFilter (optional)
     * @param minCLASSRATEFilter (optional)
     * @param maxTRANSTYPEFilter (optional)
     * @param minTRANSTYPEFilter (optional)
     * @param cLASSTYPEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param taxAuthorityTAXAUTHFilter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined, tAXAUTHFilter: string | null | undefined, cLASSDESCFilter: string | null | undefined, maxCLASSRATEFilter: number | null | undefined, minCLASSRATEFilter: number | null | undefined, maxTRANSTYPEFilter: number | null | undefined, minTRANSTYPEFilter: number | null | undefined, cLASSTYPEFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, taxAuthorityTAXAUTHFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetTaxClassForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (tAXAUTHFilter !== undefined)
            url_ += "TAXAUTHFilter=" + encodeURIComponent("" + tAXAUTHFilter) + "&";
        if (cLASSDESCFilter !== undefined)
            url_ += "CLASSDESCFilter=" + encodeURIComponent("" + cLASSDESCFilter) + "&";
        if (maxCLASSRATEFilter !== undefined)
            url_ += "MaxCLASSRATEFilter=" + encodeURIComponent("" + maxCLASSRATEFilter) + "&";
        if (minCLASSRATEFilter !== undefined)
            url_ += "MinCLASSRATEFilter=" + encodeURIComponent("" + minCLASSRATEFilter) + "&";
        if (maxTRANSTYPEFilter !== undefined)
            url_ += "MaxTRANSTYPEFilter=" + encodeURIComponent("" + maxTRANSTYPEFilter) + "&";
        if (minTRANSTYPEFilter !== undefined)
            url_ += "MinTRANSTYPEFilter=" + encodeURIComponent("" + minTRANSTYPEFilter) + "&";
        if (cLASSTYPEFilter !== undefined)
            url_ += "CLASSTYPEFilter=" + encodeURIComponent("" + cLASSTYPEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (taxAuthorityTAXAUTHFilter !== undefined)
            url_ += "TaxAuthorityTAXAUTHFilter=" + encodeURIComponent("" + taxAuthorityTAXAUTHFilter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetTaxClassForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetTaxClassForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTaxClassForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetTaxClassForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetTaxClassForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetTaxClassForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getTaxClassForView(id: number | null | undefined): Observable<GetTaxClassForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetTaxClassForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTaxClassForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxClassForView(<any>response_);
                } catch (e) {
                    return <Observable<GetTaxClassForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaxClassForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxClassForView(response: HttpResponseBase): Observable<GetTaxClassForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetTaxClassForViewDto.fromJS(resultData200) : new GetTaxClassForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaxClassForViewDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getTaxClassForEdit(id: number | null | undefined): Observable<GetTaxClassForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetTaxClassForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTaxClassForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxClassForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTaxClassForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTaxClassForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxClassForEdit(response: HttpResponseBase): Observable<GetTaxClassForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetTaxClassForEditOutput.fromJS(resultData200) : new GetTaxClassForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTaxClassForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEdit(input: CreateOrEditTaxClassDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param tAXAUTHFilter (optional)
     * @param cLASSDESCFilter (optional)
     * @param maxCLASSRATEFilter (optional)
     * @param minCLASSRATEFilter (optional)
     * @param maxTRANSTYPEFilter (optional)
     * @param minTRANSTYPEFilter (optional)
     * @param cLASSTYPEFilter (optional)
     * @param maxAUDTDATEFilter (optional)
     * @param minAUDTDATEFilter (optional)
     * @param aUDTUSERFilter (optional)
     * @param taxAuthorityTAXAUTHFilter (optional)
     * @return Success
     */
    getTaxClassesToExcel(filter: string | null | undefined, tAXAUTHFilter: string | null | undefined, cLASSDESCFilter: string | null | undefined, maxCLASSRATEFilter: number | null | undefined, minCLASSRATEFilter: number | null | undefined, maxTRANSTYPEFilter: number | null | undefined, minTRANSTYPEFilter: number | null | undefined, cLASSTYPEFilter: string | null | undefined, maxAUDTDATEFilter: moment.Moment | null | undefined, minAUDTDATEFilter: moment.Moment | null | undefined, aUDTUSERFilter: string | null | undefined, taxAuthorityTAXAUTHFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetTaxClassesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (tAXAUTHFilter !== undefined)
            url_ += "TAXAUTHFilter=" + encodeURIComponent("" + tAXAUTHFilter) + "&";
        if (cLASSDESCFilter !== undefined)
            url_ += "CLASSDESCFilter=" + encodeURIComponent("" + cLASSDESCFilter) + "&";
        if (maxCLASSRATEFilter !== undefined)
            url_ += "MaxCLASSRATEFilter=" + encodeURIComponent("" + maxCLASSRATEFilter) + "&";
        if (minCLASSRATEFilter !== undefined)
            url_ += "MinCLASSRATEFilter=" + encodeURIComponent("" + minCLASSRATEFilter) + "&";
        if (maxTRANSTYPEFilter !== undefined)
            url_ += "MaxTRANSTYPEFilter=" + encodeURIComponent("" + maxTRANSTYPEFilter) + "&";
        if (minTRANSTYPEFilter !== undefined)
            url_ += "MinTRANSTYPEFilter=" + encodeURIComponent("" + minTRANSTYPEFilter) + "&";
        if (cLASSTYPEFilter !== undefined)
            url_ += "CLASSTYPEFilter=" + encodeURIComponent("" + cLASSTYPEFilter) + "&";
        if (maxAUDTDATEFilter !== undefined)
            url_ += "MaxAUDTDATEFilter=" + encodeURIComponent(maxAUDTDATEFilter ? "" + maxAUDTDATEFilter.toJSON() : "") + "&";
        if (minAUDTDATEFilter !== undefined)
            url_ += "MinAUDTDATEFilter=" + encodeURIComponent(minAUDTDATEFilter ? "" + minAUDTDATEFilter.toJSON() : "") + "&";
        if (aUDTUSERFilter !== undefined)
            url_ += "AUDTUSERFilter=" + encodeURIComponent("" + aUDTUSERFilter) + "&";
        if (taxAuthorityTAXAUTHFilter !== undefined)
            url_ += "TaxAuthorityTAXAUTHFilter=" + encodeURIComponent("" + taxAuthorityTAXAUTHFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTaxClassesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxClassesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxClassesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param sorting (optional)
     * @param skipCount (optional)
     * @param maxResultCount (optional)
     * @return Success
     */
    getAllTaxAuthorityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetAllTaxAuthorityForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllTaxAuthorityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTaxAuthorityForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllTaxAuthorityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto>(<any>null);
    }

    /**
     * @param authId (optional)
     * @return Success
     */
    getMaxTaxClassId(authId: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TaxClasses/GetMaxTaxClassId?";
        if (authId !== undefined)
            url_ += "authId=" + encodeURIComponent("" + authId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMaxTaxClassId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxTaxClassId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxTaxClassId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param subscriptionEndDateStart (optional)
     * @param subscriptionEndDateEnd (optional)
     * @param creationDateStart (optional)
     * @param creationDateEnd (optional)
     * @param editionId (optional)
     * @param editionIdSpecified (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&";
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&";
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&";
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&";
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getheaderData() {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/getDashboardheaderStats";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    getPostDatedChequeRecievedData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetPostDatedChequesRecieved";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    
    getPostDatedChequeIssuedData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetPostDatedChequesIssued";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

       
    getBankOverDraftData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetBankOverDraft";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    getPartyRecieveableData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetPartyRecieveable";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    getPartyPayableData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetPartyPayable";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    
    getStockBalancesData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetStockBalance";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }
    getCashBalnceDetailData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetCashBalance";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }
    getBankBalnceDetailData()
    {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetBankBalance";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }
    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    opeingBalances(input: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/OpeingBalances?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processOpeingBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpeingBalances(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processOpeingBalances(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    cashFlowSummary(input: GetCashFlowSummaryInput | null | undefined): Observable<ListResultDtoOfCashFlowSummary> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/CashFlowSummary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCashFlowSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCashFlowSummary(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCashFlowSummary>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCashFlowSummary>><any>_observableThrow(response_);
        }));
    }

    protected processCashFlowSummary(response: HttpResponseBase): Observable<ListResultDtoOfCashFlowSummary> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfCashFlowSummary.fromJS(resultData200) : new ListResultDtoOfCashFlowSummary();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCashFlowSummary>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    bankStatusSummary(input: GetBankStatusSummaryInput | null | undefined): Observable<ListResultDtoOfBankStatusSummary> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/BankStatusSummary";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processBankStatusSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBankStatusSummary(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfBankStatusSummary>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfBankStatusSummary>><any>_observableThrow(response_);
        }));
    }

    protected processBankStatusSummary(response: HttpResponseBase): Observable<ListResultDtoOfBankStatusSummary> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfBankStatusSummary.fromJS(resultData200) : new ListResultDtoOfBankStatusSummary();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfBankStatusSummary>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional)
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional)
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ComboboxItemDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional)
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        debugger
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional)
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? RefreshTokenResult.fromJS(resultData200) : new RefreshTokenResult();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional)
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional)
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional)
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional)
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional)
     * @param severity (optional)
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TrialBalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param tenantId (optional)
     * @param fromDate (optional)
     * @param toDate (optional)
     * @param fromAcc (optional)
     * @param toAcc (optional)
     * @param status (optional)
     * @param locId (optional)
     * @return Success
     */
    getData(tenantId: number | null | undefined, fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined, fromAcc: string | null | undefined, toAcc: string | null | undefined, status: string | null | undefined, locId: number | null | undefined): Observable<TrialBalanceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TrialBalance/GetData?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (fromAcc !== undefined)
            url_ += "FromAcc=" + encodeURIComponent("" + fromAcc) + "&";
        if (toAcc !== undefined)
            url_ += "ToAcc=" + encodeURIComponent("" + toAcc) + "&";
        if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (locId !== undefined)
            url_ += "locId=" + encodeURIComponent("" + locId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetData(<any>response_);
                } catch (e) {
                    return <Observable<TrialBalanceDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TrialBalanceDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetData(response: HttpResponseBase): Observable<TrialBalanceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(TrialBalanceDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TrialBalanceDto[]>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ThemeSettingsDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional)
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional)
     * @return Success
     */
    updateUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional)
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @param permission (optional)
     * @param role (optional)
     * @param onlyLockedUsers (optional)
     * @param sorting (optional)
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @return Success
     */
    getUsers(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional)
     * @param permission (optional)
     * @param role (optional)
     * @param onlyLockedUsers (optional)
     * @param sorting (optional)
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");
debugger
        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional)
     * @param skipCount (optional)
     * @param sorting (optional)
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional)
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VendorActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param subAccID (optional)
     * @param accountID (optional)
     * @return Success
     */
    getVendorActivityForView(subAccID: number | null | undefined, accountID: string | null | undefined): Observable<ListResultDtoOfGetVenderActivityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorActivity/GetVendorActivityForView?";
        if (subAccID !== undefined)
            url_ += "SubAccID=" + encodeURIComponent("" + subAccID) + "&";
        if (accountID !== undefined)
            url_ += "AccountID=" + encodeURIComponent("" + accountID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVendorActivityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorActivityForView(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetVenderActivityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetVenderActivityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorActivityForView(response: HttpResponseBase): Observable<ListResultDtoOfGetVenderActivityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfGetVenderActivityForViewDto.fromJS(resultData200) : new ListResultDtoOfGetVenderActivityForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetVenderActivityForViewDto>(<any>null);
    }
}

@Injectable()
export class VoucherEntryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional)
     * @return Success
     */
    createOrEditVoucherEntry(input: VoucherEntryDto | null | undefined): Observable<void> {
        debugger
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/CreateOrEditVoucherEntry";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCreateOrEditVoucherEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEditVoucherEntry(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    GetOverDraftLimit(accountId: string, docId: number, bookId: string) {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetOverDraftLimit?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (docId !== undefined)
            url_ += "docNo=" + encodeURIComponent("" + docId) + "&";
        if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        return this.http.get(url_);
    }

    GetWeatherBankTypeISOverDraftOrNot(accountId: string) {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetWeatherBankTypeISOverDraftOrNot?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        return this.http.get(url_);
    }
    postLCExpense(id: number,flag :boolean) {
        debugger
        let url_ = this.baseUrl + "/api/services/app/LCExpensesHeader/PostLCExpense?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (flag !== undefined)
            url_ += "Flag=" + encodeURIComponent("" + flag) + "&";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.get(url_);
    }

    protected processCreateOrEditVoucherEntry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }


    GetMaxSrNo() {
        let url_ = this.baseUrl;
        url_ += "/api/services/app/VoucherEntry/GetMaxSrNo";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.request("get",url_);
      }

    GetInstruNo() {
        debugger
        let url_ = this.baseUrl;
        url_ += "/api/services/app/VoucherEntry/GetInstrumentStatus";
        url_ = url_.replace(/[?&]$/, "");
        return this.http.request("get",url_);
      }
    /**
     * @param bookId (optional)
     * @return Success
     */
    getMaxDocId(bookId: string | null | undefined,
        fmtDocNoRequired: boolean | null | undefined,
        docDate: any | null | undefined,
    ): Observable<number> {
        debugger
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetMaxDocId?";
        if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        if (bookId !== undefined)
            url_ += "fmtDocNoRequired=" + encodeURIComponent("" + fmtDocNoRequired) + "&";
        if (docDate !== undefined)
            url_ += "docDate=" + encodeURIComponent("" + docDate) + "&";

        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetMaxDocId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaxDocId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaxDocId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param account (optional)
     * @return Success
     */
    getDirectPostedStatus(account: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetDirectPostedStatus?";
        if (account !== undefined)
            url_ += "account=" + encodeURIComponent("" + account) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetDirectPostedStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDirectPostedStatus(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetDirectPostedStatus(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param bookId (optional)
     * @return Success
     */
    getBookNormalEntry(bookId: string | null | undefined): Observable<GLBOOKSDto> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetBookNormalEntry?";
        if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBookNormalEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookNormalEntry(<any>response_);
                } catch (e) {
                    return <Observable<GLBOOKSDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GLBOOKSDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookNormalEntry(response: HttpResponseBase): Observable<GLBOOKSDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GLBOOKSDto>(<any>null);
    }

    /**
     * @param accountId (optional)
     * @return Success
     */
    getAccountDesc(accountId: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetAccountDesc?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountDesc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountDesc(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountDesc(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param accountId (optional)
     * @param subledgerId (optional)
     * @return Success
     */
    getSubledgerDesc(accountId: string | null | undefined, subledgerId: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetSubledgerDesc?";
        if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (subledgerId !== undefined)
            url_ += "subledgerId=" + encodeURIComponent("" + subledgerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetSubledgerDesc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubledgerDesc(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSubledgerDesc(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    getBaseCurrency(): Observable<APOptionCurrencyRateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetBaseCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBaseCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBaseCurrency(<any>response_);
                } catch (e) {
                    return <Observable<APOptionCurrencyRateLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<APOptionCurrencyRateLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBaseCurrency(response: HttpResponseBase): Observable<APOptionCurrencyRateLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? APOptionCurrencyRateLookupTableDto.fromJS(resultData200) : new APOptionCurrencyRateLookupTableDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<APOptionCurrencyRateLookupTableDto>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getBooksDetails(jvoucher: boolean | undefined, interfaceName: string | undefined): Observable<BooksDetailsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetBooksDetails?";
        if (jvoucher !== undefined)
            url_ += "jvoucher=" + encodeURIComponent("" + jvoucher) + "&";
        if (interfaceName !== undefined)
            url_ += "interfaceName=" + encodeURIComponent("" + interfaceName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBooksDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBooksDetails(<any>response_);
                } catch (e) {
                    return <Observable<BooksDetailsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BooksDetailsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBooksDetails(response: HttpResponseBase): Observable<BooksDetailsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(BooksDetailsDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BooksDetailsDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getGLLocData(): Observable<GLLocationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/VoucherEntry/GetUserGLLocData";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetGLLocData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGLLocData(<any>response_);
                } catch (e) {
                    return <Observable<GLLocationDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GLLocationDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetGLLocData(response: HttpResponseBase): Observable<GLLocationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(GLLocationDto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GLLocationDto[]>(<any>null);
    }
}

@Injectable()
export class VoucherPrintingReportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getBookListForReport(): Observable<ListResultDtoOfGetBookViewModeldto> {
        let url_ = this.baseUrl + "/api/services/app/VoucherPrintingReports/GetBookListForReport";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetBookListForReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBookListForReport(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfGetBookViewModeldto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfGetBookViewModeldto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBookListForReport(response: HttpResponseBase): Observable<ListResultDtoOfGetBookViewModeldto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ListResultDtoOfGetBookViewModeldto.fromJS(resultData200) : new ListResultDtoOfGetBookViewModeldto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfGetBookViewModeldto>(<any>null);
    }

    /**
     * @param bookId (optional)
     * @param year (optional)
     * @param month (optional)
     * @param fromconfig (optional)
     * @param toconfig (optional)
     * @param fromdoc (optional)
     * @param todoc (optional)
     * @return Success
     */
    getVoucherPrintingList(bookId: string | null | undefined, year: number | null | undefined, month: number | null | undefined, fromconfig: number | null | undefined, toconfig: number | null | undefined, fromdoc: number | null | undefined, todoc: number | null | undefined): Observable<VoucherPrint[]> {
        let url_ = this.baseUrl + "/api/services/app/VoucherPrintingReports/GetVoucherPrintingList?";
        if (bookId !== undefined)
            url_ += "bookId=" + encodeURIComponent("" + bookId) + "&";
        if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (month !== undefined)
            url_ += "month=" + encodeURIComponent("" + month) + "&";
        if (fromconfig !== undefined)
            url_ += "fromconfig=" + encodeURIComponent("" + fromconfig) + "&";
        if (toconfig !== undefined)
            url_ += "toconfig=" + encodeURIComponent("" + toconfig) + "&";
        if (fromdoc !== undefined)
            url_ += "fromdoc=" + encodeURIComponent("" + fromdoc) + "&";
        if (todoc !== undefined)
            url_ += "todoc=" + encodeURIComponent("" + todoc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetVoucherPrintingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVoucherPrintingList(<any>response_);
                } catch (e) {
                    return <Observable<VoucherPrint[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VoucherPrint[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetVoucherPrintingList(response: HttpResponseBase): Observable<VoucherPrint[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(VoucherPrint.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoucherPrint[]>(<any>null);
    }

    /**
     * @return Success
     */
    getChartofAccountList(): Observable<ChartofAccountdto[]> {
        let url_ = this.baseUrl + "/api/services/app/VoucherPrintingReports/GetChartofAccountList";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetChartofAccountList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetChartofAccountList(<any>response_);
                } catch (e) {
                    return <Observable<ChartofAccountdto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChartofAccountdto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetChartofAccountList(response: HttpResponseBase): Observable<ChartofAccountdto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ChartofAccountdto.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChartofAccountdto[]>(<any>null);
    }

    /**
     * @param asOfDate (optional)
     * @param fromAcc (optional)
     * @param toAcc (optional)
     * @param fromSubAcc (optional)
     * @param toSubAcc (optional)
     * @param ag1 (optional)
     * @param ag2 (optional)
     * @param ag3 (optional)
     * @param ag4 (optional)
     * @param type (optional)
     * @return Success
     */
    getAccountAginReport(asOfDate: moment.Moment | null | undefined, fromAcc: string | null | undefined, toAcc: string | null | undefined, fromSubAcc: number | null | undefined, toSubAcc: number | null | undefined, ag1: number | null | undefined, ag2: number | null | undefined, ag3: number | null | undefined, ag4: number | null | undefined, type: number | null | undefined): Observable<AccountsAging[]> {
        let url_ = this.baseUrl + "/api/services/app/VoucherPrintingReports/GetAccountAginReport?";
        if (asOfDate !== undefined)
            url_ += "AsOfDate=" + encodeURIComponent(asOfDate ? "" + asOfDate.toJSON() : "") + "&";
        if (fromAcc !== undefined)
            url_ += "FromAcc=" + encodeURIComponent("" + fromAcc) + "&";
        if (toAcc !== undefined)
            url_ += "ToAcc=" + encodeURIComponent("" + toAcc) + "&";
        if (fromSubAcc !== undefined)
            url_ += "FromSubAcc=" + encodeURIComponent("" + fromSubAcc) + "&";
        if (toSubAcc !== undefined)
            url_ += "ToSubAcc=" + encodeURIComponent("" + toSubAcc) + "&";
        if (ag1 !== undefined)
            url_ += "Ag1=" + encodeURIComponent("" + ag1) + "&";
        if (ag2 !== undefined)
            url_ += "Ag2=" + encodeURIComponent("" + ag2) + "&";
        if (ag3 !== undefined)
            url_ += "Ag3=" + encodeURIComponent("" + ag3) + "&";
        if (ag4 !== undefined)
            url_ += "Ag4=" + encodeURIComponent("" + ag4) + "&";
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/xml"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAccountAginReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountAginReport(<any>response_);
                } catch (e) {
                    return <Observable<AccountsAging[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountsAging[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountAginReport(response: HttpResponseBase): Observable<AccountsAging[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(AccountsAging.fromJS(item));
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountsAging[]>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class YearEndClosingReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    closeFiscalYearEnd(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/YearEndClosingReport/CloseFiscalYearEnd";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCloseFiscalYearEnd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseFiscalYearEnd(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCloseFiscalYearEnd(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAll(): Observable<PagedResultDtoOfGetCityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/City/GetAll?";

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCityForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PagedResultDtoOfGetCityForViewDto.fromJS(resultData200) : new PagedResultDtoOfGetCityForViewDto();
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCityForViewDto>(<any>null);
    }
}

export class PagedResultDtoOfGetCityForViewDto implements IPagedResultDtoOfGetCityForViewDto {
    totalCount!: number | undefined;
    items!: GetCityForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCityForViewDto {
        debugger;
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger;
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCityForViewDto {
    totalCount: number | undefined;
    items: GetCityForViewDto[] | undefined;
}

export class GetCityForViewDto implements IGetCityForViewDto {
    city!: CityDto | undefined;

    constructor(data?: IGetCityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            this.city = data["city"] ? CityDto.fromJS(data["city"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCityForViewDto {
        debugger;
        data = typeof data === 'object' ? data : {};
        let result = new GetCityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger;
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCityForViewDto {
    city: CityDto | undefined;
}

export class CityDto implements ICityDto {
    cityID: number | undefined;
    name: string | undefined;
    preFix: string | undefined;
    provinceID: number | undefined;
    countryID: number | undefined;
    id: number | undefined;

    constructor(data?: ICityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityID = data["cityID"];
            this.name = data["name"];
            this.preFix = data["preFix"];
            this.provinceID = data["provinceID"];
            this.countryID = data["countryID"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityID"] = this.cityID;
        data["name"] = this.name;
        data["preFix"] = this.preFix;
        data["provinceID"] = this.provinceID;
        data["countryID"] = this.countryID;
        data["id"] = this.id;
        return data;
    }

}

export interface ICityDto {
    cityID: number | undefined;
    name: string | undefined;
    preFix: string | undefined;
    provinceID: number | undefined;
    countryID: number | undefined;
    id: number | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data;
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        debugger;
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class PagedResultDtoOfGetAccountsPostingForViewDto implements IPagedResultDtoOfGetAccountsPostingForViewDto {
    totalCount!: number | undefined;
    items!: GetAccountsPostingForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAccountsPostingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAccountsPostingForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAccountsPostingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAccountsPostingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAccountsPostingForViewDto {
    totalCount: number | undefined;
    items: GetAccountsPostingForViewDto[] | undefined;
}

export class GetAccountsPostingForViewDto implements IGetAccountsPostingForViewDto {
    accountsPosting!: AccountsPostingDto | undefined;

    constructor(data?: IGetAccountsPostingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountsPosting = data["accountsPosting"] ? AccountsPostingDto.fromJS(data["accountsPosting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountsPostingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountsPostingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountsPosting"] = this.accountsPosting ? this.accountsPosting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAccountsPostingForViewDto {
    accountsPosting: AccountsPostingDto | undefined;
}

export class AccountsPostingDto implements IAccountsPostingDto {
    detID!: number | undefined;
    bookID!: string | undefined;
    configID!: number | undefined;
    docNo!: number | undefined;
    docMonth!: number | undefined;
    docDate!: moment.Moment | undefined;
    auditUser!: string | undefined;
    auditTime!: moment.Moment | undefined;
    posted!: boolean | undefined;
    bookName!: string | undefined;
    accountID!: string | undefined;
    subAccID!: number | undefined;
    narration!: string | undefined;
    amount!: number | undefined;
    accountName!: string | undefined;
    subAccName!: string | undefined;
    detailID!: number | undefined;
    chequeNo!: string | undefined;
    regNo!: string | undefined;
    reference!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAccountsPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.detID = data["detID"];
            this.bookID = data["bookID"];
            this.configID = data["configID"];
            this.docNo = data["docNo"];
            this.docMonth = data["docMonth"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.auditUser = data["auditUser"];
            this.auditTime = data["auditTime"] ? moment(data["auditTime"].toString()) : <any>undefined;
            this.posted = data["posted"];
            this.bookName = data["bookName"];
            this.accountID = data["accountID"];
            this.subAccID = data["subAccID"];
            this.narration = data["narration"];
            this.amount = data["amount"];
            this.accountName = data["accountName"];
            this.subAccName = data["subAccName"];
            this.detailID = data["detailID"];
            this.chequeNo = data["chequeNo"];
            this.regNo = data["regNo"];
            this.reference = data["reference"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountsPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detID"] = this.detID;
        data["bookID"] = this.bookID;
        data["configID"] = this.configID;
        data["docNo"] = this.docNo;
        data["docMonth"] = this.docMonth;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["auditUser"] = this.auditUser;
        data["auditTime"] = this.auditTime ? this.auditTime.toISOString() : <any>undefined;
        data["posted"] = this.posted;
        data["bookName"] = this.bookName;
        data["accountID"] = this.accountID;
        data["subAccID"] = this.subAccID;
        data["narration"] = this.narration;
        data["amount"] = this.amount;
        data["accountName"] = this.accountName;
        data["subAccName"] = this.subAccName;
        data["detailID"] = this.detailID;
        data["chequeNo"] = this.chequeNo;
        data["regNo"] = this.regNo;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface IAccountsPostingDto {
    detID: number | undefined;
    bookID: string | undefined;
    configID: number | undefined;
    docNo: number | undefined;
    docMonth: number | undefined;
    docDate: moment.Moment | undefined;
    auditUser: string | undefined;
    auditTime: moment.Moment | undefined;
    posted: boolean | undefined;
    bookName: string | undefined;
    accountID: string | undefined;
    subAccID: number | undefined;
    narration: string | undefined;
    amount: number | undefined;
    accountName: string | undefined;
    subAccName: string | undefined;
    detailID: number | undefined;
    chequeNo: string | undefined;
    regNo: string | undefined;
    reference: string | undefined;
    id: number | undefined;
}

export class GetAccountsPostingForEditOutput implements IGetAccountsPostingForEditOutput {
    accountsPosting!: CreateOrEditAccountsPostingDto | undefined;

    constructor(data?: IGetAccountsPostingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountsPosting = data["accountsPosting"] ? CreateOrEditAccountsPostingDto.fromJS(data["accountsPosting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountsPostingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountsPostingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountsPosting"] = this.accountsPosting ? this.accountsPosting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAccountsPostingForEditOutput {
    accountsPosting: CreateOrEditAccountsPostingDto | undefined;
}

export class CreateOrEditAccountsPostingDto implements ICreateOrEditAccountsPostingDto {
    detID!: number;
    bookID!: string;
    configID!: number;
    docNo!: number;
    docMonth!: number;
    docDate!: moment.Moment;
    auditUser!: string | undefined;
    auditTime!: moment.Moment | undefined;
    posted!: boolean;
    bookName!: string | undefined;
    accountID!: string | undefined;
    subAccID!: number | undefined;
    narration!: string | undefined;
    amount!: number | undefined;
    accountName!: string | undefined;
    subAccName!: string | undefined;
    detailID!: number | undefined;
    chequeNo!: string;
    regNo!: string | undefined;
    reference!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAccountsPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.detID = data["detID"];
            this.bookID = data["bookID"];
            this.configID = data["configID"];
            this.docNo = data["docNo"];
            this.docMonth = data["docMonth"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.auditUser = data["auditUser"];
            this.auditTime = data["auditTime"] ? moment(data["auditTime"].toString()) : <any>undefined;
            this.posted = data["posted"];
            this.bookName = data["bookName"];
            this.accountID = data["accountID"];
            this.subAccID = data["subAccID"];
            this.narration = data["narration"];
            this.amount = data["amount"];
            this.accountName = data["accountName"];
            this.subAccName = data["subAccName"];
            this.detailID = data["detailID"];
            this.chequeNo = data["chequeNo"];
            this.regNo = data["regNo"];
            this.reference = data["reference"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAccountsPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAccountsPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detID"] = this.detID;
        data["bookID"] = this.bookID;
        data["configID"] = this.configID;
        data["docNo"] = this.docNo;
        data["docMonth"] = this.docMonth;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["auditUser"] = this.auditUser;
        data["auditTime"] = this.auditTime ? this.auditTime.toISOString() : <any>undefined;
        data["posted"] = this.posted;
        data["bookName"] = this.bookName;
        data["accountID"] = this.accountID;
        data["subAccID"] = this.subAccID;
        data["narration"] = this.narration;
        data["amount"] = this.amount;
        data["accountName"] = this.accountName;
        data["subAccName"] = this.subAccName;
        data["detailID"] = this.detailID;
        data["chequeNo"] = this.chequeNo;
        data["regNo"] = this.regNo;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAccountsPostingDto {
    detID: number;
    bookID: string;
    configID: number;
    docNo: number;
    docMonth: number;
    docDate: moment.Moment;
    auditUser: string | undefined;
    auditTime: moment.Moment | undefined;
    posted: boolean;
    bookName: string | undefined;
    accountID: string | undefined;
    subAccID: number | undefined;
    narration: string | undefined;
    amount: number | undefined;
    accountName: string | undefined;
    subAccName: string | undefined;
    detailID: number | undefined;
    chequeNo: string;
    regNo: string | undefined;
    reference: string | undefined;
    id: number | undefined;
}

export class GetDetailForAccountsPostingDto implements IGetDetailForAccountsPostingDto {
    getUsersForAccountPostingDto!: GetUsersForAccountPostingDto[] | undefined;
    getBooksForAccountPostingDto!: GetBooksForAccountPostingDto[] | undefined;

    constructor(data?: IGetDetailForAccountsPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["getUsersForAccountPostingDto"] && data["getUsersForAccountPostingDto"].constructor === Array) {
                this.getUsersForAccountPostingDto = [] as any;
                for (let item of data["getUsersForAccountPostingDto"])
                    this.getUsersForAccountPostingDto!.push(GetUsersForAccountPostingDto.fromJS(item));
            }
            if (data["getBooksForAccountPostingDto"] && data["getBooksForAccountPostingDto"].constructor === Array) {
                this.getBooksForAccountPostingDto = [] as any;
                for (let item of data["getBooksForAccountPostingDto"])
                    this.getBooksForAccountPostingDto!.push(GetBooksForAccountPostingDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetDetailForAccountsPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailForAccountsPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.getUsersForAccountPostingDto && this.getUsersForAccountPostingDto.constructor === Array) {
            data["getUsersForAccountPostingDto"] = [];
            for (let item of this.getUsersForAccountPostingDto)
                data["getUsersForAccountPostingDto"].push(item.toJSON());
        }
        if (this.getBooksForAccountPostingDto && this.getBooksForAccountPostingDto.constructor === Array) {
            data["getBooksForAccountPostingDto"] = [];
            for (let item of this.getBooksForAccountPostingDto)
                data["getBooksForAccountPostingDto"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetDetailForAccountsPostingDto {
    getUsersForAccountPostingDto: GetUsersForAccountPostingDto[] | undefined;
    getBooksForAccountPostingDto: GetBooksForAccountPostingDto[] | undefined;
}

export class GetUsersForAccountPostingDto implements IGetUsersForAccountPostingDto {
    userId!: string | undefined;

    constructor(data?: IGetUsersForAccountPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): GetUsersForAccountPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersForAccountPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IGetUsersForAccountPostingDto {
    userId: string | undefined;
}

export class GetBooksForAccountPostingDto implements IGetBooksForAccountPostingDto {
    bookId!: string | undefined;
    bookName!: string | undefined;

    constructor(data?: IGetBooksForAccountPostingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookId = data["bookId"];
            this.bookName = data["bookName"];
        }
    }

    static fromJS(data: any): GetBooksForAccountPostingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBooksForAccountPostingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookId"] = this.bookId;
        data["bookName"] = this.bookName;
        return data;
    }
}

export interface IGetBooksForAccountPostingDto {
    bookId: string | undefined;
    bookName: string | undefined;
}

export class AccountsPostingListDto implements IAccountsPostingListDto {
    bookId!: string | undefined;
    bookName!: string | undefined;
    configId!: number | undefined;
    docNo!: number | undefined;
    docDate!: moment.Moment | undefined;
    userId!: string | undefined;
    posted!: boolean | undefined;
    detailId!: number | undefined;
    locDesc!: string | undefined;
    narration!: string | undefined;
    amount!: number | undefined;
    constructor(data?: IAccountsPostingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookId = data["bookId"];
            this.bookName = data["bookName"];
            this.configId = data["configId"];
            this.docNo = data["docNo"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.userId = data["userId"];
            this.posted = data["posted"];
            this.detailId = data["detailId"];
            this.locDesc = data["locDesc"];
            this.narration = data["narration"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): AccountsPostingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsPostingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookId"] = this.bookId;
        data["bookName"] = this.bookName;
        data["configId"] = this.configId;
        data["docNo"] = this.docNo;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["posted"] = this.posted;
        data["detailId"] = this.detailId;
        data["locDesc"] = this.locDesc;
        data["narration"] = this.narration;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IAccountsPostingListDto {
    bookId: string | undefined;
    bookName: string | undefined;
    configId: number | undefined;
    docNo: number | undefined;
    docDate: moment.Moment | undefined;
    userId: string | undefined;
    posted: boolean | undefined;
    detailId: number | undefined;
}

export class PagedResultDtoOfGetAccountSubLedgerForViewDto implements IPagedResultDtoOfGetAccountSubLedgerForViewDto {
    totalCount!: number | undefined;
    items!: GetAccountSubLedgerForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAccountSubLedgerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAccountSubLedgerForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAccountSubLedgerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAccountSubLedgerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAccountSubLedgerForViewDto {
    totalCount: number | undefined;
    items: GetAccountSubLedgerForViewDto[] | undefined;
}

export class GetAccountSubLedgerForViewDto implements IGetAccountSubLedgerForViewDto {
    accountSubLedger!: AccountSubLedgerDto | undefined;
    chartofControlAccountName!: string | undefined;
    taxAuthorityTAXAUTHDESC!: string | undefined;
    parentAccountName!: string | undefined;

    constructor(data?: IGetAccountSubLedgerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountSubLedger = data["accountSubLedger"] ? AccountSubLedgerDto.fromJS(data["accountSubLedger"]) : <any>undefined;
            this.chartofControlAccountName = data["chartofControlAccountName"];
            this.taxAuthorityTAXAUTHDESC = data["taxAuthorityTAXAUTHDESC"];
            this.parentAccountName = data["parentAccountName"];
        }
    }

    static fromJS(data: any): GetAccountSubLedgerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountSubLedgerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountSubLedger"] = this.accountSubLedger ? this.accountSubLedger.toJSON() : <any>undefined;
        data["chartofControlAccountName"] = this.chartofControlAccountName;
        data["taxAuthorityTAXAUTHDESC"] = this.taxAuthorityTAXAUTHDESC;
        data["parentAccountName"] = this.parentAccountName;
        return data;
    }
}

export interface IGetAccountSubLedgerForViewDto {
    accountSubLedger: AccountSubLedgerDto | undefined;
    chartofControlAccountName: string | undefined;
    taxAuthorityTAXAUTHDESC: string | undefined;
}

export class AccountSubLedgerDto implements IAccountSubLedgerDto {
    accountID!: string | undefined;
    subAccID!: number | undefined;
    subAccName!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    city!: string | undefined;
    phone!: string | undefined;
    contact!: string | undefined;
    regNo!: string | undefined;
    taxauth!: string | undefined;
    classID!: number | undefined;
    sttaxauth!: string | undefined;
    stClassID!: number | undefined;
    oldSL!: string | undefined;
    ledgerType!: number | undefined;
    agreement1!: string | undefined;
    agreement2!: string | undefined;
    payTerm!: number | undefined;
    otherCondition!: string | undefined;
    reference!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    slType!: number | undefined;
    slDesc!: string | undefined;
    legalName!: string | undefined;
    countryID!: number | undefined;
    provinceID!: number | undefined;
    cityID!: number | undefined;
    linked!: boolean | undefined;
    parentID!: string | undefined;
    active!: boolean | undefined;
    parentSubID!: number | undefined;
    parent!: boolean | undefined
    creditLimit!: number | undefined;
    crLimit!: boolean | undefined;
    cnicno!: string | undefined;
    id!: number | undefined;
    itemPriceID!: string | undefined;
    constructor(data?: IAccountSubLedgerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountID = data["accountID"];
            this.subAccID = data["subAccID"];
            this.subAccName = data["subAccName"];
            this.slType = data["slType"];
            this.slDesc = data["slDesc"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.city = data["city"];
            this.phone = data["phone"];
            this.contact = data["contact"];
            this.regNo = data["regNo"];
            this.taxauth = data["taxauth"];
            this.classID = data["classID"];
            this.sttaxauth = data["sttaxauth"];
            this.stClassID = data["stClassID"];
            this.oldSL = data["oldSL"];
            this.ledgerType = data["ledgerType"];
            this.agreement1 = data["agreement1"];
            this.agreement2 = data["agreement2"];
            this.payTerm = data["payTerm"];
            this.otherCondition = data["otherCondition"];
            this.reference = data["reference"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
        
            this.legalName = data["legalName"];
            this.countryID = data["countryID"];
            this.provinceID = data["provinceID"];
            this.cityID = data["cityID"];
            this.linked = data["linked"];
            this.parentID = data["parentID"];
            this.active = data["active"];
            this.parentSubID = data["parentSubID"];
            this.parent = data["parent"];
            this.creditLimit = data["creditLimit"];
            this.crLimit = data["crLimit"];
            this.cnicno = data["cnicno"];
            this.id = data["id"];
            this.itemPriceID = data["itemPriceID"];
        }
    }

    static fromJS(data: any): AccountSubLedgerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSubLedgerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountID"] = this.accountID;
        data["subAccID"] = this.subAccID;
        data["subAccName"] = this.subAccName;
        data["slType"] = this.slType;
        data["slDesc"] = this.slDesc;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["phone"] = this.phone;
        data["contact"] = this.contact;
        data["regNo"] = this.regNo;
        data["taxauth"] = this.taxauth;
        data["classID"] = this.classID;
        data["sttaxauth"] = this.sttaxauth;
        data["stClassID"] = this.stClassID;
        data["oldSL"] = this.oldSL;
        data["ledgerType"] = this.ledgerType;
        data["agreement1"] = this.agreement1;
        data["agreement2"] = this.agreement2;
        data["payTerm"] = this.payTerm;
        data["otherCondition"] = this.otherCondition;
        data["reference"] = this.reference;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        
        data["legalName"] = this.legalName;
        data["countryID"] = this.countryID;
        data["provinceID"] = this.provinceID;
        data["cityID"] = this.cityID;
        data["linked"] = this.linked;
        data["parentID"] = this.parentID;
        data["active"] = this.active;
        data["parentSubID"] = this.parentSubID;
        data["parent"] = this.parent
        data["creditLimit"] = this.creditLimit;
        data["crLimit"] = this.crLimit;
        data["cnicno"] = this.cnicno;
        data["id"] = this.id;
        data["itemPriceID"]=this.itemPriceID;

        return data;
    }
}

export interface IAccountSubLedgerDto {
    accountID: string | undefined;
    subAccID: number | undefined;
    subAccName: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    phone: string | undefined;
    contact: string | undefined;
    regNo: string | undefined;
    taxauth: string | undefined;
    classID: number | undefined;
    sttaxauth: string | undefined;
    stClassID: number | undefined;
    oldSL: string | undefined;
    ledgerType: number | undefined;
    agreement1: string | undefined;
    agreement2: string | undefined;
    payTerm: number | undefined;
    otherCondition: string | undefined;
    reference: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    slType: number | undefined;
    slDesc: string | undefined;
    legalName: string | undefined;
    countryID: number | undefined;
    provinceID: number | undefined;
    cityID: number | undefined;
    linked: boolean | undefined;
    parentID: string | undefined;
    active: boolean | undefined;
    parentSubID: number | undefined;
    parent: boolean | undefined;
    creditLimit: number | undefined;
    crLimit: boolean | undefined;
    cnicno: string | undefined;
    id: number | undefined;
    itemPriceID: string | undefined;
    
}

export class GetAccountSubLedgerForEditOutput implements IGetAccountSubLedgerForEditOutput {
    accountSubLedger!: CreateOrEditAccountSubLedgerDto | undefined;
    chartofControlAccountName!: string | undefined;
    taxAuthorityTAXAUTHDESC!: string | undefined;
    parentAccountName!: string | undefined;
    parentSubAccountName!: string | undefined;
    itemPriceLIst!: string | undefined;

    constructor(data?: IGetAccountSubLedgerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            debugger

            this.accountSubLedger = data["accountSubLedger"] ? CreateOrEditAccountSubLedgerDto.fromJS(data["accountSubLedger"]) : <any>undefined;
            this.chartofControlAccountName = data["chartofControlAccountName"];
            this.taxAuthorityTAXAUTHDESC = data["taxAuthorityTAXAUTHDESC"];
            this.parentAccountName = data["parentAccountName"];
            this.parentSubAccountName = data["parentSubAccountName"];
            this.itemPriceLIst = data["itemPriceLIst"];
        }
    }

    static fromJS(data: any): GetAccountSubLedgerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountSubLedgerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountSubLedger"] = this.accountSubLedger ? this.accountSubLedger.toJSON() : <any>undefined;
        data["chartofControlAccountName"] = this.chartofControlAccountName;
        data["taxAuthorityTAXAUTHDESC"] = this.taxAuthorityTAXAUTHDESC;
        data["parentAccountName"] = this.parentAccountName;
        data["parentSubAccountName"] = this.parentSubAccountName;
        data["itemPriceLIst"] = this.itemPriceLIst;
        return data;
    }
}

export interface IGetAccountSubLedgerForEditOutput {
    accountSubLedger: CreateOrEditAccountSubLedgerDto | undefined;
    chartofControlAccountName: string | undefined;
    taxAuthorityTAXAUTHDESC: string | undefined;
    parentAccountName: string | undefined;
    itemPriceLIst: string | undefined;
}

export class CreateOrEditAccountSubLedgerDto implements ICreateOrEditAccountSubLedgerDto {
    accountID!: string;
    subAccID!: string;
    subAccName!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    city!: string | undefined;
    phone!: string | undefined;
    contact!: string | undefined;
    payterms!: string | undefined;
    regNo!: string | undefined;
    taxauth!: string | undefined;
    classID!: number | undefined;
    sttaxauth!: string | undefined;
    stClassID!: number | undefined;
    oldSL!: string | undefined;
    ledgerType!: number | undefined;
    agreement1!: string | undefined;
    agreement2!: string | undefined;
    payTerm!: number | undefined;
    otherCondition!: string | undefined;
    reference!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    slType!: number | undefined;
    slDesc!: string | undefined;
    flag!: boolean | undefined;
    legalName!: string | undefined;
    countryID!: number | undefined;
    provinceID!: number | undefined;
    cityID!: number | undefined;
    linked!: boolean | undefined;
    parentID!: string | undefined;
    active!: boolean | undefined;
    parentSubID!: number | undefined;
    parent!: boolean | undefined;
    creditLimit!: number | undefined;
    crLimit !: boolean | undefined;
    cnicno!: string | undefined;
    id!: number | undefined;
    slGrpId!: string | undefined;
    slGrpName!: string | undefined;
    itemPriceID!: string | undefined;
    itemPriceLIst!: string | undefined;
    constructor(data?: ICreateOrEditAccountSubLedgerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            debugger
            this.accountID = data["accountID"];
            this.subAccID = data["subAccID"];
            this.subAccName = data["subAccName"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.city = data["city"];
            this.phone = data["phone"];
            this.contact = data["contact"];
            this.payterms = data["payterms"];
            this.regNo = data["regNo"];
            this.taxauth = data["taxauth"];
            this.classID = data["classID"];
            this.sttaxauth = data["sttaxauth"];
            this.stClassID = data["stClassID"];
            this.oldSL = data["oldSL"];
            this.ledgerType = data["ledgerType"];
            this.agreement1 = data["agreement1"];
            this.agreement2 = data["agreement2"];
            this.payTerm = data["payTerm"];
            this.otherCondition = data["otherCondition"];
            this.reference = data["reference"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.slType = data["slType"];
            this.slDesc = data["slDesc"];
            this.flag = data["flag"];
            this.legalName = data["legalName"];
            this.countryID = data["countryID"];
            this.provinceID = data["provinceID"];
            this.cityID = data["cityID"];
            this.linked = data["linked"];
            this.parentID = data["parentID"];
            this.active = data["active"];
            this.parentSubID = data["parentSubID"];
            this.parent = data["parent"];
            this.creditLimit = data["creditLimit"];
            this.crLimit = data["crLimit"];
            this.cnicno = data["cnicno"];
            this.id = data["id"];
            this.slGrpId = data["slGrpId"];
            this.slGrpName = data["slGrpName"];
            this.itemPriceID=data["itemPriceID"];
        }
    }

    static fromJS(data: any): CreateOrEditAccountSubLedgerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAccountSubLedgerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger
        data = typeof data === 'object' ? data : {};
        data["accountID"] = this.accountID;
        data["subAccID"] = this.subAccID;
        data["subAccName"] = this.subAccName;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["city"] = this.city;
        data["phone"] = this.phone;
        data["contact"] = this.contact;
        data["payterms"] = this.payterms;
        data["regNo"] = this.regNo;
        data["taxauth"] = this.taxauth;
        data["classID"] = this.classID;
        data["sttaxauth"] = this.sttaxauth;
        data["stClassID"] = this.stClassID;
        data["oldSL"] = this.oldSL;
        data["ledgerType"] = this.ledgerType;
        data["agreement1"] = this.agreement1;
        data["agreement2"] = this.agreement2;
        data["payTerm"] = this.payTerm;
        data["otherCondition"] = this.otherCondition;
        data["reference"] = this.reference;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["slType"] = this.slType;
        data["slDesc"] = this.slDesc;
        data["flag"] = this.flag;
        data["legalName"] = this.legalName;
        data["countryID"] = this.countryID;
        data["provinceID"] = this.provinceID;
        data["cityID"] = this.cityID;
        data["linked"] = this.linked;
        data["parentID"] = this.parentID;
        data["active"] = this.active;
        data["parentSubID"] = this.parentSubID;
        data["parent"] = this.parent;
        data["creditLimit"] = this.creditLimit;
        data["crLimit"] = this.crLimit;
        data["cnicno"] = this.cnicno;
        data["id"] = this.id;
        data["itemPriceID"] = this.itemPriceID;
        this.slGrpId = data["slGrpId"];
        this.slGrpName = data["slGrpName"];
     
        return data;
    }
}

export interface ICreateOrEditAccountSubLedgerDto {
    accountID: string;
    subAccID: string;
    subAccName: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    city: string | undefined;
    payterms: string | undefined;
    phone: string | undefined;
    contact: string | undefined;
    regNo: string | undefined;
    taxauth: string | undefined;
    classID: number | undefined;
    sttaxauth: string | undefined;
    stClassID: number | undefined;
    oldSL: string | undefined;
    ledgerType: number | undefined;
    agreement1: string | undefined;
    agreement2: string | undefined;
    payTerm: number | undefined;
    otherCondition: string | undefined;
    reference: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    slType: number | undefined;
    slDesc: string | undefined;
    flag: boolean | undefined;
    legalName: string | undefined;
    countryID: number | undefined;
    provinceID: number | undefined;
    cityID: number | undefined;
    linked: boolean | undefined;
    parentID: string | undefined;
    active: boolean | undefined;
    parentSubID: number | undefined;
    parent: boolean | undefined;
    creditLimit: number | undefined;
    crLimit: boolean | undefined;
    cnicno: string | undefined;
    id: number | undefined;
    slGrpName : string | undefined;
    itemPriceID: string | undefined;
}

export class GetAccountSubLedgerForCreateOutputDto implements IGetAccountSubLedgerForCreateOutputDto {
    accountId!: string | undefined;
    accountDesc!: string | undefined;
    subAccountId!: number | undefined;
    itemPriceLIst!: string | undefined;

    constructor(data?: IGetAccountSubLedgerForCreateOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.accountDesc = data["accountDesc"];
            this.subAccountId = data["subAccountId"];
        }
    }

    static fromJS(data: any): GetAccountSubLedgerForCreateOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountSubLedgerForCreateOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountDesc"] = this.accountDesc;
        data["subAccountId"] = this.subAccountId;
        return data;
    }
}

export interface IGetAccountSubLedgerForCreateOutputDto {
    accountId: string | undefined;
    accountDesc: string | undefined;
    subAccountId: number | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class CustomFileDto implements ICustomFileDto {
    contents!: BlobPart[];
    fileType!: string | undefined;
    fileName!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            this.contents = data["contents"];
            this.fileType = data["fileType"];
            this.fileName = data["fileName"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger;
        data = typeof data === 'object' ? data : {};
        data["contents"] = this.contents;
        data["fileType"] = this.fileType;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface ICustomFileDto {
    contents: BlobPart[];
    fileType: string | undefined;
    fileName: string;
}

export class PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto implements IPagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto {
    totalCount!: number | undefined;
    items!: AccountSubLedgerChartofControlLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AccountSubLedgerChartofControlLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAccountSubLedgerChartofControlLookupTableDto {
    totalCount: number | undefined;
    items: AccountSubLedgerChartofControlLookupTableDto[] | undefined;
}

export class AccountSubLedgerChartofControlLookupTableDto implements IAccountSubLedgerChartofControlLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    slType!: string | undefined;
    slDesc!: string | undefined;
    

    constructor(data?: IAccountSubLedgerChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.slType = data["slType"];
            this.slDesc = data["slDesc"];
        }
    }

    static fromJS(data: any): AccountSubLedgerChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSubLedgerChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["slType"] = this.slType;
        data["slDesc"] = this.slDesc;
        return data;
    }
}

export interface IAccountSubLedgerChartofControlLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    slType: string | undefined;
    slDesc: string | undefined;
}

export class PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto implements IPagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto {
    totalCount!: number | undefined;
    items!: AccountSubLedgerTaxAuthorityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AccountSubLedgerTaxAuthorityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAccountSubLedgerTaxAuthorityLookupTableDto {
    totalCount: number | undefined;
    items: AccountSubLedgerTaxAuthorityLookupTableDto[] | undefined;
}

export class AccountSubLedgerTaxAuthorityLookupTableDto implements IAccountSubLedgerTaxAuthorityLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    slType!: string | undefined;

    constructor(data?: IAccountSubLedgerTaxAuthorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.slType = data["slType"];
        }
    }

    static fromJS(data: any): AccountSubLedgerTaxAuthorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSubLedgerTaxAuthorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["slType"] = this.slType;
        return data;
    }
}

export interface IAccountSubLedgerTaxAuthorityLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    slType: string | undefined;
}

export class ListResultDtoOfGetAllTaxClassesForCombobox implements IListResultDtoOfGetAllTaxClassesForCombobox {
    items!: GetAllTaxClassesForCombobox[] | undefined;

    constructor(data?: IListResultDtoOfGetAllTaxClassesForCombobox) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAllTaxClassesForCombobox.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllTaxClassesForCombobox {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllTaxClassesForCombobox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllTaxClassesForCombobox {
    items: GetAllTaxClassesForCombobox[] | undefined;
}

export class GetAllTaxClassesForCombobox implements IGetAllTaxClassesForCombobox {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IGetAllTaxClassesForCombobox) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): GetAllTaxClassesForCombobox {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllTaxClassesForCombobox();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IGetAllTaxClassesForCombobox {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class PagedResultDtoOfGetAPOptionForViewDto implements IPagedResultDtoOfGetAPOptionForViewDto {
    totalCount!: number | undefined;
    items!: GetAPOptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAPOptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAPOptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAPOptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAPOptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAPOptionForViewDto {
    totalCount: number | undefined;
    items: GetAPOptionForViewDto[] | undefined;
}

export class GetAPOptionForViewDto implements IGetAPOptionForViewDto {
    apOption!: APOptionDto | undefined;
    currencyRateId!: string | undefined;
    bankBANKID!: string | undefined;
    chartofControlId!: string | undefined;

    constructor(data?: IGetAPOptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apOption = data["apOption"] ? APOptionDto.fromJS(data["apOption"]) : <any>undefined;
            this.currencyRateId = data["currencyRateId"];
            this.bankBANKID = data["bankBANKID"];
            this.chartofControlId = data["chartofControlId"];
        }
    }

    static fromJS(data: any): GetAPOptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAPOptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apOption"] = this.apOption ? this.apOption.toJSON() : <any>undefined;
        data["currencyRateId"] = this.currencyRateId;
        data["bankBANKID"] = this.bankBANKID;
        data["chartofControlId"] = this.chartofControlId;
        return data;
    }
}

export interface IGetAPOptionForViewDto {
    apOption: APOptionDto | undefined;
    currencyRateId: string | undefined;
    bankBANKID: string | undefined;
    chartofControlId: string | undefined;
}

export class APOptionDto implements IAPOptionDto {
    defbankid!: string | undefined;
    defpaycode!: number | undefined;
    defvenctrlacc!: string | undefined;
    defcurrcode!: string | undefined;
    payterms!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAPOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defbankid = data["defbankid"];
            this.defpaycode = data["defpaycode"];
            this.defvenctrlacc = data["defvenctrlacc"];
            this.defcurrcode = data["defcurrcode"];
            this.payterms = data["payterms"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): APOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new APOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defbankid"] = this.defbankid;
        data["defpaycode"] = this.defpaycode;
        data["defvenctrlacc"] = this.defvenctrlacc;
        data["defcurrcode"] = this.defcurrcode;
        data["payterms"] = this.payterms;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        return data;
    }
}

export interface IAPOptionDto {
    defbankid: string | undefined;
    defpaycode: number | undefined;
    defvenctrlacc: string | undefined;
    defcurrcode: string | undefined;
    payterms: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class GetAPOptionForEditOutput implements IGetAPOptionForEditOutput {
    apOption!: CreateOrEditAPOptionDto | undefined;
    currencyRateId!: string | undefined;
    bankBANKID!: string | undefined;
    chartofControlId!: string | undefined;
    sltypeid: string;
    slName :string;

    constructor(data?: IGetAPOptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apOption = data["apOption"] ? CreateOrEditAPOptionDto.fromJS(data["apOption"]) : <any>undefined;
            this.currencyRateId = data["currencyRateId"];
            this.bankBANKID = data["bankBANKID"];
            this.chartofControlId = data["chartofControlId"];
            this.slName=data["slName"];
        }
    }

    static fromJS(data: any): GetAPOptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAPOptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apOption"] = this.apOption ? this.apOption.toJSON() : <any>undefined;
        data["currencyRateId"] = this.currencyRateId;
        data["bankBANKID"] = this.bankBANKID;
        data["chartofControlId"] = this.chartofControlId;
        data["slName"] = this.slName;
        return data;
    }
}

export interface IGetAPOptionForEditOutput {
    apOption: CreateOrEditAPOptionDto | undefined;
    currencyRateId: string | undefined;
    bankBANKID: string | undefined;
    chartofControlId: string | undefined;
    sltypeid: string;
    slName :string;

}

export class CreateOrEditAPOptionDto implements ICreateOrEditAPOptionDto {
    defbankid!: string | undefined;
    defpaycode!: number | undefined;
    defvenctrlacc!: string | undefined;
    defcurrcode!: string | undefined;
    
    payterms!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;
     sltypeid!: string | undefined;
     slName!: string | undefined;
    //defslcode!:string |undefined;
    

    constructor(data?: ICreateOrEditAPOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defbankid = data["defbankid"];
            this.defpaycode = data["defpaycode"];
            this.defvenctrlacc = data["defvenctrlacc"];
            this.defcurrcode = data["defcurrcode"];
            this.payterms = data["payterms"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
            this.sltypeid = data["sltypeid"];
            this.slName = data["slName"];

        }
    }

    static fromJS(data: any): CreateOrEditAPOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAPOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defbankid"] = this.defbankid;
        data["defpaycode"] = this.defpaycode;
        data["defvenctrlacc"] = this.defvenctrlacc;
        data["defcurrcode"] = this.defcurrcode;
        data["payterms"] = this.payterms;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        data ["sltypeid"] = this.sltypeid;
        data ["slName"] = this.slName;
        return data;
    }
}

export interface ICreateOrEditAPOptionDto {
    defbankid: string | undefined;
    defpaycode: number | undefined;
    defvenctrlacc: string | undefined;
    defcurrcode: string | undefined;
    payterms: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
    sltypeid: string | undefined;
    slName: string | undefined;
}

export class PagedResultDtoOfAPOptionCurrencyRateLookupTableDto implements IPagedResultDtoOfAPOptionCurrencyRateLookupTableDto {
    totalCount!: number | undefined;
    items!: APOptionCurrencyRateLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAPOptionCurrencyRateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(APOptionCurrencyRateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAPOptionCurrencyRateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAPOptionCurrencyRateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAPOptionCurrencyRateLookupTableDto {
    totalCount: number | undefined;
    items: APOptionCurrencyRateLookupTableDto[] | undefined;
}

export class APOptionCurrencyRateLookupTableDto implements IAPOptionCurrencyRateLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    currRate!: number | undefined;
    symbol!: string | undefined;
    constructor(data?: IAPOptionCurrencyRateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.currRate = data["currRate"];
            this.symbol=data["symbol"];
        }
    }

    static fromJS(data: any): APOptionCurrencyRateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new APOptionCurrencyRateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["currRate"] = this.currRate;
        data["symbol"]=this.symbol;
        return data;
    }
}

export interface IAPOptionCurrencyRateLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    currRate: number | undefined;
    symbol: string | undefined;
}

export class PagedResultDtoOfAPOptionBankLookupTableDto implements IPagedResultDtoOfAPOptionBankLookupTableDto {
    totalCount!: number | undefined;
    items!: APOptionBankLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAPOptionBankLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(APOptionBankLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAPOptionBankLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAPOptionBankLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAPOptionBankLookupTableDto {
    totalCount: number | undefined;
    items: APOptionBankLookupTableDto[] | undefined;
}

export class APOptionBankLookupTableDto implements IAPOptionBankLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    accountID!: string | undefined;

    constructor(data?: IAPOptionBankLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.accountID = data["accountID"];
        }
    }

    static fromJS(data: any): APOptionBankLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new APOptionBankLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["accountID"] = this.accountID;
        return data;
    }
}

export interface IAPOptionBankLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    accountID: string | undefined;
}

export class PagedResultDtoOfAPOptionChartofControlLookupTableDto implements IPagedResultDtoOfAPOptionChartofControlLookupTableDto {
    totalCount!: number | undefined;
    items!: APOptionChartofControlLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAPOptionChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(APOptionChartofControlLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAPOptionChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAPOptionChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAPOptionChartofControlLookupTableDto {
    totalCount: number | undefined;
    items: APOptionChartofControlLookupTableDto[] | undefined;
}

export class APOptionChartofControlLookupTableDto implements IAPOptionChartofControlLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IAPOptionChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): APOptionChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new APOptionChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAPOptionChartofControlLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class CompanyProfileViewDto implements ICompanyProfileViewDto {
    companyName!: string | undefined;
    contperson!: string | undefined;
    contphone!: string | undefined;
    address!: string | undefined;
    country!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    zipCode!: string | undefined;

    constructor(data?: ICompanyProfileViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.contperson = data["contperson"];
            this.contphone = data["contphone"];
            this.address = data["address"];
            this.country = data["country"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
        }
    }

    static fromJS(data: any): CompanyProfileViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyProfileViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["contperson"] = this.contperson;
        data["contphone"] = this.contphone;
        data["address"] = this.address;
        data["country"] = this.country;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

export interface ICompanyProfileViewDto {
    companyName: string | undefined;
    contperson: string | undefined;
    contphone: string | undefined;
    address: string | undefined;
    country: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
}

export class PagedResultDtoOfGetAPTermForViewDto implements IPagedResultDtoOfGetAPTermForViewDto {
    totalCount!: number | undefined;
    items!: GetAPTermForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAPTermForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAPTermForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAPTermForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAPTermForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAPTermForViewDto {
    totalCount: number | undefined;
    items: GetAPTermForViewDto[] | undefined;
}

export class GetAPTermForViewDto implements IGetAPTermForViewDto {
    apTerm!: APTermDto | undefined;

    constructor(data?: IGetAPTermForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apTerm = data["apTerm"] ? APTermDto.fromJS(data["apTerm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAPTermForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAPTermForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apTerm"] = this.apTerm ? this.apTerm.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAPTermForViewDto {
    apTerm: APTermDto | undefined;
}

export class APTermDto implements IAPTermDto {
    termdesc!: string | undefined;
    termrate!: number | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    inactive!: boolean | undefined;
    termType!: number | undefined;
    taxStatus!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAPTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.termdesc = data["termdesc"];
            this.termrate = data["termrate"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.inactive = data["inactive"];
            this.termType = data["termType"];
            this.taxStatus = data["taxStatus"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): APTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new APTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["termdesc"] = this.termdesc;
        data["termrate"] = this.termrate;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["inactive"] = this.inactive;
        data["termType"] = this.termType;
        data["taxStatus"] = this.taxStatus;
        data["id"] = this.id;
        return data;
    }
}

export interface IAPTermDto {
    termdesc: string | undefined;
    termrate: number | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    inactive: boolean | undefined;
    termType: number | undefined;
    taxStatus: number | undefined;
    id: number | undefined;
}

export class GetAPTermForEditOutput implements IGetAPTermForEditOutput {
    apTerm!: CreateOrEditAPTermDto | undefined;

    constructor(data?: IGetAPTermForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.apTerm = data["apTerm"] ? CreateOrEditAPTermDto.fromJS(data["apTerm"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAPTermForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAPTermForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apTerm"] = this.apTerm ? this.apTerm.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAPTermForEditOutput {
    apTerm: CreateOrEditAPTermDto | undefined;
}

export class CreateOrEditAPTermDto implements ICreateOrEditAPTermDto {
    termdesc!: string | undefined;
    termrate!: number | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    inactive!: boolean;
    termType!: number | undefined;
    taxStatus!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAPTermDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.termdesc = data["termdesc"];
            this.termrate = data["termrate"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.inactive = data["inactive"];
            this.termType = data["termType"];
            this.taxStatus = data["taxStatus"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAPTermDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAPTermDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["termdesc"] = this.termdesc;
        data["termrate"] = this.termrate;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["inactive"] = this.inactive;
        data["termType"] = this.termType;
        data["taxStatus"] = this.taxStatus;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAPTermDto {
    termdesc: string | undefined;
    termrate: number | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    inactive: boolean;
    termType: number | undefined;
    taxStatus: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfGetBookViewModeldto implements IListResultDtoOfGetBookViewModeldto {
    items!: GetBookViewModeldto[] | undefined;

    constructor(data?: IListResultDtoOfGetBookViewModeldto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBookViewModeldto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetBookViewModeldto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetBookViewModeldto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetBookViewModeldto {
    items: GetBookViewModeldto[] | undefined;
}

export class GetBookViewModeldto implements IGetBookViewModeldto {
    bookId!: string | undefined;
    bookName!: string | undefined;

    constructor(data?: IGetBookViewModeldto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookId = data["bookId"];
            this.bookName = data["bookName"];
        }
    }

    static fromJS(data: any): GetBookViewModeldto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBookViewModeldto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookId"] = this.bookId;
        data["bookName"] = this.bookName;
        return data;
    }
}

export interface IGetBookViewModeldto {
    bookId: string | undefined;
    bookName: string | undefined;
}

export class ListResultDtoOfMonthListDto implements IListResultDtoOfMonthListDto {
    items!: MonthListDto[] | undefined;

    constructor(data?: IListResultDtoOfMonthListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MonthListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfMonthListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfMonthListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfMonthListDto {
    items: MonthListDto[] | undefined;
}

export class MonthListDto implements IMonthListDto {
    monthId!: number | undefined;
    monthName!: string | undefined;

    constructor(data?: IMonthListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.monthId = data["monthId"];
            this.monthName = data["monthName"];
        }
    }

    static fromJS(data: any): MonthListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MonthListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["monthId"] = this.monthId;
        data["monthName"] = this.monthName;
        return data;
    }
}

export interface IMonthListDto {
    monthId: number | undefined;
    monthName: string | undefined;
}

export class ListResultDtoOfYearListDto implements IListResultDtoOfYearListDto {
    items!: YearListDto[] | undefined;

    constructor(data?: IListResultDtoOfYearListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(YearListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfYearListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfYearListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfYearListDto {
    items: YearListDto[] | undefined;
}

export class YearListDto implements IYearListDto {
    years!: number | undefined;

    constructor(data?: IYearListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.years = data["years"];
        }
    }

    static fromJS(data: any): YearListDto {
        data = typeof data === 'object' ? data : {};
        let result = new YearListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["years"] = this.years;
        return data;
    }
}

export interface IYearListDto {
    years: number | undefined;
}

export class ListResultDtoOfUserDto implements IListResultDtoOfUserDto {
    items!: UserDto[] | undefined;

    constructor(data?: IListResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfUserDto {
    items: UserDto[] | undefined;
}

export class UserDto implements IUserDto {
    userId!: number | undefined;
    username!: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        return data;
    }
}

export interface IUserDto {
    userId: number | undefined;
    username: string | undefined;
}

export class TransactionListDto implements ITransactionListDto {
    id!: number | undefined;
    subAccId!: number | undefined;
    accountId!: string | undefined;
    bookConfigMerge!: string | undefined;
    detId!: number | undefined;
    bookId!: string | undefined;
    configID!: number | undefined;
    accountName!: string | undefined;
    narration!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    posted!: boolean | undefined;
    doc!: number | undefined;
    date!: string | undefined;
    user!: string | undefined;
    audtTime!: moment.Moment | undefined;
    subAccName!: string | undefined;
    postedBy!: string | undefined;
    postedDate!: moment.Moment | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;

    constructor(data?: ITransactionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.subAccId = data["subAccId"];
            this.accountId = data["accountId"];
            this.bookConfigMerge = data["bookConfigMerge"];
            this.detId = data["detId"];
            this.bookId = data["bookId"];
            this.configID = data["configID"];
            this.accountName = data["accountName"];
            this.narration = data["narration"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.posted = data["posted"];
            this.doc = data["doc"];
            this.date = data["date"];
            this.user = data["user"];
            this.audtTime = data["audtTime"] ? moment(data["audtTime"].toString()) : <any>undefined;
            this.subAccName = data["subAccName"];
            this.postedBy = data["postedBy"];
            this.postedDate = data["postedDate"] ? moment(data["postedDate"].toString()) : <any>undefined;
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
        }
    }

    static fromJS(data: any): TransactionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subAccId"] = this.subAccId;
        data["accountId"] = this.accountId;
        data["bookConfigMerge"] = this.bookConfigMerge;
        data["detId"] = this.detId;
        data["bookId"] = this.bookId;
        data["configID"] = this.configID;
        data["accountName"] = this.accountName;
        data["narration"] = this.narration;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["posted"] = this.posted;
        data["doc"] = this.doc;
        data["date"] = this.date;
        data["user"] = this.user;
        data["audtTime"] = this.audtTime ? this.audtTime.toISOString() : <any>undefined;
        data["subAccName"] = this.subAccName;
        data["postedBy"] = this.postedBy;
        data["postedDate"] = this.postedDate ? this.postedDate.toISOString() : <any>undefined;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        return data;
    }
}

export interface ITransactionListDto {
    id: number | undefined;
    subAccId: number | undefined;
    accountId: string | undefined;
    bookConfigMerge: string | undefined;
    detId: number | undefined;
    bookId: string | undefined;
    configID: number | undefined;
    accountName: string | undefined;
    narration: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    posted: boolean | undefined;
    doc: number | undefined;
    date: string | undefined;
    user: string | undefined;
    audtTime: moment.Moment | undefined;
    subAccName: string | undefined;
    postedBy: string | undefined;
    postedDate: moment.Moment | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
}

export class PagedResultDtoOfGetAROptionForViewDto implements IPagedResultDtoOfGetAROptionForViewDto {
    totalCount!: number | undefined;
    items!: GetAROptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAROptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAROptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAROptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAROptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAROptionForViewDto {
    totalCount: number | undefined;
    items: GetAROptionForViewDto[] | undefined;
}

export class GetAROptionForViewDto implements IGetAROptionForViewDto {
    arOption!: AROptionDto | undefined;
    bankBANKID!: string | undefined;
    currencyRateId!: string | undefined;
    chartofControlId!: string | undefined;
    
    constructor(data?: IGetAROptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.arOption = data["arOption"] ? AROptionDto.fromJS(data["arOption"]) : <any>undefined;
            this.bankBANKID = data["bankBANKID"];
            this.currencyRateId = data["currencyRateId"];
            this.chartofControlId = data["chartofControlId"];
        }
    }

    static fromJS(data: any): GetAROptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAROptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arOption"] = this.arOption ? this.arOption.toJSON() : <any>undefined;
        data["bankBANKID"] = this.bankBANKID;
        data["currencyRateId"] = this.currencyRateId;
        data["chartofControlId"] = this.chartofControlId;
        return data;
    }
}

export interface IGetAROptionForViewDto {
    arOption: AROptionDto | undefined;
    bankBANKID: string | undefined;
    currencyRateId: string | undefined;
    chartofControlId: string | undefined;
}

export class AROptionDto implements IAROptionDto {
    defbankid!: string | undefined;
    defpaycode!: number | undefined;
    defcusctrlacc!: string | undefined;
    defcurrcode!: string | undefined;
    payterms!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAROptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defbankid = data["defbankid"];
            this.defpaycode = data["defpaycode"];
            this.defcusctrlacc = data["defcusctrlacc"];
            this.defcurrcode = data["defcurrcode"];
            this.payterms = data["payterms"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AROptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new AROptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defbankid"] = this.defbankid;
        data["defpaycode"] = this.defpaycode;
        data["defcusctrlacc"] = this.defcusctrlacc;
        data["defcurrcode"] = this.defcurrcode;
        data["payterms"] = this.payterms;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        return data;
    }
}

export interface IAROptionDto {
    defbankid: string | undefined;
    defpaycode: number | undefined;
    defcusctrlacc: string | undefined;
    defcurrcode: string | undefined;
    payterms: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class GetAROptionForEditOutput implements IGetAROptionForEditOutput {
    arOption!: CreateOrEditAROptionDto | undefined;
    bankBANKID!: string | undefined;
    currencyRateId!: string | undefined;
    chartofControlId!: string | undefined;
 slTypeId: string;
    slName :string;
    constructor(data?: IGetAROptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.arOption = data["arOption"] ? CreateOrEditAROptionDto.fromJS(data["arOption"]) : <any>undefined;
            this.bankBANKID = data["bankBANKID"];
            this.currencyRateId = data["currencyRateId"];
            this.chartofControlId = data["chartofControlId"];
            this.slName=data["slName"];
        }
    }

    static fromJS(data: any): GetAROptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAROptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["arOption"] = this.arOption ? this.arOption.toJSON() : <any>undefined;
        data["bankBANKID"] = this.bankBANKID;
        data["currencyRateId"] = this.currencyRateId;
        data["chartofControlId"] = this.chartofControlId;
        data["slName"] = this.slName;
        return data;
    }
}

export interface IGetAROptionForEditOutput {
    arOption: CreateOrEditAROptionDto | undefined;
    bankBANKID: string | undefined;
    currencyRateId: string | undefined;
    chartofControlId: string | undefined;
    slTypeId: string;
    slName :string;
}

export class CreateOrEditAROptionDto implements ICreateOrEditAROptionDto {
    defbankid!: string | undefined;
    defpaycode!: number | undefined;
    defcusctrlacc!: string | undefined;
    defcurrcode!: string | undefined;
    payterms!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;
    sltypeid!: string | undefined;
     slName!: string | undefined;
    constructor(data?: ICreateOrEditAROptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defbankid = data["defbankid"];
            this.defpaycode = data["defpaycode"];
            this.defcusctrlacc = data["defcusctrlacc"];
            this.defcurrcode = data["defcurrcode"];
            this.payterms = data["payterms"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
            this.sltypeid = data["sltypeid"];
            this.slName = data["slName"];
        }
    }

    static fromJS(data: any): CreateOrEditAROptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAROptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defbankid"] = this.defbankid;
        data["defpaycode"] = this.defpaycode;
        data["defcusctrlacc"] = this.defcusctrlacc;
        data["defcurrcode"] = this.defcurrcode;
        data["payterms"] = this.payterms;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        data ["sltypeid"] = this.sltypeid;
        data ["slName"] = this.slName;
        return data;
    }
}

export interface ICreateOrEditAROptionDto {
    defbankid: string | undefined;
    defpaycode: number | undefined;
    defcusctrlacc: string | undefined;
    defcurrcode: string | undefined;
    payterms: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
    sltypeid: string | undefined;
    slName: string | undefined;
}

export class PagedResultDtoOfAROptionBankLookupTableDto implements IPagedResultDtoOfAROptionBankLookupTableDto {
    totalCount!: number | undefined;
    items!: AROptionBankLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAROptionBankLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AROptionBankLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAROptionBankLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAROptionBankLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAROptionBankLookupTableDto {
    totalCount: number | undefined;
    items: AROptionBankLookupTableDto[] | undefined;
}

export class AROptionBankLookupTableDto implements IAROptionBankLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IAROptionBankLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AROptionBankLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AROptionBankLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAROptionBankLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAROptionCurrencyRateLookupTableDto implements IPagedResultDtoOfAROptionCurrencyRateLookupTableDto {
    totalCount!: number | undefined;
    items!: AROptionCurrencyRateLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAROptionCurrencyRateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AROptionCurrencyRateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAROptionCurrencyRateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAROptionCurrencyRateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAROptionCurrencyRateLookupTableDto {
    totalCount: number | undefined;
    items: AROptionCurrencyRateLookupTableDto[] | undefined;
}

export class AROptionCurrencyRateLookupTableDto implements IAROptionCurrencyRateLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IAROptionCurrencyRateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AROptionCurrencyRateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AROptionCurrencyRateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAROptionCurrencyRateLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAROptionChartofControlLookupTableDto implements IPagedResultDtoOfAROptionChartofControlLookupTableDto {
    totalCount!: number | undefined;
    items!: AROptionChartofControlLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAROptionChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AROptionChartofControlLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAROptionChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAROptionChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAROptionChartofControlLookupTableDto {
    totalCount: number | undefined;
    items: AROptionChartofControlLookupTableDto[] | undefined;
}

export class AROptionChartofControlLookupTableDto implements IAROptionChartofControlLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IAROptionChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AROptionChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AROptionChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAROptionChartofControlLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetBankForViewDto implements IPagedResultDtoOfGetBankForViewDto {
    totalCount!: number | undefined;
    items!: GetBankForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBankForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBankForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBankForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBankForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBankForViewDto {
    totalCount: number | undefined;
    items: GetBankForViewDto[] | undefined;
}

export class GetBankForViewDto implements IGetBankForViewDto {
    bank!: BankDto | undefined;
    chartofControlId!: string | undefined;

    constructor(data?: IGetBankForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bank = data["bank"] ? BankDto.fromJS(data["bank"]) : <any>undefined;
            this.chartofControlId = data["chartofControlId"];
        }
    }

    static fromJS(data: any): GetBankForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["chartofControlId"] = this.chartofControlId;
        return data;
    }
}

export interface IGetBankForViewDto {
    bank: BankDto | undefined;
    chartofControlId: string | undefined;
}

export class BankDto implements IBankDto {
    cmpid!: string | undefined;
    docType!: number | undefined;
    bankid!: string | undefined;
    bankname!: string | undefined;
    branchName!: string | undefined;
    addR1!: string | undefined;
    addR2!: string | undefined;
    addR3!: string | undefined;
    addR4!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    postal!: string | undefined;
    contact!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    odlimit!: number | undefined;
    inactive!: boolean | undefined;
    inactdate!: moment.Moment | undefined;
    bkacctnumber!: string | undefined;
    idacctbank!: string | undefined;
    idacctwoff!: string | undefined;
    idacctcrcard!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cmpid = data["cmpid"];
            this.docType = data["docType"];
            this.bankid = data["bankid"];
            this.bankname = data["bankname"];
            this.branchName = data["branchName"];
            this.addR1 = data["addR1"];
            this.addR2 = data["addR2"];
            this.addR3 = data["addR3"];
            this.addR4 = data["addR4"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.postal = data["postal"];
            this.contact = data["contact"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.odlimit = data["odlimit"];
            this.inactive = data["inactive"];
            this.inactdate = data["inactdate"] ? moment(data["inactdate"].toString()) : <any>undefined;
            this.bkacctnumber = data["bkacctnumber"];
            this.idacctbank = data["idacctbank"];
            this.idacctwoff = data["idacctwoff"];
            this.idacctcrcard = data["idacctcrcard"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BankDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cmpid"] = this.cmpid;
        data["docType"] = this.docType;
        data["bankid"] = this.bankid;
        data["bankname"] = this.bankname;
        data["branchName"] = this.branchName;
        data["addR1"] = this.addR1;
        data["addR2"] = this.addR2;
        data["addR3"] = this.addR3;
        data["addR4"] = this.addR4;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postal"] = this.postal;
        data["contact"] = this.contact;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["odlimit"] = this.odlimit;
        data["inactive"] = this.inactive;
        data["inactdate"] = this.inactdate ? this.inactdate.toISOString() : <any>undefined;
        data["bkacctnumber"] = this.bkacctnumber;
        data["idacctbank"] = this.idacctbank;
        data["idacctwoff"] = this.idacctwoff;
        data["idacctcrcard"] = this.idacctcrcard;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        return data;
    }
}

export interface IBankDto {
    cmpid: string | undefined;
    docType: number | undefined;
    bankid: string | undefined;
    bankname: string | undefined;
    branchName: string | undefined;
    addR1: string | undefined;
    addR2: string | undefined;
    addR3: string | undefined;
    addR4: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postal: string | undefined;
    contact: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    odlimit: number | undefined;
    inactive: boolean | undefined;
    inactdate: moment.Moment | undefined;
    bkacctnumber: string | undefined;
    idacctbank: string | undefined;
    idacctwoff: string | undefined;
    idacctcrcard: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class GetBankForEditOutput implements IGetBankForEditOutput {
    bank!: CreateOrEditBankDto | undefined;
    chartofControlId!: string | undefined;

    constructor(data?: IGetBankForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bank = data["bank"] ? CreateOrEditBankDto.fromJS(data["bank"]) : <any>undefined;
            this.chartofControlId = data["chartofControlId"];
        }
    }

    static fromJS(data: any): GetBankForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bank"] = this.bank ? this.bank.toJSON() : <any>undefined;
        data["chartofControlId"] = this.chartofControlId;
        return data;
    }
}

export interface IPagedResultDtoOfGetCPRForViewDto {
    totalCount: number | undefined;
    items: GetCPRForViewDto[] | undefined;
}

export interface IGetCPRForViewDto {
    cpr: CPRDto | undefined;
}

export interface IGetCPRForEditOutput {
    cpr: CreateOrEditCPRDto | undefined;
}

export interface ICreateOrEditCPRDto {
    cprId: number | undefined;
    cprNo: string | undefined;
    active: boolean;
    audtUser: string | undefined;
    audtDate: moment.Moment | undefined;
    createdBy: string | undefined;
    createDate: moment.Moment | undefined;
    id: number | undefined;
}

export interface ICPRDto {
    cprId: number | undefined;
    cprNo: string | undefined;
    active: boolean;
    audtUser: string | undefined;
    audtDate: moment.Moment | undefined;
    createdBy: string | undefined;
    createDate: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetCPRForViewDto implements IPagedResultDtoOfGetCPRForViewDto {
    totalCount!: number | undefined;
    items!: GetCPRForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCPRForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCPRForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCPRForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCPRForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export class GetCPRForViewDto implements IGetCPRForViewDto {
    cpr!: CPRDto | undefined;

    constructor(data?: IGetCPRForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {

        if (data) {
            this.cpr = data["cpr"] ? CPRDto.fromJS(data["cpr"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCPRForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCPRForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cpr"] = this.cpr ? this.cpr.toJSON() : <any>undefined;
        return data;
    }
}

export class CPRDto implements ICPRDto {
    cprId!: number | undefined;
    cprNo!: string | undefined;
    active!: boolean;;
    audtUser!: string | undefined;
    audtDate!: moment.Moment | undefined;
    createdBy!: string | undefined;
    createDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICPRDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            debugger;
            this.cprNo = data["cprNo"];
            this.cprId = data["cprId"];
            this.active = data["active"];
            this.audtUser = data["audtUser"];
            this.audtDate = data["audtDate"];
            this.createdBy = data["createdBy"];
            this.createDate = data["createDate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CPRDto {
        debugger
        data = typeof data === 'object' ? data : {};
        let result = new CPRDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cprNo"] = this.cprNo;
        data["cprId"] = this.cprId;
        data["active"] = this.active;
        data["id"] = this.id;
        data["audtUser"] = this.audtUser;
        data["audtDate"] = this.audtDate;
        data["createdBy"] = this.createdBy;
        data["createDate"] = this.createDate;
        debugger;
        return data;
    }
}

export class GetCPRForEditOutput implements IGetCPRForEditOutput {
    cpr!: CreateOrEditCPRDto | undefined;

    constructor(data?: IGetCPRForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cpr = data["cpr"] ? CreateOrEditCPRDto.fromJS(data["cpr"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCPRForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCPRForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cpr"] = this.cpr ? this.cpr.toJSON() : <any>undefined;
        return data;
    }
}

export class CreateOrEditCPRDto implements ICreateOrEditCPRDto {
    cprId!: number | undefined;
    cprNo!: string | undefined;
    active!: boolean;;
    audtUser!: string | undefined;
    audtDate!: moment.Moment | undefined;
    createdBy!: string | undefined;
    createDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCPRDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            this.cprNo = data["cprNo"];
            this.cprId = data["cprId"];
            this.active = data["active"];
            this.audtUser = data["audtUser"];
            this.audtDate = data["audtDate"];
            this.createdBy = data["createdBy"];
            this.createDate = data["createDate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCPRDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCPRDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger;
        data = typeof data === 'object' ? data : {};
        data["cprNo"] = this.cprNo;
        data["cprId"] = this.cprId;
        data["active"] = this.active;
        data["audtUser"] = this.audtUser;
        data["audtDate"] = this.audtDate;
        data["createdBy"] = this.createdBy;
        data["createDate"] = this.createDate;
        data["id"] = this.id;
        return data;
    }
}

export interface IGetBankForEditOutput {
    bank: CreateOrEditBankDto | undefined;
    chartofControlId: string | undefined;
}

export class CreateOrEditBankDto implements ICreateOrEditBankDto {
    cmpid!: string | undefined;
    docType!: number | undefined;
    bankid!: string | undefined;
    bankname!: string | undefined;
    branchName!: string | undefined;
    addR1!: string | undefined;
    addR2!: string | undefined;
    addR3!: string | undefined;
    addR4!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    postal!: string | undefined;
    contact!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    odlimit!: number | undefined;
    inactive!: boolean;
    inactdate!: moment.Moment | undefined;
    bkacctnumber!: string | undefined;
    idacctbank!: string | undefined;
    idacctwoff!: string | undefined;
    idacctcrcard!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cmpid = data["cmpid"];
            this.docType = data["docType"];
            this.bankid = data["bankid"];
            this.bankname = data["bankname"];
            this.branchName = data["branchName"];
            this.addR1 = data["addR1"];
            this.addR2 = data["addR2"];
            this.addR3 = data["addR3"];
            this.addR4 = data["addR4"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.postal = data["postal"];
            this.contact = data["contact"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.odlimit = data["odlimit"];
            this.inactive = data["inactive"];
            this.inactdate = data["inactdate"] ? moment(data["inactdate"].toString()) : <any>undefined;
            this.bkacctnumber = data["bkacctnumber"];
            this.idacctbank = data["idacctbank"];
            this.idacctwoff = data["idacctwoff"];
            this.idacctcrcard = data["idacctcrcard"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cmpid"] = this.cmpid;
        data["docType"] = this.docType;
        data["bankid"] = this.bankid;
        data["bankname"] = this.bankname;
        data["branchName"] = this.branchName;
        data["addR1"] = this.addR1;
        data["addR2"] = this.addR2;
        data["addR3"] = this.addR3;
        data["addR4"] = this.addR4;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postal"] = this.postal;
        data["contact"] = this.contact;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["odlimit"] = this.odlimit;
        data["inactive"] = this.inactive;
        data["inactdate"] = this.inactdate ? this.inactdate.toISOString() : <any>undefined;
        data["bkacctnumber"] = this.bkacctnumber;
        data["idacctbank"] = this.idacctbank;
        data["idacctwoff"] = this.idacctwoff;
        data["idacctcrcard"] = this.idacctcrcard;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBankDto {
    cmpid: string | undefined;
    docType: number | undefined;
    bankid: string | undefined;
    bankname: string | undefined;
    branchName: string | undefined;
    addR1: string | undefined;
    addR2: string | undefined;
    addR3: string | undefined;
    addR4: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    postal: string | undefined;
    contact: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    odlimit: number | undefined;
    inactive: boolean;
    inactdate: moment.Moment | undefined;
    bkacctnumber: string | undefined;
    idacctbank: string | undefined;
    idacctwoff: string | undefined;
    idacctcrcard: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBankChartofControlLookupTableDto implements IPagedResultDtoOfBankChartofControlLookupTableDto {
    totalCount!: number | undefined;
    items!: BankChartofControlLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBankChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BankChartofControlLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBankChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBankChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBankChartofControlLookupTableDto {
    totalCount: number | undefined;
    items: BankChartofControlLookupTableDto[] | undefined;
}

export class BankChartofControlLookupTableDto implements IBankChartofControlLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    subledger!: boolean | undefined;

    constructor(data?: IBankChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.subledger = data["subledger"];
        }
    }

    static fromJS(data: any): BankChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["subledger"] = this.subledger;
        return data;
    }
}

export interface IBankChartofControlLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    subledger: boolean | undefined;
}

export class PagedResultDtoOfGetBatchListPreviewForViewDto implements IPagedResultDtoOfGetBatchListPreviewForViewDto {
    totalCount!: number | undefined;
    items!: GetBatchListPreviewForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBatchListPreviewForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBatchListPreviewForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBatchListPreviewForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBatchListPreviewForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBatchListPreviewForViewDto {
    totalCount: number | undefined;
    items: GetBatchListPreviewForViewDto[] | undefined;
}

export class GetBatchListPreviewForViewDto implements IGetBatchListPreviewForViewDto {
    batchListPreview!: BatchListPreviewDto | undefined;
    gLTRDetailDto!: GLTRDetailDto | undefined;
    chartofControlDto!: ChartofControlDto | undefined;

    constructor(data?: IGetBatchListPreviewForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.batchListPreview = data["batchListPreview"] ? BatchListPreviewDto.fromJS(data["batchListPreview"]) : <any>undefined;
            this.gLTRDetailDto = data["gLTRDetailDto"] ? GLTRDetailDto.fromJS(data["gLTRDetailDto"]) : <any>undefined;
            this.chartofControlDto = data["chartofControlDto"] ? ChartofControlDto.fromJS(data["chartofControlDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBatchListPreviewForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBatchListPreviewForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batchListPreview"] = this.batchListPreview ? this.batchListPreview.toJSON() : <any>undefined;
        data["gLTRDetailDto"] = this.gLTRDetailDto ? this.gLTRDetailDto.toJSON() : <any>undefined;
        data["chartofControlDto"] = this.chartofControlDto ? this.chartofControlDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetBatchListPreviewForViewDto {
    batchListPreview: BatchListPreviewDto | undefined;
    gLTRDetailDto: GLTRDetailDto | undefined;
    chartofControlDto: ChartofControlDto | undefined;
}

export class BatchListPreviewDto implements IBatchListPreviewDto {
    docDate!: moment.Moment | undefined;
    description!: string | undefined;
    bookDesc!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    approved!: boolean | undefined;
    bookID!: string | undefined;
    locDesc!: string | undefined;
    reference!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBatchListPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.bookDesc = data["bookDesc"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.approved = data["approved"];
            this.bookID = data["bookID"];
            this.locDesc = data["locDesc"];
            this.reference = data["reference"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BatchListPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new BatchListPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["bookDesc"] = this.bookDesc;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["approved"] = this.approved;
        data["bookID"] = this.bookID;
        data["locDesc"] = this.locDesc;
        data["reference"] = this.reference;
        data["id"] = this.id;
        return data;
    }
}

export interface IBatchListPreviewDto {
    docDate: moment.Moment | undefined;
    description: string | undefined;
    bookDesc: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    bookID: string | undefined;
    locDesc: string | undefined;
    reference: string | undefined;
    approved: boolean | undefined;
    id: number | undefined;
}

export class GLTRDetailDto implements IGLTRDetailDto {
    detID!: number | undefined;
    srNo!: number | undefined;
    accountID!: string | undefined;
    accountDesc!: string | undefined;
    subAccID!: number | undefined;
    subAccDesc!: string | undefined;
    narration!: string | undefined;
    amount!: number | undefined;
    chequeNo!: string | undefined;
    isAuto!: boolean | undefined;
    locId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IGLTRDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.detID = data["detID"];
            this.srNo = data["srNo"];
            this.accountID = data["accountID"];
            this.accountDesc = data["accountDesc"];
            this.subAccID = data["subAccID"];
            this.subAccDesc = data["subAccDesc"];
            this.narration = data["narration"];
            this.amount = data["amount"];
            this.chequeNo = data["chequeNo"];
            this.isAuto = data["isAuto"];
            this.locId = data["locId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GLTRDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLTRDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detID"] = this.detID;
        data["srNo"] = this.srNo;
        data["accountID"] = this.accountID;
        data["accountDesc"] = this.accountDesc;
        data["subAccID"] = this.subAccID;
        data["subAccDesc"] = this.subAccDesc;
        data["narration"] = this.narration;
        data["amount"] = this.amount;
        data["chequeNo"] = this.chequeNo;
        data["isAuto"] = this.isAuto;
        data["locId"] = this.locId;
        data["id"] = this.id;
        return data;
    }
}

export interface IGLTRDetailDto {
    detID: number | undefined;
    srNo: number | undefined;
    accountID: string | undefined;
    accountDesc: string | undefined;
    subAccID: number | undefined;
    subAccDesc: string | undefined;
    narration: string | undefined;
    amount: number | undefined;
    chequeNo: string | undefined;
    isAuto: boolean | undefined;
    locId: number | undefined;
    id: number | undefined;
}

export class ChartofControlDto implements IChartofControlDto {
    accountName!: string | undefined;
    subLedger!: boolean | undefined;
    optFld!: number | undefined;
    tenantId!: number | undefined;
    slType!: number | undefined;
    inactive!: boolean | undefined;
    creationDate!: moment.Moment | undefined;
    auditUser!: string | undefined;
    auditTime!: moment.Moment | undefined;
    oldCode!: string | undefined;
    controlDetailId!: string | undefined;
    subControlDetailId!: string | undefined;
    segmentlevel3Id!: string | undefined;
    sortOrder!: number | undefined;
    accountType!: string | undefined;
    accountHeader!: number | undefined;
    id!: string | undefined;

    constructor(data?: IChartofControlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountName = data["accountName"];
            this.subLedger = data["subLedger"];
            this.optFld = data["optFld"];
            this.tenantId = data["tenantId"];
            this.slType = data["slType"];
            this.inactive = data["inactive"];
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.auditUser = data["auditUser"];
            this.auditTime = data["auditTime"] ? moment(data["auditTime"].toString()) : <any>undefined;
            this.oldCode = data["oldCode"];
            this.controlDetailId = data["controlDetailId"];
            this.subControlDetailId = data["subControlDetailId"];
            this.segmentlevel3Id = data["segmentlevel3Id"];
            this.sortOrder = data["sortOrder"];
            this.accountHeader = data["accountHeader"];
            this.accountType = data["accountType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChartofControlDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartofControlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["subLedger"] = this.subLedger;
        data["optFld"] = this.optFld;
        data["tenantId"] = this.tenantId;
        data["slType"] = this.slType;
        data["inactive"] = this.inactive;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["auditUser"] = this.auditUser;
        data["auditTime"] = this.auditTime ? this.auditTime.toISOString() : <any>undefined;
        data["oldCode"] = this.oldCode;
        data["controlDetailId"] = this.controlDetailId;
        data["subControlDetailId"] = this.subControlDetailId;
        data["segmentlevel3Id"] = this.segmentlevel3Id;
        data["sortOrder"] = this.sortOrder;
        data["accountType"] = this.accountType;
        data["accountHeader"] = this.accountHeader;
        data["id"] = this.id;
        return data;
    }
}

export interface IChartofControlDto {
    accountName: string | undefined;
    subLedger: boolean | undefined;
    optFld: number | undefined;
    tenantId: number | undefined;
    slType: number | undefined;
    inactive: boolean | undefined;
    creationDate: moment.Moment | undefined;
    auditUser: string | undefined;
    auditTime: moment.Moment | undefined;
    oldCode: string | undefined;
    controlDetailId: string | undefined;
    subControlDetailId: string | undefined;
    segmentlevel3Id: string | undefined;
    sortOrder: number | undefined;
    accountType: string | undefined;
    accountHeader: number | undefined;
    id: string | undefined;
}

export class GetBatchListPreviewForEditOutput implements IGetBatchListPreviewForEditOutput {
    batchListPreview!: CreateOrEditBatchListPreviewDto | undefined;

    constructor(data?: IGetBatchListPreviewForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.batchListPreview = data["batchListPreview"] ? CreateOrEditBatchListPreviewDto.fromJS(data["batchListPreview"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBatchListPreviewForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBatchListPreviewForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["batchListPreview"] = this.batchListPreview ? this.batchListPreview.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetBatchListPreviewForEditOutput {
    batchListPreview: CreateOrEditBatchListPreviewDto | undefined;
}

export class CreateOrEditBatchListPreviewDto implements ICreateOrEditBatchListPreviewDto {
    id!: number | undefined;

    constructor(data?: ICreateOrEditBatchListPreviewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBatchListPreviewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBatchListPreviewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBatchListPreviewDto {
    id: number | undefined;
}

export class PagedResultDtoOfGetBkTransferForViewDto implements IPagedResultDtoOfGetBkTransferForViewDto {
    totalCount!: number | undefined;
    items!: GetBkTransferForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBkTransferForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBkTransferForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBkTransferForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBkTransferForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetBkTransferForViewDto {
    totalCount: number | undefined;
    items: GetBkTransferForViewDto[] | undefined;
}

export class GetBkTransferForViewDto implements IGetBkTransferForViewDto {
    bkTransfer!: BkTransferDto | undefined;
    bankBANKNAME!: string | undefined;

    constructor(data?: IGetBkTransferForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bkTransfer = data["bkTransfer"] ? BkTransferDto.fromJS(data["bkTransfer"]) : <any>undefined;
            this.bankBANKNAME = data["bankBANKNAME"];
        }
    }

    static fromJS(data: any): GetBkTransferForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBkTransferForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bkTransfer"] = this.bkTransfer ? this.bkTransfer.toJSON() : <any>undefined;
        data["bankBANKNAME"] = this.bankBANKNAME;
        return data;
    }
}

export interface IGetBkTransferForViewDto {
    bkTransfer: BkTransferDto | undefined;
    bankBANKNAME: string | undefined;
}

export class BkTransferDto implements IBkTransferDto {
    cmpid!: string | undefined;
    docid!: number | undefined;
    docdate!: moment.Moment | undefined;
    transferdate!: moment.Moment | undefined;
    description!: string | undefined;
    frombankid!: number | undefined;
    fromconfigid!: number | undefined;
    tobankid!: number | undefined;
    toconfigid!: number | undefined;
    availlimit!: number | undefined;
    transferamount!: number | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    bankId!: number | undefined;
    status!: boolean
    id!: number | undefined;

    constructor(data?: IBkTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cmpid = data["cmpid"];
            this.docid = data["docid"];
            this.docdate = data["docdate"] ? moment(data["docdate"].toString()) : <any>undefined;
            this.transferdate = data["transferdate"] ? moment(data["transferdate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.frombankid = data["frombankid"];
            this.fromconfigid = data["fromconfigid"];
            this.tobankid = data["tobankid"];
            this.toconfigid = data["toconfigid"];
            this.availlimit = data["availlimit"];
            this.transferamount = data["transferamount"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.bankId = data["bankId"];
            this.status = data["status"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BkTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new BkTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cmpid"] = this.cmpid;
        data["docid"] = this.docid;
        data["docdate"] = this.docdate ? this.docdate.toISOString() : <any>undefined;
        data["transferdate"] = this.transferdate ? this.transferdate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["frombankid"] = this.frombankid;
        data["fromconfigid"] = this.fromconfigid;
        data["tobankid"] = this.tobankid;
        data["toconfigid"] = this.toconfigid;
        data["availlimit"] = this.availlimit;
        data["transferamount"] = this.transferamount;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["bankId"] = this.bankId;
        data["status"] = this.status;
        data["id"] = this.id;
        return data;
    }
}

export interface IBkTransferDto {
    cmpid: string | undefined;
    docid: number | undefined;
    docdate: moment.Moment | undefined;
    transferdate: moment.Moment | undefined;
    description: string | undefined;
    frombankid: number | undefined;
    fromconfigid: number | undefined;
    tobankid: number | undefined;
    toconfigid: number | undefined;
    availlimit: number | undefined;
    transferamount: number | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    bankId: number | undefined;
    status: boolean;
    id: number | undefined;
}

export class GetBkTransferForEditOutput implements IGetBkTransferForEditOutput {
    bkTransfer!: CreateOrEditBkTransferDto | undefined;
    fromBankName!: string | undefined;
    fromBankAddress!: string | undefined;
    fromBankAccount!: string | undefined;
    toBankName!: string | undefined;
    toBankAddress!: string | undefined;
    toBankAccount!: string | undefined;

    constructor(data?: IGetBkTransferForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bkTransfer = data["bkTransfer"] ? CreateOrEditBkTransferDto.fromJS(data["bkTransfer"]) : <any>undefined;
            this.fromBankName = data["fromBankName"];
            this.fromBankAddress = data["fromBankAddress"];
            this.fromBankAccount = data["fromBankAccount"];
            this.toBankName = data["toBankName"];
            this.toBankAddress = data["toBankAddress"];
            this.toBankAccount = data["toBankAccount"];
        }
    }

    static fromJS(data: any): GetBkTransferForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBkTransferForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bkTransfer"] = this.bkTransfer ? this.bkTransfer.toJSON() : <any>undefined;
        data["fromBankName"] = this.fromBankName;
        data["fromBankAddress"] = this.fromBankAddress;
        data["fromBankAccount"] = this.fromBankAccount;
        data["toBankName"] = this.toBankName;
        data["toBankAddress"] = this.toBankAddress;
        data["toBankAccount"] = this.toBankAccount;
        return data;
    }
}

export interface IGetBkTransferForEditOutput {
    bkTransfer: CreateOrEditBkTransferDto | undefined;
    fromBankName: string | undefined;
    fromBankAddress: string | undefined;
    fromBankAccount: string | undefined;
    toBankName: string | undefined;
    toBankAddress: string | undefined;
    toBankAccount: string | undefined;
}

export class CreateOrEditBkTransferDto implements ICreateOrEditBkTransferDto {
    cmpid!: string | undefined;
    docid!: number;
    docdate!: moment.Moment;
    transferdate!: moment.Moment;
    description!: string | undefined;
    frombankid!: number | undefined;
    fromconfigid!: number | undefined;
    tobankid!: number | undefined;
    toconfigid!: number | undefined;
    availlimit!: number | undefined;
    transferamount!: number | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    bankId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBkTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {

            this.cmpid = data["cmpid"];
            this.docid = data["docid"];
            this.docdate = data["docdate"] ? moment(data["docdate"].toString()) : <any>undefined;
            this.transferdate = data["transferdate"] ? moment(data["transferdate"].toString()) : <any>undefined;
            this.description = data["description"];
            this.frombankid = data["frombankid"];
            this.fromconfigid = data["fromconfigid"];
            this.tobankid = data["tobankid"];
            this.toconfigid = data["toconfigid"];
            this.availlimit = data["availlimit"];
            this.transferamount = data["transferamount"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.bankId = data["bankId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBkTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBkTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};

        data["cmpid"] = this.cmpid;
        data["docid"] = this.docid;
        data["docdate"] = this.docdate ? this.docdate.toISOString() : <any>undefined;
        data["transferdate"] = this.transferdate ? this.transferdate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["frombankid"] = this.frombankid;
        data["fromconfigid"] = this.fromconfigid;
        data["tobankid"] = this.tobankid;
        data["toconfigid"] = this.toconfigid;
        data["availlimit"] = this.availlimit;
        data["transferamount"] = this.transferamount;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["bankId"] = this.bankId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditBkTransferDto {
    cmpid: string | undefined;
    docid: number;
    docdate: moment.Moment;
    transferdate: moment.Moment;
    description: string | undefined;
    frombankid: number | undefined;
    fromconfigid: number | undefined;
    tobankid: number | undefined;
    toconfigid: number | undefined;
    availlimit: number | undefined;
    transferamount: number | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    bankId: number | undefined;
    id: number | undefined;
}

export class DataForCreateFormDto implements IDataForCreateFormDto {
    docId!: number | undefined;

    constructor(data?: IDataForCreateFormDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docId = data["docId"];
        }
    }

    static fromJS(data: any): DataForCreateFormDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataForCreateFormDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docId"] = this.docId;
        return data;
    }
}

export interface IDataForCreateFormDto {
    docId: number | undefined;
}

export class PagedResultDtoOfBkTransferBankLookupTableDto implements IPagedResultDtoOfBkTransferBankLookupTableDto {
    totalCount!: number | undefined;
    items!: BkTransferBankLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBkTransferBankLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BkTransferBankLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBkTransferBankLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBkTransferBankLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfBkTransferBankLookupTableDto {
    totalCount: number | undefined;
    items: BkTransferBankLookupTableDto[] | undefined;
}

export class BkTransferBankLookupTableDto implements IBkTransferBankLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;
    address!: string | undefined;
    bankAccount!: string | undefined;
    availableLimit!: number | undefined;

    constructor(data?: IBkTransferBankLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.address = data["address"];
            this.bankAccount = data["bankAccount"];
            this.availableLimit = data["availableLimit"];
        }
    }

    static fromJS(data: any): BkTransferBankLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BkTransferBankLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["address"] = this.address;
        data["bankAccount"] = this.bankAccount;
        data["availableLimit"] = this.availableLimit;
        return data;
    }
}

export interface IBkTransferBankLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
    address: string | undefined;
    bankAccount: string | undefined;
    availableLimit: number | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class CashBookForViewDto implements ICashBookForViewDto {
    cashBookDto!: CashBookDto | undefined;

    constructor(data?: ICashBookForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashBookDto = data["cashBookDto"] ? CashBookDto.fromJS(data["cashBookDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CashBookForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashBookForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashBookDto"] = this.cashBookDto ? this.cashBookDto.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICashBookForViewDto {
    cashBookDto: CashBookDto | undefined;
}

export class CashBookDto implements ICashBookDto {
    voucher!: number | undefined;
    accountID!: string | undefined;
    accountName!: string | undefined;
    narration!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    balance!: number | undefined;

    constructor(data?: ICashBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.voucher = data["voucher"];
            this.accountID = data["accountID"];
            this.accountName = data["accountName"];
            this.narration = data["narration"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.balance = data["balance"];
        }
    }

    static fromJS(data: any): CashBookDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashBookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["voucher"] = this.voucher;
        data["accountID"] = this.accountID;
        data["accountName"] = this.accountName;
        data["narration"] = this.narration;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["balance"] = this.balance;
        return data;
    }
}

export interface ICashBookDto {
    voucher: number | undefined;
    accountID: string | undefined;
    accountName: string | undefined;
    narration: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    balance: number | undefined;
}

export class CashReceiptModel implements ICashReceiptModel {
    accountCode!: string | undefined;
    accountTitle!: string | undefined;
    docNo!: number | undefined;
    subledgerCode!: number | undefined;
    subledgerDesc!: string | undefined;
    narration!: string | undefined;
    detailNarration!: string | undefined;
    docDate!: moment.Moment | undefined;
    bookId!: string | undefined;
    bookName!: string | undefined;
    configId!: number | undefined;
    approvedBy!: string | undefined;
    posted!: boolean | undefined;
    postedBy!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    amount!: number | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;
    isAuto!: boolean | undefined;
    firstSignature!: string | undefined;
    secondSignature!: string | undefined;
    thirdSignature!: string | undefined;
    fourthSignature!: string | undefined;
    fifthSignature!: string | undefined;
    sixthSignature!: string | undefined;
    createdBy!: string | undefined;
    createdAt!: moment.Moment | undefined;

    constructor(data?: ICashReceiptModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountCode = data["accountCode"];
            this.accountTitle = data["accountTitle"];
            this.docNo = data["docNo"];
            this.subledgerCode = data["subledgerCode"];
            this.subledgerDesc = data["subledgerDesc"];
            this.narration = data["narration"];
            this.detailNarration = data["detailNarration"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.bookId = data["bookId"];
            this.bookName = data["bookName"];
            this.configId = data["configId"];
            this.approvedBy = data["approvedBy"];
            this.posted = data["posted"];
            this.postedBy = data["postedBy"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.amount = data["amount"];
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
            this.isAuto = data["isAuto"];
            this.firstSignature = data["firstSignature"];
            this.secondSignature = data["secondSignature"];
            this.thirdSignature = data["thirdSignature"];
            this.fourthSignature = data["fourthSignature"];
            this.fifthSignature = data["fifthSignature"];
            this.sixthSignature = data["sixthSignature"];
            this.createdBy = data["createdBy"];
            this.createdAt = data["createdAt"] ? moment(data["createdAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CashReceiptModel {
        data = typeof data === 'object' ? data : {};
        let result = new CashReceiptModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountCode"] = this.accountCode;
        data["accountTitle"] = this.accountTitle;
        data["docNo"] = this.docNo;
        data["subledgerCode"] = this.subledgerCode;
        data["subledgerDesc"] = this.subledgerDesc;
        data["narration"] = this.narration;
        data["detailNarration"] = this.detailNarration;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["bookId"] = this.bookId;
        data["bookName"] = this.bookName;
        data["configId"] = this.configId;
        data["approvedBy"] = this.approvedBy;
        data["posted"] = this.posted;
        data["postedBy"] = this.postedBy;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["amount"] = this.amount;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        data["isAuto"] = this.isAuto;
        data["firstSignature"] = this.firstSignature;
        data["secondSignature"] = this.secondSignature;
        data["thirdSignature"] = this.thirdSignature;
        data["fourthSignature"] = this.fourthSignature;
        data["fifthSignature"] = this.fifthSignature;
        data["sixthSignature"] = this.sixthSignature;
        data["createdBy"] = this.createdBy;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICashReceiptModel {
    accountCode: string | undefined;
    accountTitle: string | undefined;
    docNo: number | undefined;
    subledgerCode: number | undefined;
    subledgerDesc: string | undefined;
    narration: string | undefined;
    detailNarration: string | undefined;
    docDate: moment.Moment | undefined;
    bookId: string | undefined;
    bookName: string | undefined;
    configId: number | undefined;
    approvedBy: string | undefined;
    posted: boolean | undefined;
    postedBy: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    amount: number | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
    isAuto: boolean | undefined;
    firstSignature: string | undefined;
    secondSignature: string | undefined;
    thirdSignature: string | undefined;
    fourthSignature: string | undefined;
    fifthSignature: string | undefined;
    sixthSignature: string | undefined;
    createdBy: string | undefined;
    createdAt: moment.Moment | undefined;
}

export class ChartOfAccountListDto implements IChartOfAccountListDto {
    accountCode!: string | undefined;
    accountTitle!: string | undefined;
    family!: string | undefined;
    subLedger!: boolean | undefined;
    groupDesc!: string | undefined;
    segment1!: string | undefined;
    segment1Name!: string | undefined;
    segment2!: string | undefined;
    segment2Name!: string | undefined;
    segment3!: string | undefined;
    segment3Name!: string | undefined;

    constructor(data?: IChartOfAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountCode = data["accountCode"];
            this.accountTitle = data["accountTitle"];
            this.family = data["family"];
            this.subLedger = data["subLedger"];
            this.groupDesc = data["groupDesc"];
            this.segment1 = data["segment1"];
            this.segment1Name = data["segment1Name"];
            this.segment2 = data["segment2"];
            this.segment2Name = data["segment2Name"];
            this.segment3 = data["segment3"];
            this.segment3Name = data["segment3Name"];
        }
    }

    static fromJS(data: any): ChartOfAccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfAccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountCode"] = this.accountCode;
        data["accountTitle"] = this.accountTitle;
        data["family"] = this.family;
        data["subLedger"] = this.subLedger;
        data["groupDesc"] = this.groupDesc;
        data["segment1"] = this.segment1;
        data["segment1Name"] = this.segment1Name;
        data["segment2"] = this.segment2;
        data["segment2Name"] = this.segment2Name;
        data["segment3"] = this.segment3;
        data["segment3Name"] = this.segment3Name;
        return data;
    }
}

export interface IChartOfAccountListDto {
    accountCode: string | undefined;
    accountTitle: string | undefined;
    family: string | undefined;
    subLedger: boolean | undefined;
    groupDesc: string | undefined;
    segment1: string | undefined;
    segment1Name: string | undefined;
    segment2: string | undefined;
    segment2Name: string | undefined;
    segment3: string | undefined;
    segment3Name: string | undefined;
}

export class SubledgerListDto implements ISubledgerListDto {
    accountCode!: string | undefined;
    accountTitle!: string | undefined;
    subAccID!: number | undefined;
    subAccTitle!: string | undefined;
    address!: string | undefined;
    city!: string | undefined;
    phone!: string | undefined;

    constructor(data?: ISubledgerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountCode = data["accountCode"];
            this.accountTitle = data["accountTitle"];
            this.subAccID = data["subAccID"];
            this.subAccTitle = data["subAccTitle"];
            this.address = data["address"];
            this.city = data["city"];
            this.phone = data["phone"];
        }
    }

    static fromJS(data: any): SubledgerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubledgerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountCode"] = this.accountCode;
        data["accountTitle"] = this.accountTitle;
        data["subAccID"] = this.subAccID;
        data["subAccTitle"] = this.subAccTitle;
        data["address"] = this.address;
        data["city"] = this.city;
        data["phone"] = this.phone;
        return data;
    }
}

export interface ISubledgerListDto {
    accountCode: string | undefined;
    accountTitle: string | undefined;
    subAccID: number | undefined;
    subAccTitle: string | undefined;
    address: string | undefined;
    city: string | undefined;
    phone: string | undefined;
}

export class PagedResultDtoOfGetChartofControlForViewDto implements IPagedResultDtoOfGetChartofControlForViewDto {
    totalCount!: number | undefined;
    items!: GetChartofControlForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetChartofControlForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetChartofControlForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetChartofControlForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetChartofControlForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetChartofControlForViewDto {
    totalCount: number | undefined;
    items: GetChartofControlForViewDto[] | undefined;
}

export class GetChartofControlForViewDto implements IGetChartofControlForViewDto {
    chartofControl!: ChartofControlDto | undefined;
    controlDetailSegmentName!: string | undefined;
    subControlDetailSegmentName!: string | undefined;
    segmentlevel3SegmentName!: string | undefined;

    constructor(data?: IGetChartofControlForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.chartofControl = data["chartofControl"] ? ChartofControlDto.fromJS(data["chartofControl"]) : <any>undefined;
            this.controlDetailSegmentName = data["controlDetailSegmentName"];
            this.subControlDetailSegmentName = data["subControlDetailSegmentName"];
            this.segmentlevel3SegmentName = data["segmentlevel3SegmentName"];
        }
    }

    static fromJS(data: any): GetChartofControlForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetChartofControlForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chartofControl"] = this.chartofControl ? this.chartofControl.toJSON() : <any>undefined;
        data["controlDetailSegmentName"] = this.controlDetailSegmentName;
        data["subControlDetailSegmentName"] = this.subControlDetailSegmentName;
        data["segmentlevel3SegmentName"] = this.segmentlevel3SegmentName;
        return data;
    }
}

export interface IGetChartofControlForViewDto {
    chartofControl: ChartofControlDto | undefined;
    controlDetailSegmentName: string | undefined;
    subControlDetailSegmentName: string | undefined;
    segmentlevel3SegmentName: string | undefined;
}

export class GetChartofControlForEditOutput implements IGetChartofControlForEditOutput {
    chartofControl!: CreateOrEditChartofControlDto | undefined;
    controlDetailSegmentName!: string | undefined;
    subControlDetailSegmentName!: string | undefined;
    segmentlevel3SegmentName!: string | undefined;

    constructor(data?: IGetChartofControlForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.chartofControl = data["chartofControl"] ? CreateOrEditChartofControlDto.fromJS(data["chartofControl"]) : <any>undefined;
            this.controlDetailSegmentName = data["controlDetailSegmentName"];
            this.subControlDetailSegmentName = data["subControlDetailSegmentName"];
            this.segmentlevel3SegmentName = data["segmentlevel3SegmentName"];
        }
    }

    static fromJS(data: any): GetChartofControlForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetChartofControlForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chartofControl"] = this.chartofControl ? this.chartofControl.toJSON() : <any>undefined;
        data["controlDetailSegmentName"] = this.controlDetailSegmentName;
        data["subControlDetailSegmentName"] = this.subControlDetailSegmentName;
        data["segmentlevel3SegmentName"] = this.segmentlevel3SegmentName;
        return data;
    }
}

export interface IGetChartofControlForEditOutput {
    chartofControl: CreateOrEditChartofControlDto | undefined;
    controlDetailSegmentName: string | undefined;
    subControlDetailSegmentName: string | undefined;
    segmentlevel3SegmentName: string | undefined;
}

export class CreateOrEditChartofControlDto implements ICreateOrEditChartofControlDto {
    accountName!: string;
    subLedger!: boolean;
    segmantID1: string | undefined;
    optFld!: number | undefined;
    slType!: number | undefined;
    inactive!: boolean | undefined;
    creationDate!: moment.Moment | undefined;
    auditUser!: string | undefined;
    auditTime!: moment.Moment | undefined;
    oldCode!: string | undefined;
    controlDetailId!: string | undefined;
    subControlDetailId!: string | undefined;
    segmentlevel3Id!: string | undefined;
    flag!: boolean | undefined;
    groupCode!: number | undefined;
    sortOrder!: number | undefined;
    accountType!: string | undefined;
    accountHeader!: number | undefined;
    accountBSType !: string | undefined;
    accountBSHeader !: number | undefined;
    sortBSOrder !: number | undefined;
    accountCFType !: string | undefined;
    accountCFHeader !: number | undefined;
    sortCFOrder !: number | undefined;
    id!: string | undefined;
    accNature: string | undefined;
    acctype:string|undefined;
    categoryID: number | undefined;
    

    constructor(data?: ICreateOrEditChartofControlDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            this.accountName = data["accountName"];
            this.subLedger = data["subLedger"];
            this.segmantID1 = data["segmantID1"];
            this.optFld = data["optFld"];
            this.slType = data["slType"];
            this.inactive = data["inactive"];
            this.creationDate = data["creationDate"] ? moment(data["creationDate"].toString()) : <any>undefined;
            this.auditUser = data["auditUser"];
            this.auditTime = data["auditTime"] ? moment(data["auditTime"].toString()) : <any>undefined;
            this.oldCode = data["oldCode"];
            this.controlDetailId = data["controlDetailId"];
            this.subControlDetailId = data["subControlDetailId"];
            this.segmentlevel3Id = data["segmentlevel3Id"];
            this.flag = data["flag"];
            this.groupCode = data["groupCode"];
            this.sortOrder = data["sortOrder"];
            this.accountType = data["accountType"];
            this.accountHeader = data["accountHeader"];
            this.sortBSOrder = data["sortBSOrder"];
            this.accountBSType = data["accountBSType"];
            this.accountBSHeader = data["accountBSHeader"];
            this.sortCFOrder = data["sortCFOrder"];
            this.accountCFType = data["accountCFType"];
            this.accountCFHeader = data["accountCFHeader"];
            this.id = data["id"];
            this.accNature = data["accNature"];
            this.acctype=data["acctype"];
            this.categoryID = data["categoryID"];
        }
    }

    static fromJS(data: any): CreateOrEditChartofControlDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditChartofControlDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["subLedger"] = this.subLedger;
        data["segmantID1"] = this.segmantID1;
        data["optFld"] = this.optFld;
        data["slType"] = this.slType;
        data["inactive"] = this.inactive;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["auditUser"] = this.auditUser;
        data["auditTime"] = this.auditTime ? this.auditTime.toISOString() : <any>undefined;
        data["oldCode"] = this.oldCode;
        data["controlDetailId"] = this.controlDetailId;
        data["subControlDetailId"] = this.subControlDetailId;
        data["segmentlevel3Id"] = this.segmentlevel3Id;
        data["flag"] = this.flag;
        data["groupCode"] = this.groupCode;
        data["sortOrder"] = this.sortOrder;
        data["accountType"] = this.accountType;
        data["accountHeader"] = this.accountHeader;
        data["sortBSOrder"] = this.sortBSOrder;
        data["accountBSType"] = this.accountBSType;
        data["accountBSHeader"] = this.accountBSHeader;
        data["sortCFOrder"] = this.sortCFOrder;
        data["accountCFType"] = this.accountCFType;
        data["accountCFHeader"] = this.accountCFHeader;
        data["id"] = this.id;
        data["accNature"] = this.accNature;
        data["acctype"]=this.acctype;
        data["categoryID"] = this.categoryID;
        return data;
    }
}

export interface ICreateOrEditChartofControlDto {
    accountName: string;
    subLedger: boolean;
    segmantID1: string | undefined;
    optFld: number | undefined;
    slType: number | undefined;
    inactive: boolean | undefined;
    creationDate: moment.Moment | undefined;
    auditUser: string | undefined;
    auditTime: moment.Moment | undefined;
    oldCode: string | undefined;
    controlDetailId: string | undefined;
    subControlDetailId: string | undefined;
    segmentlevel3Id: string | undefined;
    flag: boolean | undefined;
    groupCode: number | undefined;
    sortOrder: number | undefined;
    accountType: string | undefined;
    accountHeader: number | undefined;
    sortBSOrder: number | undefined;
    accountBSType: string | undefined;
    accountBSHeader: number | undefined;
    sortCFOrder: number | undefined;
    accountCFType: string | undefined;
    accountCFHeader: number | undefined;
    id: string | undefined;
    accNature: string | undefined;
    acctype:string|undefined;
    categoryID: number | undefined;
}

export class ListResultDtoOfSegmentCodeDtoView implements IListResultDtoOfSegmentCodeDtoView {
    items!: SegmentCodeDtoView[] | undefined;

    constructor(data?: IListResultDtoOfSegmentCodeDtoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SegmentCodeDtoView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSegmentCodeDtoView {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSegmentCodeDtoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSegmentCodeDtoView {
    items: SegmentCodeDtoView[] | undefined;
}

export class SegmentCodeDtoView implements ISegmentCodeDtoView {
    groupId!: number | undefined;
    groupname!: string | undefined;
    groupCode!: number | undefined;
    constructor(data?: ISegmentCodeDtoView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupId = data["groupId"];
            this.groupname = data["groupname"];
            this.groupCode = data["groupCode"];
        }
    }

    static fromJS(data: any): SegmentCodeDtoView {
        data = typeof data === 'object' ? data : {};
        let result = new SegmentCodeDtoView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["groupname"] = this.groupname;
        data["groupCode"] = this.groupCode;
        return data;
    }
}

export interface ISegmentCodeDtoView {
    groupId: number | undefined;
    groupname: string | undefined;
    groupCode: number | undefined;
}

export class PagedResultDtoOfChartofControlControlDetailLookupTableDto implements IPagedResultDtoOfChartofControlControlDetailLookupTableDto {
    totalCount!: number | undefined;
    items!: ChartofControlControlDetailLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfChartofControlControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChartofControlControlDetailLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChartofControlControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChartofControlControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChartofControlControlDetailLookupTableDto {
    totalCount: number | undefined;
    items: ChartofControlControlDetailLookupTableDto[] | undefined;
}

export class ChartofControlControlDetailLookupTableDto implements IChartofControlControlDetailLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IChartofControlControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ChartofControlControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartofControlControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IChartofControlControlDetailLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfChartofControlSubControlDetailLookupTableDto implements IPagedResultDtoOfChartofControlSubControlDetailLookupTableDto {
    totalCount!: number | undefined;
    items!: ChartofControlSubControlDetailLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfChartofControlSubControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChartofControlSubControlDetailLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChartofControlSubControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChartofControlSubControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChartofControlSubControlDetailLookupTableDto {
    totalCount: number | undefined;
    items: ChartofControlSubControlDetailLookupTableDto[] | undefined;
}

export class ChartofControlSubControlDetailLookupTableDto implements IChartofControlSubControlDetailLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IChartofControlSubControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ChartofControlSubControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartofControlSubControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IChartofControlSubControlDetailLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto implements IPagedResultDtoOfChartofControlSegmentlevel3LookupTableDto {
    totalCount!: number | undefined;
    items!: ChartofControlSegmentlevel3LookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfChartofControlSegmentlevel3LookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChartofControlSegmentlevel3LookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfChartofControlSegmentlevel3LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfChartofControlSegmentlevel3LookupTableDto {
    totalCount: number | undefined;
    items: ChartofControlSegmentlevel3LookupTableDto[] | undefined;
}

export class ChartofControlSegmentlevel3LookupTableDto implements IChartofControlSegmentlevel3LookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IChartofControlSegmentlevel3LookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ChartofControlSegmentlevel3LookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartofControlSegmentlevel3LookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IChartofControlSegmentlevel3LookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetGLOptionForViewDto implements IPagedResultDtoOfGetGLOptionForViewDto {
    totalCount!: number | undefined;
    items!: GetGLOptionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGLOptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGLOptionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGLOptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGLOptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGLOptionForViewDto {
    totalCount: number | undefined;
    items: GetGLOptionForViewDto[] | undefined;
}

export class GetGLOptionForViewDto implements IGetGLOptionForViewDto {
    glOption!: GLOptionDto | undefined;
    chartofControlId!: string | undefined;

    constructor(data?: IGetGLOptionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glOption = data["glOption"] ? GLOptionDto.fromJS(data["glOption"]) : <any>undefined;
            this.chartofControlId = data["chartofControlId"];
        }
    }

    static fromJS(data: any): GetGLOptionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLOptionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glOption"] = this.glOption ? this.glOption.toJSON() : <any>undefined;
        data["chartofControlId"] = this.chartofControlId;
        return data;
    }
}

export interface IGetGLOptionForViewDto {
    glOption: GLOptionDto | undefined;
    chartofControlId: string | undefined;
}

export class GLOptionDto implements IGLOptionDto {
    defaultclacc!: string | undefined;
    stockctrlacc!: string | undefined;
    transferacc!: string | undefined;
    seg1Name!: string | undefined;
    seg2Name!: string | undefined;
    seg3Name!: string | undefined;
    firstSignature!: string | undefined;
    secondSignature!: string | undefined;
    thirdSignature!: string | undefined;
    fourthSignature!: string | undefined;
    fifthSignature!: string | undefined;
    sixthSignature!: string | undefined;
    directPost!: boolean | undefined;
    autoSeg3!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: IGLOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {

            this.defaultclacc = data["defaultclacc"];
            this.stockctrlacc = data["stockctrlacc"];
            this.seg1Name = data["seg1Name"];
            this.seg2Name = data["seg2Name"];
            this.seg3Name = data["seg3Name"];
            this.firstSignature = data["firstSignature"];
            this.secondSignature = data["secondSignature"];
            this.thirdSignature = data["thirdSignature"];
            this.fourthSignature = data["fourthSignature"];
            this.fifthSignature = data["fifthSignature"];
            this.sixthSignature = data["sixthSignature"];
            this.directPost = data["directPost"];
            this.autoSeg3 = data["autoSeg3"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GLOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultclacc"] = this.defaultclacc;
        data["stockctrlacc"] = this.stockctrlacc;
        data["seg1Name"] = this.seg1Name;
        data["seg2Name"] = this.seg2Name;
        data["seg3Name"] = this.seg3Name;
        data["firstSignature"] = this.firstSignature;
        data["secondSignature"] = this.secondSignature;
        data["thirdSignature"] = this.thirdSignature;
        data["fourthSignature"] = this.fourthSignature;
        data["fifthSignature"] = this.fifthSignature;
        data["sixthSignature"] = this.sixthSignature;
        data["directPost"] = this.directPost;
        data["autoSeg3"] = this.autoSeg3;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;

        return data;
    }
}

export interface IGLOptionDto {
    defaultclacc: string | undefined;
    stockctrlacc: string | undefined;
    seg1Name: string | undefined;
    seg2Name: string | undefined;
    seg3Name: string | undefined;
    firstSignature: string | undefined;
    secondSignature: string | undefined;
    thirdSignature: string | undefined;
    fourthSignature: string | undefined;
    fifthSignature: string | undefined;
    sixthSignature: string | undefined;
    directPost: boolean | undefined;
    autoSeg3: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfGlOption implements IListResultDtoOfGlOptionDto {
    items!: GLOptionDto[] | undefined;

    constructor(data?: IListResultDtoOfGlOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        debugger;
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGlOption {
        data = typeof data === 'object' ? data : {};
        debugger;
        let result = new ListResultDtoOfGlOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGlOptionDto {
    items: GLOptionDto[] | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [] as any;
                for (let item of data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindIcSegment1Input implements IFindIcSegment1Input {
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindIcSegment1Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindIcSegment1Input {
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class CommonReportData implements ICommonReportData {
    companyName!: string | undefined;
    tenantId!: number | undefined;
    sign1!: string | undefined;
    sign2!: string | undefined;
    sign3!: string | undefined;
    sign4!: string | undefined;
    sign5!: string | undefined;

    constructor(data?: ICommonReportData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.tenantId = data["tenantId"];
            this.sign1 = data["sign1"];
            this.sign2 = data["sign2"];
            this.sign3 = data["sign3"];
            this.sign4 = data["sign4"];
            this.sign5 = data["sign5"];
        }
    }

    static fromJS(data: any): CommonReportData {
        data = typeof data === 'object' ? data : {};
        let result = new CommonReportData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["tenantId"] = this.tenantId;
        data["sign1"] = this.sign1;
        data["sign2"] = this.sign2;
        data["sign3"] = this.sign3;
        data["sign4"] = this.sign4;
        data["sign5"] = this.sign5;
        return data;
    }
}

export interface ICommonReportData {
    companyName: string | undefined;
    tenantId: number | undefined;
    sign1: string | undefined;
    sign2: string | undefined;
    sign3: string | undefined;
    sign4: string | undefined;
    sign5: string | undefined;
}

export class PagedResultDtoOfGetCompanyProfileForViewDto implements IPagedResultDtoOfGetCompanyProfileForViewDto {
    totalCount!: number | undefined;
    items!: GetCompanyProfileForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCompanyProfileForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCompanyProfileForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCompanyProfileForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCompanyProfileForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCompanyProfileForViewDto {
    totalCount: number | undefined;
    items: GetCompanyProfileForViewDto[] | undefined;
}

export class GetCompanyProfileForViewDto implements IGetCompanyProfileForViewDto {
    companyProfile!: CompanyProfileDto | undefined;

    constructor(data?: IGetCompanyProfileForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyProfile = data["companyProfile"] ? CompanyProfileDto.fromJS(data["companyProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCompanyProfileForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyProfileForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyProfile"] = this.companyProfile ? this.companyProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCompanyProfileForViewDto {
    companyProfile: CompanyProfileDto | undefined;
}

export class CompanyProfileDto implements ICompanyProfileDto {
    companyName!: string | undefined;
    serverUrl!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    legalName!: string | undefined;
    country!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    zipCode!: string | undefined;
    email!: string | undefined;
    slRegNo!: string | undefined;
    contperson!: string | undefined;
    designation!: string | undefined;
    contphone!: string | undefined;
    contemail!: string | undefined;
    contpersoN1!: string | undefined;
    designatioN1!: string | undefined;
    contphonE1!: string | undefined;
    contemaiL1!: string | undefined;
    url!: string | undefined;
    directPost!: boolean | undefined;
    id!: string | undefined;
    itemPriceID!:string|undefined;
    constructor(data?: ICompanyProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverUrl = data["serverUrl"]
            this.companyName = data["companyName"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.legalName = data["legalName"];
            this.country = data["country"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
            this.email = data["email"];
            this.slRegNo = data["slRegNo"];
            this.contperson = data["contperson"];
            this.designation = data["designation"];
            this.contphone = data["contphone"];
            this.contemail = data["contemail"];
            this.contpersoN1 = data["contpersoN1"];
            this.designatioN1 = data["designatioN1"];
            this.contphonE1 = data["contphonE1"];
            this.contemaiL1 = data["contemaiL1"];
            this.url = data["url"];
            this.directPost = data["directPost"];
            this.id = data["id"];
            this.itemPriceID=data["itemPriceID"];
        }
    }

    static fromJS(data: any): CompanyProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverUrl"] = this.serverUrl;
        data["companyName"] = this.companyName;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["legalName"] = this.legalName;
        data["country"] = this.country;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["email"] = this.email;
        data["slRegNo"] = this.slRegNo;
        data["contperson"] = this.contperson;
        data["designation"] = this.designation;
        data["contphone"] = this.contphone;
        data["contemail"] = this.contemail;
        data["contpersoN1"] = this.contpersoN1;
        data["designatioN1"] = this.designatioN1;
        data["contphonE1"] = this.contphonE1;
        data["contemaiL1"] = this.contemaiL1;
        data["url"] = this.url;
        data["directPost"] = this.directPost;
        data["id"] = this.id;
        data["itemPriceID"]=this.itemPriceID;
        return data;
    }
}

export interface ICompanyProfileDto {
    companyName: string | undefined;
    serverUrl: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    legalName: string | undefined;
    country: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    email: string | undefined;
    slRegNo: string | undefined;
    contperson: string | undefined;
    designation: string | undefined;
    contphone: string | undefined;
    contemail: string | undefined;
    contpersoN1: string | undefined;
    designatioN1: string | undefined;
    contphonE1: string | undefined;
    contemaiL1: string | undefined;
    url: string | undefined;
    directPost: boolean | undefined;
    id: string | undefined;
    itemPriceID:string | undefined;
}

export class GetCompanyProfileForEditOutput implements IGetCompanyProfileForEditOutput {
    companyProfile!: CreateOrEditCompanyProfileDto | undefined;

    constructor(data?: IGetCompanyProfileForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyProfile = data["companyProfile"] ? CreateOrEditCompanyProfileDto.fromJS(data["companyProfile"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCompanyProfileForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCompanyProfileForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyProfile"] = this.companyProfile ? this.companyProfile.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCompanyProfileForEditOutput {
    companyProfile: CreateOrEditCompanyProfileDto | undefined;
}

export class CreateOrEditCompanyProfileDto implements ICreateOrEditCompanyProfileDto {
    companyName!: string;
    serverUrl!: string | undefined;
    address1!: string | undefined;
    address2!: string | undefined;
    legalName!: string | undefined;
    country!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    zipCode!: string | undefined;
    email!: string | undefined;
    slRegNo!: string | undefined;
    contperson!: string | undefined;
    designation!: string | undefined;
    contphone!: string | undefined;
    contemail!: string | undefined;
    contpersoN1!: string | undefined;
    designatioN1!: string | undefined;
    contphonE1!: string | undefined;
    contemaiL1!: string | undefined;
    url!: string | undefined;
    id!: string | undefined;
    itemPriceID!:string | undefined;
    constructor(data?: ICreateOrEditCompanyProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyName = data["companyName"];
            this.serverUrl = data["serverUrl"];
            this.address1 = data["address1"];
            this.address2 = data["address2"];
            this.legalName = data["legalName"];
            this.country = data["country"];
            this.phone = data["phone"];
            this.fax = data["fax"];
            this.city = data["city"];
            this.state = data["state"];
            this.zipCode = data["zipCode"];
            this.email = data["email"];
            this.slRegNo = data["slRegNo"];
            this.contperson = data["contperson"];
            this.designation = data["designation"];
            this.contphone = data["contphone"];
            this.contemail = data["contemail"];
            this.contpersoN1 = data["contpersoN1"];
            this.designatioN1 = data["designatioN1"];
            this.contphonE1 = data["contphonE1"];
            this.contemaiL1 = data["contemaiL1"];
            this.url = data["url"];
            this.id = data["id"];
            this.itemPriceID=data["itemPriceID"];
        }
    }

    static fromJS(data: any): CreateOrEditCompanyProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCompanyProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["serverUrl"] = this.serverUrl;
        data["address1"] = this.address1;
        data["address2"] = this.address2;
        data["legalName"] = this.legalName;
        data["country"] = this.country;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["email"] = this.email;
        data["slRegNo"] = this.slRegNo;
        data["contperson"] = this.contperson;
        data["designation"] = this.designation;
        data["contphone"] = this.contphone;
        data["contemail"] = this.contemail;
        data["contpersoN1"] = this.contpersoN1;
        data["designatioN1"] = this.designatioN1;
        data["contphonE1"] = this.contphonE1;
        data["contemaiL1"] = this.contemaiL1;
        data["url"] = this.url;
        data["id"] = this.id;
        data["itemPriceID"]=this.itemPriceID;
        return data;
    }
}

export interface ICreateOrEditCompanyProfileDto {
    companyName: string;
    serverUrl: string | undefined;
    address1: string | undefined;
    address2: string | undefined;
    legalName: string | undefined;
    country: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    city: string | undefined;
    state: string | undefined;
    zipCode: string | undefined;
    email: string | undefined;
    slRegNo: string | undefined;
    contperson: string | undefined;
    designation: string | undefined;
    contphone: string | undefined;
    contemail: string | undefined;
    contpersoN1: string | undefined;
    designatioN1: string | undefined;
    contphonE1: string | undefined;
    contemaiL1: string | undefined;
    url: string | undefined;
    id: string | undefined;
    itemPriceID:string | undefined;
}

export class PagedResultDtoOfGetControlDetailForViewDto implements IPagedResultDtoOfGetControlDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetControlDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetControlDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetControlDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetControlDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetControlDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetControlDetailForViewDto {
    totalCount: number | undefined;
    items: GetControlDetailForViewDto[] | undefined;
}

export class GetControlDetailForViewDto implements IGetControlDetailForViewDto {
    controlDetail!: ControlDetailDto | undefined;
    familyDesc!: string | undefined;

    constructor(data?: IGetControlDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.controlDetail = data["controlDetail"] ? ControlDetailDto.fromJS(data["controlDetail"]) : <any>undefined;
            this.familyDesc = data["familyDesc"];
        }
    }

    static fromJS(data: any): GetControlDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetControlDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controlDetail"] = this.controlDetail ? this.controlDetail.toJSON() : <any>undefined;
        data["familyDesc"] = this.familyDesc;
        return data;
    }
}

export interface IGetControlDetailForViewDto {
    controlDetail: ControlDetailDto | undefined;
    familyDesc: string | undefined;
}

export class ControlDetailDto implements IControlDetailDto {
    seg1ID!: string | undefined;
    segmentName!: string | undefined;
    family!: number | undefined;
    oldCode!: string | undefined;
    id!: number | undefined;

    constructor(data?: IControlDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg1ID = data["seg1ID"];
            this.segmentName = data["segmentName"];
            this.family = data["family"];
            this.oldCode = data["oldCode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ControlDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ControlDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg1ID"] = this.seg1ID;
        data["segmentName"] = this.segmentName;
        data["family"] = this.family;
        data["oldCode"] = this.oldCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IControlDetailDto {
    seg1ID: string | undefined;
    segmentName: string | undefined;
    family: number | undefined;
    oldCode: string | undefined;
    id: number | undefined;
}

export class GetControlDetailForEditOutput implements IGetControlDetailForEditOutput {
    controlDetail!: CreateOrEditControlDetailDto | undefined;
    family!: number | undefined;

    constructor(data?: IGetControlDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.controlDetail = data["controlDetail"] ? CreateOrEditControlDetailDto.fromJS(data["controlDetail"]) : <any>undefined;
            this.family = data["family"];
        }
    }

    static fromJS(data: any): GetControlDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetControlDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controlDetail"] = this.controlDetail ? this.controlDetail.toJSON() : <any>undefined;
        data["family"] = this.family;
        return data;
    }
}

export interface IGetControlDetailForEditOutput {
    controlDetail: CreateOrEditControlDetailDto | undefined;
    family: number | undefined;
}

export class CreateOrEditControlDetailDto implements ICreateOrEditControlDetailDto {
    seg1ID!: string | undefined;
    segmentName!: string;
    family!: number;
    oldCode!: string | undefined;
    flag!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditControlDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg1ID = data["seg1ID"];
            this.segmentName = data["segmentName"];
            this.family = data["family"];
            this.oldCode = data["oldCode"];
            this.flag = data["flag"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditControlDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditControlDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg1ID"] = this.seg1ID;
        data["segmentName"] = this.segmentName;
        data["family"] = this.family;
        data["oldCode"] = this.oldCode;
        data["flag"] = this.flag;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditControlDetailDto {
    seg1ID: string | undefined;
    segmentName: string;
    family: number;
    oldCode: string | undefined;
    flag: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetCurrencyRateForViewDto implements IPagedResultDtoOfGetCurrencyRateForViewDto {
    totalCount!: number | undefined;
    items!: GetCurrencyRateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCurrencyRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCurrencyRateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCurrencyRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCurrencyRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCurrencyRateForViewDto {
    totalCount: number | undefined;
    items: GetCurrencyRateForViewDto[] | undefined;
}

export class GetCurrencyRateForViewDto implements IGetCurrencyRateForViewDto {
    currencyRate!: CurrencyRateDto | undefined;
    companyProfileCompanyName!: string | undefined;

    constructor(data?: IGetCurrencyRateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currencyRate = data["currencyRate"] ? CurrencyRateDto.fromJS(data["currencyRate"]) : <any>undefined;
            this.companyProfileCompanyName = data["companyProfileCompanyName"];
        }
    }

    static fromJS(data: any): GetCurrencyRateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyRateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyRate"] = this.currencyRate ? this.currencyRate.toJSON() : <any>undefined;
        data["companyProfileCompanyName"] = this.companyProfileCompanyName;
        return data;
    }
}

export interface IGetCurrencyRateForViewDto {
    currencyRate: CurrencyRateDto | undefined;
    companyProfileCompanyName: string | undefined;
}

export class CurrencyRateDto implements ICurrencyRateDto {
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    curname!: string | undefined;
    symbol!: string | undefined;
    ratedate!: moment.Moment | undefined;
    currate!: number | undefined;
    cmpid!: string | undefined;
    id!: string | undefined;
    narration:string | undefined;
    unit:string | undefined;


    constructor(data?: ICurrencyRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.curname = data["curname"];
            this.symbol = data["symbol"];
            this.ratedate = data["ratedate"] ? moment(data["ratedate"].toString()) : <any>undefined;
            this.currate = data["currate"];
            this.cmpid = data["cmpid"];
            this.narration=data["narration"];
            this.unit=data["unit"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CurrencyRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["curname"] = this.curname;
        data["symbol"] = this.symbol;
        data["ratedate"] = this.ratedate ? this.ratedate.toISOString() : <any>undefined;
        data["currate"] = this.currate;
        data["cmpid"] = this.cmpid;
        data["narration"]= this.narration;
        data["unit"]=this.unit;
        data["id"] = this.id;
        return data;
    }
}

export interface ICurrencyRateDto {
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    curname: string | undefined;
    symbol: string | undefined;
    ratedate: moment.Moment | undefined;
    currate: number | undefined;
    cmpid: string | undefined;
    id: string | undefined;
    narration:string | undefined;
    unit:string | undefined;

}

export class GetCurrencyRateForEditOutput implements IGetCurrencyRateForEditOutput {
    currencyRate!: CreateOrEditCurrencyRateDto | undefined;
    companyProfileCompanyName!: string | undefined;
    currencyHistory!:CurrencyRateHistoryDto[] | undefined;

    constructor(data?: IGetCurrencyRateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currencyRate = data["currencyRate"] ? CreateOrEditCurrencyRateDto.fromJS(data["currencyRate"]) : <any>undefined;
            this.companyProfileCompanyName = data["companyProfileCompanyName"];
            this.currencyHistory = data["currencyHistory"];
        }
    }

    static fromJS(data: any): GetCurrencyRateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyRateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyRate"] = this.currencyRate ? this.currencyRate.toJSON() : <any>undefined;
        data["companyProfileCompanyName"] = this.companyProfileCompanyName;
        data["currencyHistory"]=this.currencyHistory
        return data;
    }
}

export interface IGetCurrencyRateForEditOutput {
    currencyRate: CreateOrEditCurrencyRateDto | undefined;
    companyProfileCompanyName: string | undefined;
    currencyHistory:CurrencyRateHistoryDto[] | undefined;
}

export class CreateOrEditCurrencyRateDto implements ICreateOrEditCurrencyRateDto {
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    curname!: string;
    symbol!: string | undefined;
    ratedate!: moment.Moment | undefined;
    currate!: number | undefined;
    decimal!: number | undefined;
    id!: string | undefined;
    narration:string | undefined;
    unit:string | undefined;

    constructor(data?: ICreateOrEditCurrencyRateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.curname = data["curname"];
            this.symbol = data["symbol"];
            this.ratedate = data["ratedate"] ? moment(data["ratedate"].toString()) : <any>undefined;
            this.currate = data["currate"];
            this.decimal = data["decimal"];
            this.narration=data["narration"];
this.unit=data["unit"];
            this.id = data["id"];

        }
    }

    static fromJS(data: any): CreateOrEditCurrencyRateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCurrencyRateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["curname"] = this.curname;
        data["symbol"] = this.symbol;
        data["ratedate"] = this.ratedate ? this.ratedate.toISOString() : <any>undefined;
        data["currate"] = this.currate;
        data["decimal"] = this.decimal;
        data["narration"]= this.narration;
        data["unit"]=this.unit;
        data["id"] = this.id;
        return data;
    }
}



export interface ICreateOrEditCurrencyRateDto {
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    curname: string;
    symbol: string | undefined;
    ratedate: moment.Moment | undefined;
    currate: number | undefined;
    decimal: number | undefined;
narration:string | undefined;
unit:string | undefined;
    id: string | undefined;
}


export class PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto implements IPagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto {
    totalCount!: number | undefined;
    items!: CurrencyRateCompanyProfileLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CurrencyRateCompanyProfileLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfCurrencyRateCompanyProfileLookupTableDto {
    totalCount: number | undefined;
    items: CurrencyRateCompanyProfileLookupTableDto[] | undefined;
}

export class CurrencyRateCompanyProfileLookupTableDto implements ICurrencyRateCompanyProfileLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ICurrencyRateCompanyProfileLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CurrencyRateCompanyProfileLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyRateCompanyProfileLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICurrencyRateCompanyProfileLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data;
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number | undefined;
    targetEditionId!: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class PagedResultDtoOfGetFiscalCalendarForViewDto implements IPagedResultDtoOfGetFiscalCalendarForViewDto {
    totalCount!: number | undefined;
    items!: GetFiscalCalendarForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetFiscalCalendarForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetFiscalCalendarForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetFiscalCalendarForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetFiscalCalendarForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetFiscalCalendarForViewDto {
    totalCount: number | undefined;
    items: GetFiscalCalendarForViewDto[] | undefined;
}

export class GetFiscalCalendarForViewDto implements IGetFiscalCalendarForViewDto {
    fiscalCalendar!: FiscalCalendarDto | undefined;

    constructor(data?: IGetFiscalCalendarForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fiscalCalendar = data["fiscalCalendar"] ? FiscalCalendarDto.fromJS(data["fiscalCalendar"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFiscalCalendarForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFiscalCalendarForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fiscalCalendar"] = this.fiscalCalendar ? this.fiscalCalendar.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetFiscalCalendarForViewDto {
    fiscalCalendar: FiscalCalendarDto | undefined;
}

export class FiscalCalendarDto implements IFiscalCalendarDto {
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    periods!: number | undefined;
    qtR4PERD!: number | undefined;
    active!: number | undefined;
    bgndatE1!: moment.Moment | undefined;
    bgndatE2!: moment.Moment | undefined;
    bgndatE3!: moment.Moment | undefined;
    bgndatE4!: moment.Moment | undefined;
    bgndatE5!: moment.Moment | undefined;
    bgndatE6!: moment.Moment | undefined;
    bgndatE7!: moment.Moment | undefined;
    bgndatE8!: moment.Moment | undefined;
    bgndatE9!: moment.Moment | undefined;
    bgndatE10!: moment.Moment | undefined;
    bgndatE11!: moment.Moment | undefined;
    bgndatE12!: moment.Moment | undefined;
    bgndatE13!: moment.Moment | undefined;
    enddatE1!: moment.Moment | undefined;
    enddatE2!: moment.Moment | undefined;
    enddatE3!: moment.Moment | undefined;
    enddatE4!: moment.Moment | undefined;
    enddatE5!: moment.Moment | undefined;
    enddatE6!: moment.Moment | undefined;
    enddatE7!: moment.Moment | undefined;
    enddatE8!: moment.Moment | undefined;
    enddatE9!: moment.Moment | undefined;
    enddatE10!: moment.Moment | undefined;
    enddatE11!: moment.Moment | undefined;
    enddatE12!: moment.Moment | undefined;
    enddatE13!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IFiscalCalendarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.periods = data["periods"];
            this.qtR4PERD = data["qtR4PERD"];
            this.active = data["active"];
            this.bgndatE1 = data["bgndatE1"] ? moment(data["bgndatE1"].toString()) : <any>undefined;
            this.bgndatE2 = data["bgndatE2"] ? moment(data["bgndatE2"].toString()) : <any>undefined;
            this.bgndatE3 = data["bgndatE3"] ? moment(data["bgndatE3"].toString()) : <any>undefined;
            this.bgndatE4 = data["bgndatE4"] ? moment(data["bgndatE4"].toString()) : <any>undefined;
            this.bgndatE5 = data["bgndatE5"] ? moment(data["bgndatE5"].toString()) : <any>undefined;
            this.bgndatE6 = data["bgndatE6"] ? moment(data["bgndatE6"].toString()) : <any>undefined;
            this.bgndatE7 = data["bgndatE7"] ? moment(data["bgndatE7"].toString()) : <any>undefined;
            this.bgndatE8 = data["bgndatE8"] ? moment(data["bgndatE8"].toString()) : <any>undefined;
            this.bgndatE9 = data["bgndatE9"] ? moment(data["bgndatE9"].toString()) : <any>undefined;
            this.bgndatE10 = data["bgndatE10"] ? moment(data["bgndatE10"].toString()) : <any>undefined;
            this.bgndatE11 = data["bgndatE11"] ? moment(data["bgndatE11"].toString()) : <any>undefined;
            this.bgndatE12 = data["bgndatE12"] ? moment(data["bgndatE12"].toString()) : <any>undefined;
            this.bgndatE13 = data["bgndatE13"] ? moment(data["bgndatE13"].toString()) : <any>undefined;
            this.enddatE1 = data["enddatE1"] ? moment(data["enddatE1"].toString()) : <any>undefined;
            this.enddatE2 = data["enddatE2"] ? moment(data["enddatE2"].toString()) : <any>undefined;
            this.enddatE3 = data["enddatE3"] ? moment(data["enddatE3"].toString()) : <any>undefined;
            this.enddatE4 = data["enddatE4"] ? moment(data["enddatE4"].toString()) : <any>undefined;
            this.enddatE5 = data["enddatE5"] ? moment(data["enddatE5"].toString()) : <any>undefined;
            this.enddatE6 = data["enddatE6"] ? moment(data["enddatE6"].toString()) : <any>undefined;
            this.enddatE7 = data["enddatE7"] ? moment(data["enddatE7"].toString()) : <any>undefined;
            this.enddatE8 = data["enddatE8"] ? moment(data["enddatE8"].toString()) : <any>undefined;
            this.enddatE9 = data["enddatE9"] ? moment(data["enddatE9"].toString()) : <any>undefined;
            this.enddatE10 = data["enddatE10"] ? moment(data["enddatE10"].toString()) : <any>undefined;
            this.enddatE11 = data["enddatE11"] ? moment(data["enddatE11"].toString()) : <any>undefined;
            this.enddatE12 = data["enddatE12"] ? moment(data["enddatE12"].toString()) : <any>undefined;
            this.enddatE13 = data["enddatE13"] ? moment(data["enddatE13"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FiscalCalendarDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiscalCalendarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["periods"] = this.periods;
        data["qtR4PERD"] = this.qtR4PERD;
        data["active"] = this.active;
        data["bgndatE1"] = this.bgndatE1 ? this.bgndatE1.toISOString() : <any>undefined;
        data["bgndatE2"] = this.bgndatE2 ? this.bgndatE2.toISOString() : <any>undefined;
        data["bgndatE3"] = this.bgndatE3 ? this.bgndatE3.toISOString() : <any>undefined;
        data["bgndatE4"] = this.bgndatE4 ? this.bgndatE4.toISOString() : <any>undefined;
        data["bgndatE5"] = this.bgndatE5 ? this.bgndatE5.toISOString() : <any>undefined;
        data["bgndatE6"] = this.bgndatE6 ? this.bgndatE6.toISOString() : <any>undefined;
        data["bgndatE7"] = this.bgndatE7 ? this.bgndatE7.toISOString() : <any>undefined;
        data["bgndatE8"] = this.bgndatE8 ? this.bgndatE8.toISOString() : <any>undefined;
        data["bgndatE9"] = this.bgndatE9 ? this.bgndatE9.toISOString() : <any>undefined;
        data["bgndatE10"] = this.bgndatE10 ? this.bgndatE10.toISOString() : <any>undefined;
        data["bgndatE11"] = this.bgndatE11 ? this.bgndatE11.toISOString() : <any>undefined;
        data["bgndatE12"] = this.bgndatE12 ? this.bgndatE12.toISOString() : <any>undefined;
        data["bgndatE13"] = this.bgndatE13 ? this.bgndatE13.toISOString() : <any>undefined;
        data["enddatE1"] = this.enddatE1 ? this.enddatE1.toISOString() : <any>undefined;
        data["enddatE2"] = this.enddatE2 ? this.enddatE2.toISOString() : <any>undefined;
        data["enddatE3"] = this.enddatE3 ? this.enddatE3.toISOString() : <any>undefined;
        data["enddatE4"] = this.enddatE4 ? this.enddatE4.toISOString() : <any>undefined;
        data["enddatE5"] = this.enddatE5 ? this.enddatE5.toISOString() : <any>undefined;
        data["enddatE6"] = this.enddatE6 ? this.enddatE6.toISOString() : <any>undefined;
        data["enddatE7"] = this.enddatE7 ? this.enddatE7.toISOString() : <any>undefined;
        data["enddatE8"] = this.enddatE8 ? this.enddatE8.toISOString() : <any>undefined;
        data["enddatE9"] = this.enddatE9 ? this.enddatE9.toISOString() : <any>undefined;
        data["enddatE10"] = this.enddatE10 ? this.enddatE10.toISOString() : <any>undefined;
        data["enddatE11"] = this.enddatE11 ? this.enddatE11.toISOString() : <any>undefined;
        data["enddatE12"] = this.enddatE12 ? this.enddatE12.toISOString() : <any>undefined;
        data["enddatE13"] = this.enddatE13 ? this.enddatE13.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IFiscalCalendarDto {
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    periods: number | undefined;
    qtR4PERD: number | undefined;
    active: number | undefined;
    bgndatE1: moment.Moment | undefined;
    bgndatE2: moment.Moment | undefined;
    bgndatE3: moment.Moment | undefined;
    bgndatE4: moment.Moment | undefined;
    bgndatE5: moment.Moment | undefined;
    bgndatE6: moment.Moment | undefined;
    bgndatE7: moment.Moment | undefined;
    bgndatE8: moment.Moment | undefined;
    bgndatE9: moment.Moment | undefined;
    bgndatE10: moment.Moment | undefined;
    bgndatE11: moment.Moment | undefined;
    bgndatE12: moment.Moment | undefined;
    bgndatE13: moment.Moment | undefined;
    enddatE1: moment.Moment | undefined;
    enddatE2: moment.Moment | undefined;
    enddatE3: moment.Moment | undefined;
    enddatE4: moment.Moment | undefined;
    enddatE5: moment.Moment | undefined;
    enddatE6: moment.Moment | undefined;
    enddatE7: moment.Moment | undefined;
    enddatE8: moment.Moment | undefined;
    enddatE9: moment.Moment | undefined;
    enddatE10: moment.Moment | undefined;
    enddatE11: moment.Moment | undefined;
    enddatE12: moment.Moment | undefined;
    enddatE13: moment.Moment | undefined;
    id: number | undefined;
}

export class GetFiscalCalendarForEditOutput implements IGetFiscalCalendarForEditOutput {
    fiscalCalendar!: CreateOrEditFiscalCalendarDto | undefined;

    constructor(data?: IGetFiscalCalendarForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fiscalCalendar = data["fiscalCalendar"] ? CreateOrEditFiscalCalendarDto.fromJS(data["fiscalCalendar"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFiscalCalendarForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFiscalCalendarForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fiscalCalendar"] = this.fiscalCalendar ? this.fiscalCalendar.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetFiscalCalendarForEditOutput {
    fiscalCalendar: CreateOrEditFiscalCalendarDto | undefined;
}

export class CreateOrEditFiscalCalendarDto implements ICreateOrEditFiscalCalendarDto {
    audtdate!: moment.Moment;
    audtuser!: string | undefined;
    periods!: number;
    qtR4PERD!: number;
    active!: number;
    bgndatE1!: moment.Moment;
    bgndatE2!: moment.Moment;
    bgndatE3!: moment.Moment;
    bgndatE4!: moment.Moment;
    bgndatE5!: moment.Moment;
    bgndatE6!: moment.Moment;
    bgndatE7!: moment.Moment;
    bgndatE8!: moment.Moment;
    bgndatE9!: moment.Moment;
    bgndatE10!: moment.Moment;
    bgndatE11!: moment.Moment;
    bgndatE12!: moment.Moment;
    bgndatE13!: moment.Moment;
    enddatE1!: moment.Moment;
    enddatE2!: moment.Moment;
    enddatE3!: moment.Moment;
    enddatE4!: moment.Moment;
    enddatE5!: moment.Moment;
    enddatE6!: moment.Moment;
    enddatE7!: moment.Moment;
    enddatE8!: moment.Moment;
    enddatE9!: moment.Moment;
    enddatE10!: moment.Moment;
    enddatE11!: moment.Moment;
    enddatE12!: moment.Moment;
    enddatE13!: moment.Moment;
    id!: number | undefined;

    constructor(data?: ICreateOrEditFiscalCalendarDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.periods = data["periods"];
            this.qtR4PERD = data["qtR4PERD"];
            this.active = data["active"];
            this.bgndatE1 = data["bgndatE1"] ? moment(data["bgndatE1"].toString()) : <any>undefined;
            this.bgndatE2 = data["bgndatE2"] ? moment(data["bgndatE2"].toString()) : <any>undefined;
            this.bgndatE3 = data["bgndatE3"] ? moment(data["bgndatE3"].toString()) : <any>undefined;
            this.bgndatE4 = data["bgndatE4"] ? moment(data["bgndatE4"].toString()) : <any>undefined;
            this.bgndatE5 = data["bgndatE5"] ? moment(data["bgndatE5"].toString()) : <any>undefined;
            this.bgndatE6 = data["bgndatE6"] ? moment(data["bgndatE6"].toString()) : <any>undefined;
            this.bgndatE7 = data["bgndatE7"] ? moment(data["bgndatE7"].toString()) : <any>undefined;
            this.bgndatE8 = data["bgndatE8"] ? moment(data["bgndatE8"].toString()) : <any>undefined;
            this.bgndatE9 = data["bgndatE9"] ? moment(data["bgndatE9"].toString()) : <any>undefined;
            this.bgndatE10 = data["bgndatE10"] ? moment(data["bgndatE10"].toString()) : <any>undefined;
            this.bgndatE11 = data["bgndatE11"] ? moment(data["bgndatE11"].toString()) : <any>undefined;
            this.bgndatE12 = data["bgndatE12"] ? moment(data["bgndatE12"].toString()) : <any>undefined;
            this.bgndatE13 = data["bgndatE13"] ? moment(data["bgndatE13"].toString()) : <any>undefined;
            this.enddatE1 = data["enddatE1"] ? moment(data["enddatE1"].toString()) : <any>undefined;
            this.enddatE2 = data["enddatE2"] ? moment(data["enddatE2"].toString()) : <any>undefined;
            this.enddatE3 = data["enddatE3"] ? moment(data["enddatE3"].toString()) : <any>undefined;
            this.enddatE4 = data["enddatE4"] ? moment(data["enddatE4"].toString()) : <any>undefined;
            this.enddatE5 = data["enddatE5"] ? moment(data["enddatE5"].toString()) : <any>undefined;
            this.enddatE6 = data["enddatE6"] ? moment(data["enddatE6"].toString()) : <any>undefined;
            this.enddatE7 = data["enddatE7"] ? moment(data["enddatE7"].toString()) : <any>undefined;
            this.enddatE8 = data["enddatE8"] ? moment(data["enddatE8"].toString()) : <any>undefined;
            this.enddatE9 = data["enddatE9"] ? moment(data["enddatE9"].toString()) : <any>undefined;
            this.enddatE10 = data["enddatE10"] ? moment(data["enddatE10"].toString()) : <any>undefined;
            this.enddatE11 = data["enddatE11"] ? moment(data["enddatE11"].toString()) : <any>undefined;
            this.enddatE12 = data["enddatE12"] ? moment(data["enddatE12"].toString()) : <any>undefined;
            this.enddatE13 = data["enddatE13"] ? moment(data["enddatE13"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditFiscalCalendarDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditFiscalCalendarDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["periods"] = this.periods;
        data["qtR4PERD"] = this.qtR4PERD;
        data["active"] = this.active;
        data["bgndatE1"] = this.bgndatE1 ? this.bgndatE1.toISOString() : <any>undefined;
        data["bgndatE2"] = this.bgndatE2 ? this.bgndatE2.toISOString() : <any>undefined;
        data["bgndatE3"] = this.bgndatE3 ? this.bgndatE3.toISOString() : <any>undefined;
        data["bgndatE4"] = this.bgndatE4 ? this.bgndatE4.toISOString() : <any>undefined;
        data["bgndatE5"] = this.bgndatE5 ? this.bgndatE5.toISOString() : <any>undefined;
        data["bgndatE6"] = this.bgndatE6 ? this.bgndatE6.toISOString() : <any>undefined;
        data["bgndatE7"] = this.bgndatE7 ? this.bgndatE7.toISOString() : <any>undefined;
        data["bgndatE8"] = this.bgndatE8 ? this.bgndatE8.toISOString() : <any>undefined;
        data["bgndatE9"] = this.bgndatE9 ? this.bgndatE9.toISOString() : <any>undefined;
        data["bgndatE10"] = this.bgndatE10 ? this.bgndatE10.toISOString() : <any>undefined;
        data["bgndatE11"] = this.bgndatE11 ? this.bgndatE11.toISOString() : <any>undefined;
        data["bgndatE12"] = this.bgndatE12 ? this.bgndatE12.toISOString() : <any>undefined;
        data["bgndatE13"] = this.bgndatE13 ? this.bgndatE13.toISOString() : <any>undefined;
        data["enddatE1"] = this.enddatE1 ? this.enddatE1.toISOString() : <any>undefined;
        data["enddatE2"] = this.enddatE2 ? this.enddatE2.toISOString() : <any>undefined;
        data["enddatE3"] = this.enddatE3 ? this.enddatE3.toISOString() : <any>undefined;
        data["enddatE4"] = this.enddatE4 ? this.enddatE4.toISOString() : <any>undefined;
        data["enddatE5"] = this.enddatE5 ? this.enddatE5.toISOString() : <any>undefined;
        data["enddatE6"] = this.enddatE6 ? this.enddatE6.toISOString() : <any>undefined;
        data["enddatE7"] = this.enddatE7 ? this.enddatE7.toISOString() : <any>undefined;
        data["enddatE8"] = this.enddatE8 ? this.enddatE8.toISOString() : <any>undefined;
        data["enddatE9"] = this.enddatE9 ? this.enddatE9.toISOString() : <any>undefined;
        data["enddatE10"] = this.enddatE10 ? this.enddatE10.toISOString() : <any>undefined;
        data["enddatE11"] = this.enddatE11 ? this.enddatE11.toISOString() : <any>undefined;
        data["enddatE12"] = this.enddatE12 ? this.enddatE12.toISOString() : <any>undefined;
        data["enddatE13"] = this.enddatE13 ? this.enddatE13.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditFiscalCalendarDto {
    audtdate: moment.Moment;
    audtuser: string | undefined;
    periods: number;
    qtR4PERD: number;
    active: number;
    bgndatE1: moment.Moment;
    bgndatE2: moment.Moment;
    bgndatE3: moment.Moment;
    bgndatE4: moment.Moment;
    bgndatE5: moment.Moment;
    bgndatE6: moment.Moment;
    bgndatE7: moment.Moment;
    bgndatE8: moment.Moment;
    bgndatE9: moment.Moment;
    bgndatE10: moment.Moment;
    bgndatE11: moment.Moment;
    bgndatE12: moment.Moment;
    bgndatE13: moment.Moment;
    enddatE1: moment.Moment;
    enddatE2: moment.Moment;
    enddatE3: moment.Moment;
    enddatE4: moment.Moment;
    enddatE5: moment.Moment;
    enddatE6: moment.Moment;
    enddatE7: moment.Moment;
    enddatE8: moment.Moment;
    enddatE9: moment.Moment;
    enddatE10: moment.Moment;
    enddatE11: moment.Moment;
    enddatE12: moment.Moment;
    enddatE13: moment.Moment;
    id: number | undefined;
}

export class PagedResultDtoOfGetFiscalCalenderForViewDto implements IPagedResultDtoOfGetFiscalCalenderForViewDto {
    totalCount!: number | undefined;
    items!: GetFiscalCalenderForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetFiscalCalenderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetFiscalCalenderForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetFiscalCalenderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetFiscalCalenderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetFiscalCalenderForViewDto {
    totalCount: number | undefined;
    items: GetFiscalCalenderForViewDto[] | undefined;
}

export class GetFiscalCalenderForViewDto implements IGetFiscalCalenderForViewDto {
    fiscalCalender!: FiscalCalenderDto | undefined;

    constructor(data?: IGetFiscalCalenderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fiscalCalender = data["fiscalCalender"] ? FiscalCalenderDto.fromJS(data["fiscalCalender"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFiscalCalenderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetFiscalCalenderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fiscalCalender"] = this.fiscalCalender ? this.fiscalCalender.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetFiscalCalenderForViewDto {
    fiscalCalender: FiscalCalenderDto | undefined;
}

export class FiscalCalenderDto implements IFiscalCalenderDto {
    period!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    gl!: boolean | undefined;
    ap!: boolean | undefined;
    ar!: boolean | undefined;
    in!: boolean | undefined;
    po!: boolean | undefined;
    oe!: boolean | undefined;
    bk!: boolean | undefined;
    hr!: boolean | undefined;
    pr!: boolean | undefined;
    createdBy!: number | undefined;
    createdDate!: moment.Moment | undefined;
    editDate!: moment.Moment | undefined;
    editUser!: number | undefined;
    isActive!: boolean | undefined;
    isLocked!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IFiscalCalenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.gl = data["gl"];
            this.ap = data["ap"];
            this.ar = data["ar"];
            this.in = data["in"];
            this.po = data["po"];
            this.oe = data["oe"];
            this.bk = data["bk"];
            this.hr = data["hr"];
            this.pr = data["pr"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.editDate = data["editDate"] ? moment(data["editDate"].toString()) : <any>undefined;
            this.editUser = data["editUser"];
            this.isActive = data["isActive"];
            this.isLocked = data["isLocked"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FiscalCalenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FiscalCalenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["gl"] = this.gl;
        data["ap"] = this.ap;
        data["ar"] = this.ar;
        data["in"] = this.in;
        data["po"] = this.po;
        data["oe"] = this.oe;
        data["bk"] = this.bk;
        data["hr"] = this.hr;
        data["pr"] = this.pr;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["editDate"] = this.editDate ? this.editDate.toISOString() : <any>undefined;
        data["editUser"] = this.editUser;
        data["isActive"] = this.isActive;
        data["isLocked"] = this.isLocked;
        data["id"] = this.id;
        return data;
    }
}

export interface IFiscalCalenderDto {
    period: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    gl: boolean | undefined;
    ap: boolean | undefined;
    ar: boolean | undefined;
    in: boolean | undefined;
    po: boolean | undefined;
    oe: boolean | undefined;
    bk: boolean | undefined;
    hr: boolean | undefined;
    pr: boolean | undefined;
    createdBy: number | undefined;
    createdDate: moment.Moment | undefined;
    editDate: moment.Moment | undefined;
    editUser: number | undefined;
    isActive: boolean | undefined;
    isLocked: boolean | undefined;
    id: number | undefined;
}

export class GetFiscalCalenderForEditOutput implements IGetFiscalCalenderForEditOutput {
    fiscalCalender!: CreateOrEditFiscalCalenderDto | undefined;

    constructor(data?: IGetFiscalCalenderForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fiscalCalender = data["fiscalCalender"] ? CreateOrEditFiscalCalenderDto.fromJS(data["fiscalCalender"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFiscalCalenderForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFiscalCalenderForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fiscalCalender"] = this.fiscalCalender ? this.fiscalCalender.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetFiscalCalenderForEditOutput {
    fiscalCalender: CreateOrEditFiscalCalenderDto | undefined;
}

export class CreateOrEditFiscalCalenderDto implements ICreateOrEditFiscalCalenderDto {
    period!: number;
    startDate!: moment.Moment;
    endDate!: moment.Moment;
    gl!: boolean;
    ap!: boolean;
    ar!: boolean;
    in!: boolean;
    po!: boolean;
    oe!: boolean;
    bk!: boolean;
    hr!: boolean;
    pr!: boolean;
    createdBy!: number | undefined;
    createdDate!: moment.Moment | undefined;
    editDate!: moment.Moment | undefined;
    editUser!: number | undefined;
    isActive!: boolean;
    isLocked!: boolean;
    id!: number | undefined;

    constructor(data?: ICreateOrEditFiscalCalenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            debugger;
            this.period = data["period"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.gl = data["gl"];
            this.ap = data["ap"];
            this.ar = data["ar"];
            this.in = data["in"];
            this.po = data["po"];
            this.oe = data["oe"];
            this.bk = data["bk"];
            this.hr = data["hr"];
            this.pr = data["pr"];
            this.createdBy = data["createdBy"];
            this.createdDate = data["createdDate"] ? moment(data["createdDate"].toString()) : <any>undefined;
            this.editDate = data["editDate"] ? moment(data["editDate"].toString()) : <any>undefined;
            this.editUser = data["editUser"];
            this.isActive = data["isActive"];
            this.isLocked = data["isLocked"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditFiscalCalenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditFiscalCalenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        debugger;
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["gl"] = this.gl;
        data["ap"] = this.ap;
        data["ar"] = this.ar;
        data["in"] = this.in;
        data["po"] = this.po;
        data["oe"] = this.oe;
        data["bk"] = this.bk;
        data["hr"] = this.hr;
        data["pr"] = this.pr;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["editDate"] = this.editDate ? this.editDate.toISOString() : <any>undefined;
        data["editUser"] = this.editUser;
        data["isActive"] = this.isActive;
        data["isLocked"] = this.isLocked;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditFiscalCalenderDto {
    period: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    gl: boolean;
    ap: boolean;
    ar: boolean;
    in: boolean;
    po: boolean;
    oe: boolean;
    bk: boolean;
    hr: boolean;
    pr: boolean;
    createdBy: number | undefined;
    createdDate: moment.Moment | undefined;
    editDate: moment.Moment | undefined;
    editUser: number | undefined;
    isActive: boolean;
    isLocked: boolean;
    id: number | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class GeneralLedgerModel implements IGeneralLedgerModel {
    accountCode!: string | undefined;
    accountTitle!: string | undefined;
    docNo!: number | undefined;
    subledgerCode!: number | undefined;
    subledgerDesc!: string | undefined;
    narration!: string | undefined;
    docDate!: moment.Moment | undefined;
    bookId!: string | undefined;
    configId!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    amount!: number | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;

    constructor(data?: IGeneralLedgerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountCode = data["accountCode"];
            this.accountTitle = data["accountTitle"];
            this.docNo = data["docNo"];
            this.subledgerCode = data["subledgerCode"];
            this.subledgerDesc = data["subledgerDesc"];
            this.narration = data["narration"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.bookId = data["bookId"];
            this.configId = data["configId"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.amount = data["amount"];
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
        }
    }

    static fromJS(data: any): GeneralLedgerModel {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountCode"] = this.accountCode;
        data["accountTitle"] = this.accountTitle;
        data["docNo"] = this.docNo;
        data["subledgerCode"] = this.subledgerCode;
        data["subledgerDesc"] = this.subledgerDesc;
        data["narration"] = this.narration;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["bookId"] = this.bookId;
        data["configId"] = this.configId;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["amount"] = this.amount;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        return data;
    }
}

export interface IGeneralLedgerModel {
    accountCode: string | undefined;
    accountTitle: string | undefined;
    docNo: number | undefined;
    subledgerCode: number | undefined;
    subledgerDesc: string | undefined;
    narration: string | undefined;
    docDate: moment.Moment | undefined;
    bookId: string | undefined;
    configId: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
    amount: number | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
}

export class PagedResultDtoOfGetGLBOOKSForViewDto implements IPagedResultDtoOfGetGLBOOKSForViewDto {
    totalCount!: number | undefined;
    items!: GetGLBOOKSForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGLBOOKSForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGLBOOKSForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGLBOOKSForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGLBOOKSForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGLBOOKSForViewDto {
    totalCount: number | undefined;
    items: GetGLBOOKSForViewDto[] | undefined;
}

export class GetGLBOOKSForViewDto implements IGetGLBOOKSForViewDto {
    glbooks!: GLBOOKSDto | undefined;

    constructor(data?: IGetGLBOOKSForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glbooks = data["glbooks"] ? GLBOOKSDto.fromJS(data["glbooks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGLBOOKSForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLBOOKSForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glbooks"] = this.glbooks ? this.glbooks.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGLBOOKSForViewDto {
    glbooks: GLBOOKSDto | undefined;
}

export class GLBOOKSDto implements IGLBOOKSDto {
    bookID!: string | undefined;
    bookName!: string | undefined;
    normalEntry!: number | undefined;
    integrated!: boolean | undefined;
    inactive!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    restricted!: number | undefined;
    id!: string | undefined;

    constructor(data?: IGLBOOKSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookID = data["bookID"];
            this.bookName = data["bookName"];
            this.normalEntry = data["normalEntry"];
            this.integrated = data["integrated"];
            this.inactive = data["inactive"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.restricted = data["restricted"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GLBOOKSDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLBOOKSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookID"] = this.bookID;
        data["bookName"] = this.bookName;
        data["normalEntry"] = this.normalEntry;
        data["integrated"] = this.integrated;
        data["inactive"] = this.inactive;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["restricted"] = this.restricted;
        data["id"] = this.id;
        return data;
    }
}

export interface IGLBOOKSDto {
    bookID: string | undefined;
    bookName: string | undefined;
    normalEntry: number | undefined;
    integrated: boolean | undefined;
    inactive: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    restricted: number | undefined;
    id: string | undefined;
}

export class GetGLBOOKSForEditOutput implements IGetGLBOOKSForEditOutput {
    glbooks!: CreateOrEditGLBOOKSDto | undefined;

    constructor(data?: IGetGLBOOKSForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glbooks = data["glbooks"] ? CreateOrEditGLBOOKSDto.fromJS(data["glbooks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGLBOOKSForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLBOOKSForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glbooks"] = this.glbooks ? this.glbooks.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGLBOOKSForEditOutput {
    glbooks: CreateOrEditGLBOOKSDto | undefined;
}

export class CreateOrEditGLBOOKSDto implements ICreateOrEditGLBOOKSDto {
    bookID!: string;
    bookName!: string;
    normalEntry!: number;
    integrated!: boolean | undefined;
    inactive!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    restricted!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditGLBOOKSDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookID = data["bookID"];
            this.bookName = data["bookName"];
            this.normalEntry = data["normalEntry"];
            this.integrated = data["integrated"];
            this.inactive = data["inactive"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.restricted = data["restricted"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGLBOOKSDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGLBOOKSDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookID"] = this.bookID;
        data["bookName"] = this.bookName;
        data["normalEntry"] = this.normalEntry;
        data["integrated"] = this.integrated;
        data["inactive"] = this.inactive;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["restricted"] = this.restricted;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGLBOOKSDto {
    bookID: string;
    bookName: string;
    normalEntry: number;
    integrated: boolean | undefined;
    inactive: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    restricted: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetGLCONFIGForViewDto implements IPagedResultDtoOfGetGLCONFIGForViewDto {
    totalCount!: number | undefined;
    items!: GetGLCONFIGForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGLCONFIGForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGLCONFIGForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGLCONFIGForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGLCONFIGForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGLCONFIGForViewDto {
    totalCount: number | undefined;
    items: GetGLCONFIGForViewDto[] | undefined;
}

export class GetGLCONFIGForViewDto implements IGetGLCONFIGForViewDto {
    glconfig!: GLCONFIGDto | undefined;
    glbooksBookName!: string | undefined;
    chartofControlAccountName!: string | undefined;
    accountSubLedgerSubAccName!: string | undefined;
    itemPriceLIst!: string | undefined;

    constructor(data?: IGetGLCONFIGForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glconfig = data["glconfig"] ? GLCONFIGDto.fromJS(data["glconfig"]) : <any>undefined;
            this.glbooksBookName = data["glbooksBookName"];
            this.chartofControlAccountName = data["chartofControlAccountName"];
            this.accountSubLedgerSubAccName = data["accountSubLedgerSubAccName"];
            this.itemPriceLIst = data["itemPriceLIst"];
        }
    }

    static fromJS(data: any): GetGLCONFIGForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLCONFIGForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glconfig"] = this.glconfig ? this.glconfig.toJSON() : <any>undefined;
        data["glbooksBookName"] = this.glbooksBookName;
        data["chartofControlAccountName"] = this.chartofControlAccountName;
        data["accountSubLedgerSubAccName"] = this.accountSubLedgerSubAccName;
        data["itemPriceLIst"] = this.itemPriceLIst;
        return data;
    }
}

export interface IGetGLCONFIGForViewDto {
    glconfig: GLCONFIGDto | undefined;
    glbooksBookName: string | undefined;
    chartofControlAccountName: string | undefined;
    accountSubLedgerSubAccName: string | undefined;
    itemPriceLIst: string | undefined;
}

export class GLCONFIGDto implements IGLCONFIGDto {
    accountID!: string | undefined;
    accountName!: string | undefined;
    bookName!: string | undefined;
    subAccID!: number | undefined;
    configID!: number | undefined;
    bookID!: string | undefined;
    postingOn!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    glbooksId!: string | undefined;
    chartofControlId!: string | undefined;
    accountSubLedgerId!: number | undefined;
    id!: string | undefined;

    constructor(data?: IGLCONFIGDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountID = data["accountID"];
            this.accountName = data["accountName"];
            this.bookName = data["bookName"];
            this.subAccID = data["subAccID"];
            this.configID = data["configID"];
            this.bookID = data["bookID"];
            this.postingOn = data["postingOn"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.glbooksId = data["glbooksId"];
            this.chartofControlId = data["chartofControlId"];
            this.accountSubLedgerId = data["accountSubLedgerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GLCONFIGDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLCONFIGDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountID"] = this.accountID;
        data["accountName"] = this.accountName;
        data["bookName"] = this.bookName;
        data["subAccID"] = this.subAccID;
        data["configID"] = this.configID;
        data["bookID"] = this.bookID;
        data["postingOn"] = this.postingOn;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["glbooksId"] = this.glbooksId;
        data["chartofControlId"] = this.chartofControlId;
        data["accountSubLedgerId"] = this.accountSubLedgerId;
        data["id"] = this.id;
        return data;
    }
}

export interface IGLCONFIGDto {
    accountID: string | undefined;
    accountName: string | undefined;
    bookName: string | undefined;
    subAccID: number | undefined;
    configID: number | undefined;
    bookID: string | undefined;
    postingOn: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    glbooksId: string | undefined;
    chartofControlId: string | undefined;
    accountSubLedgerId: number | undefined;
    id: string | undefined;
}

export class GetGLCONFIGForEditOutput implements IGetGLCONFIGForEditOutput {
    glconfig!: CreateOrEditGLCONFIGDto | undefined;
    glbooksBookName!: string | undefined;
    chartofControlAccountName!: string | undefined;
    accountSubLedgerSubAccName!: string | undefined;

    constructor(data?: IGetGLCONFIGForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glconfig = data["glconfig"] ? CreateOrEditGLCONFIGDto.fromJS(data["glconfig"]) : <any>undefined;
            this.glbooksBookName = data["glbooksBookName"];
            this.chartofControlAccountName = data["chartofControlAccountName"];
            this.accountSubLedgerSubAccName = data["accountSubLedgerSubAccName"];
        }
    }

    static fromJS(data: any): GetGLCONFIGForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLCONFIGForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glconfig"] = this.glconfig ? this.glconfig.toJSON() : <any>undefined;
        data["glbooksBookName"] = this.glbooksBookName;
        data["chartofControlAccountName"] = this.chartofControlAccountName;
        data["accountSubLedgerSubAccName"] = this.accountSubLedgerSubAccName;
        return data;
    }
}

export interface IGetGLCONFIGForEditOutput {
    glconfig: CreateOrEditGLCONFIGDto | undefined;
    glbooksBookName: string | undefined;
    chartofControlAccountName: string | undefined;
    accountSubLedgerSubAccName: string | undefined;
}

export class CreateOrEditGLCONFIGDto implements ICreateOrEditGLCONFIGDto {
    accountID!: string | undefined;
    subAccID!: number | undefined;
    configID!: number | undefined;
    bookID!: string | undefined;
    postingOn!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    glbooksId!: string | undefined;
    chartofControlId!: string | undefined;
    accountSubLedgerId!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditGLCONFIGDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountID = data["accountID"];
            this.subAccID = data["subAccID"];
            this.configID = data["configID"];
            this.bookID = data["bookID"];
            this.postingOn = data["postingOn"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.glbooksId = data["glbooksId"];
            this.chartofControlId = data["chartofControlId"];
            this.accountSubLedgerId = data["accountSubLedgerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGLCONFIGDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGLCONFIGDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountID"] = this.accountID;
        data["subAccID"] = this.subAccID;
        data["configID"] = this.configID;
        data["bookID"] = this.bookID;
        data["postingOn"] = this.postingOn;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["glbooksId"] = this.glbooksId;
        data["chartofControlId"] = this.chartofControlId;
        data["accountSubLedgerId"] = this.accountSubLedgerId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGLCONFIGDto {
    accountID: string | undefined;
    subAccID: number | undefined;
    configID: number | undefined;
    bookID: string | undefined;
    postingOn: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    glbooksId: string | undefined;
    chartofControlId: string | undefined;
    accountSubLedgerId: number | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto implements IPagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto {
    totalCount!: number | undefined;
    items!: GLCONFIGGLBOOKSLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLCONFIGGLBOOKSLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGLCONFIGGLBOOKSLookupTableDto {
    totalCount: number | undefined;
    items: GLCONFIGGLBOOKSLookupTableDto[] | undefined;
}

export class GLCONFIGGLBOOKSLookupTableDto implements IGLCONFIGGLBOOKSLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IGLCONFIGGLBOOKSLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): GLCONFIGGLBOOKSLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLCONFIGGLBOOKSLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGLCONFIGGLBOOKSLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGLCONFIGChartofControlLookupTableDto implements IPagedResultDtoOfGLCONFIGChartofControlLookupTableDto {
    totalCount!: number | undefined;
    items!: GLCONFIGChartofControlLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGLCONFIGChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLCONFIGChartofControlLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGLCONFIGChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGLCONFIGChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGLCONFIGChartofControlLookupTableDto {
    totalCount: number | undefined;
    items: GLCONFIGChartofControlLookupTableDto[] | undefined;
}

export class GLCONFIGChartofControlLookupTableDto implements IGLCONFIGChartofControlLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IGLCONFIGChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): GLCONFIGChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLCONFIGChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGLCONFIGChartofControlLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto implements IPagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto {
    totalCount!: number | undefined;
    items!: GLCONFIGAccountSubLedgerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLCONFIGAccountSubLedgerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGLCONFIGAccountSubLedgerLookupTableDto {
    totalCount: number | undefined;
    items: GLCONFIGAccountSubLedgerLookupTableDto[] | undefined;
}

export class GLCONFIGAccountSubLedgerLookupTableDto implements IGLCONFIGAccountSubLedgerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IGLCONFIGAccountSubLedgerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): GLCONFIGAccountSubLedgerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLCONFIGAccountSubLedgerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGLCONFIGAccountSubLedgerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetGLLocationForViewDto implements IPagedResultDtoOfGetGLLocationForViewDto {
    totalCount!: number | undefined;
    items!: GetGLLocationForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGLLocationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGLLocationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGLLocationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGLLocationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGLLocationForViewDto {
    totalCount: number | undefined;
    items: GetGLLocationForViewDto[] | undefined;
}

export class GetGLLocationForViewDto implements IGetGLLocationForViewDto {
    glLocation!: GLLocationDto | undefined;

    constructor(data?: IGetGLLocationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glLocation = data["glLocation"] ? GLLocationDto.fromJS(data["glLocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGLLocationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLLocationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glLocation"] = this.glLocation ? this.glLocation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGLLocationForViewDto {
    glLocation: GLLocationDto | undefined;
}

export class GLLocationDto implements IGLLocationDto {
    locDesc!: string | undefined;
    auditUser!: string | undefined;
    auditDate!: moment.Moment | undefined;
    locId!: number | undefined;
    cityID!: number | undefined;
    preFix: string | undefined;
    id!: number | undefined;

    constructor(data?: IGLLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locDesc = data["locDesc"];
            this.auditUser = data["auditUser"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.locId = data["locId"];
            this.cityID = data["cityID"];
            this.preFix = data["preFix"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GLLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locDesc"] = this.locDesc;
        data["auditUser"] = this.auditUser;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["locId"] = this.locId;
        data["cityID"] = this.cityID;
        data["preFix"] = this.preFix;
        data["id"] = this.id;
        return data;
    }
}

export interface IGLLocationDto {
    locDesc: string | undefined;
    auditUser: string | undefined;
    auditDate: moment.Moment | undefined;
    locId: number | undefined;
    cityID: number | undefined;
    preFix: string | undefined;
    id: number | undefined;
}

export class GetGLLocationForEditOutput implements IGetGLLocationForEditOutput {
    glLocation!: CreateOrEditGLLocationDto | undefined;

    constructor(data?: IGetGLLocationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glLocation = data["glLocation"] ? CreateOrEditGLLocationDto.fromJS(data["glLocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGLLocationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLLocationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glLocation"] = this.glLocation ? this.glLocation.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGLLocationForEditOutput {
    glLocation: CreateOrEditGLLocationDto | undefined;
}

export class CreateOrEditGLLocationDto implements ICreateOrEditGLLocationDto {
    locDesc!: string | undefined;
    auditUser!: string | undefined;
    auditDate!: moment.Moment | undefined;
    locId!: number | undefined;
    cityID!: number | undefined;
    preFix: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditGLLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locDesc = data["locDesc"];
            this.auditUser = data["auditUser"];
            this.auditDate = data["auditDate"] ? moment(data["auditDate"].toString()) : <any>undefined;
            this.locId = data["locId"];
            this.cityID = data["cityID"];
            this.preFix = data["preFix"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGLLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGLLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locDesc"] = this.locDesc;
        data["auditUser"] = this.auditUser;
        data["auditDate"] = this.auditDate ? this.auditDate.toISOString() : <any>undefined;
        data["locId"] = this.locId;
        data["cityID"] = this.cityID;
        data["preFix"] = this.preFix;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGLLocationDto {
    locDesc: string | undefined;
    auditUser: string | undefined;
    auditDate: moment.Moment | undefined;
    locId: number | undefined;
    cityID: number | undefined;
    preFix: string | undefined;
    id: number | undefined;
}

export class GetGLOptionForEditOutput implements IGetGLOptionForEditOutput {
    glOption!: CreateOrEditGLOptionDto | undefined;
    chartofControlId!: string | undefined;

    constructor(data?: IGetGLOptionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glOption = data["glOption"] ? CreateOrEditGLOptionDto.fromJS(data["glOption"]) : <any>undefined;
            this.chartofControlId = data["chartofControlId"];
        }
    }

    static fromJS(data: any): GetGLOptionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLOptionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glOption"] = this.glOption ? this.glOption.toJSON() : <any>undefined;
        data["chartofControlId"] = this.chartofControlId;
        return data;
    }
}

export interface IGetGLOptionForEditOutput {
    glOption: CreateOrEditGLOptionDto | undefined;
    chartofControlId: string | undefined;
}

export class CreateOrEditGLOptionDto implements ICreateOrEditGLOptionDto {
    defaultclacc!: string | undefined;
    stockctrlacc!: string | undefined;
    transferacc!: string | undefined;

    seg1Name!: string | undefined;
    seg2Name!: string | undefined;
    seg3Name!: string | undefined;
    directPost!: boolean | undefined;
    autoSeg3!: boolean | undefined;
    instrumentNo!: boolean | undefined;
    firstSignature!: string | undefined;
    secondSignature!: string | undefined;
    thirdSignature!: string | undefined;
    fourthSignature!: string | undefined;
    fifthSignature!: string | undefined;
    sixthSignature!: string | undefined;
    docFrequency!: number | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;
    financePoint!: number | undefined;

    constructor(data?: ICreateOrEditGLOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {

            this.defaultclacc = data["defaultclacc"];
            this.stockctrlacc = data["stockctrlacc"];
            this.transferacc = data["transferacc"];

            this.seg1Name = data["seg1Name"];
            this.seg2Name = data["seg2Name"];
            this.seg3Name = data["seg3Name"];
            this.directPost = data["directPost"];
            this.autoSeg3 = data["autoSeg3"];
            this.instrumentNo = data["instrumentNo"];
            this.firstSignature = data["firstSignature"];
            this.secondSignature = data["secondSignature"];
            this.thirdSignature = data["thirdSignature"];
            this.fourthSignature = data["fourthSignature"];
            this.fifthSignature = data["fifthSignature"];
            this.sixthSignature = data["sixthSignature"];
            this.docFrequency = data["docFrequency"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
            this.financePoint=data["financePoint"];
        }
    }

    static fromJS(data: any): CreateOrEditGLOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGLOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultclacc"] = this.defaultclacc;
        data["stockctrlacc"] = this.stockctrlacc; 
        data["transferacc"] = this.transferacc; 
        data["seg1Name"] = this.seg1Name;
        data["seg2Name"] = this.seg2Name;
        data["seg3Name"] = this.seg3Name;
        data["directPost"] = this.directPost;
        data["autoSeg3"] = this.autoSeg3;
        data["instrumentNo"] = this.instrumentNo;
        data["firstSignature"] = this.firstSignature;
        data["secondSignature"] = this.secondSignature;
        data["thirdSignature"] = this.thirdSignature;
        data["fourthSignature"] = this.fourthSignature;
        data["fifthSignature"] = this.fifthSignature;
        data["sixthSignature"] = this.sixthSignature;
        data["docFrequency"] = this.docFrequency;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        data["financePoint"]=this.financePoint;

        return data;
    }
}

export interface ICreateOrEditGLOptionDto {
    defaultclacc: string | undefined;
    stockctrlacc: string | undefined;
    transferacc: string | undefined;
    seg1Name: string | undefined;
    seg2Name: string | undefined;
    seg3Name: string | undefined;
    directPost: boolean | undefined;
    autoSeg3: boolean | undefined;
    instrumentNo: boolean | undefined;
    firstSignature: string | undefined;
    secondSignature: string | undefined;
    thirdSignature: string | undefined;
    fourthSignature: string | undefined;
    fifthSignature: string | undefined;
    sixthSignature: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGLOptionChartofControlLookupTableDto implements IPagedResultDtoOfGLOptionChartofControlLookupTableDto {
    totalCount!: number | undefined;
    items!: GLOptionChartofControlLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGLOptionChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLOptionChartofControlLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGLOptionChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGLOptionChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGLOptionChartofControlLookupTableDto {
    totalCount: number | undefined;
    items: GLOptionChartofControlLookupTableDto[] | undefined;
}

export class GLOptionChartofControlLookupTableDto implements IGLOptionChartofControlLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IGLOptionChartofControlLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): GLOptionChartofControlLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLOptionChartofControlLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGLOptionChartofControlLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetGLTRDetailForViewDto implements IPagedResultDtoOfGetGLTRDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetGLTRDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGLTRDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGLTRDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGLTRDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGLTRDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGLTRDetailForViewDto {
    totalCount: number | undefined;
    items: GetGLTRDetailForViewDto[] | undefined;
}

export class GetGLTRDetailForViewDto implements IGetGLTRDetailForViewDto {
    gltrDetail!: GLTRDetailDto | undefined;

    constructor(data?: IGetGLTRDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gltrDetail = data["gltrDetail"] ? GLTRDetailDto.fromJS(data["gltrDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGLTRDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLTRDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gltrDetail"] = this.gltrDetail ? this.gltrDetail.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGLTRDetailForViewDto {
    gltrDetail: GLTRDetailDto | undefined;
}

export class GetGLTRDetailForEditOutput implements IGetGLTRDetailForEditOutput {
    gltrDetail!: CreateOrEditGLTRDetailDto | undefined;

    constructor(data?: IGetGLTRDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gltrDetail = data["gltrDetail"] ? CreateOrEditGLTRDetailDto.fromJS(data["gltrDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGLTRDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLTRDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gltrDetail"] = this.gltrDetail ? this.gltrDetail.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGLTRDetailForEditOutput {
    gltrDetail: CreateOrEditGLTRDetailDto | undefined;
}

export class CreateOrEditGLTRDetailDto implements ICreateOrEditGLTRDetailDto {
    srNo!: number;
    detID!: number;
    accountID!: string;
    subAccID!: number | undefined;
    narration!: string | undefined;
    amount!: number | undefined;
    chequeNo!: string | undefined;
    isAuto!: boolean | undefined;
    locId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditGLTRDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.detID = data["detID"];
            this.srNo = data["srNo"];
            this.accountID = data["accountID"];
            this.subAccID = data["subAccID"];
            this.narration = data["narration"];
            this.amount = data["amount"];
            this.chequeNo = data["chequeNo"];
            this.isAuto = data["isAuto"];
            this.locId = data["locId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGLTRDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGLTRDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detID"] = this.detID;
        data["srNo"] = this.srNo;
        data["accountID"] = this.accountID;
        data["subAccID"] = this.subAccID;
        data["narration"] = this.narration;
        data["amount"] = this.amount;
        data["chequeNo"] = this.chequeNo;
        data["isAuto"] = this.isAuto;
        data["locId"] = this.locId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGLTRDetailDto {
    detID: number;
    srNo: number;
    accountID: string;
    subAccID: number | undefined;
    narration: string | undefined;
    amount: number | undefined;
    chequeNo: string | undefined;
    isAuto: boolean | undefined;
    locId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetGLTRHeaderForViewDto implements IPagedResultDtoOfGetGLTRHeaderForViewDto {
    totalCount!: number | undefined;
    items!: GetGLTRHeaderForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGLTRHeaderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGLTRHeaderForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGLTRHeaderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGLTRHeaderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGLTRHeaderForViewDto {
    totalCount: number | undefined;
    items: GetGLTRHeaderForViewDto[] | undefined;
}

export class GetGLTRHeaderForViewDto implements IGetGLTRHeaderForViewDto {
    gltrHeader!: GLTRHeaderDto | undefined;
    glconfigConfigID!: string | undefined;

    constructor(data?: IGetGLTRHeaderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gltrHeader = data["gltrHeader"] ? GLTRHeaderDto.fromJS(data["gltrHeader"]) : <any>undefined;
            this.glconfigConfigID = data["glconfigConfigID"];
        }
    }

    static fromJS(data: any): GetGLTRHeaderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLTRHeaderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gltrHeader"] = this.gltrHeader ? this.gltrHeader.toJSON() : <any>undefined;
        data["glconfigConfigID"] = this.glconfigConfigID;
        return data;
    }
}

export interface IGetGLTRHeaderForViewDto {
    gltrHeader: GLTRHeaderDto | undefined;
    glconfigConfigID: string | undefined;
}

export class GLTRHeaderDto implements IGLTRHeaderDto {
    bookID!: string | undefined;
    configID!: number | undefined;
    accountID!: string | undefined;
    accountDesc!: string | undefined;
    docNo!: number | undefined;
    amount!: number | undefined;
    docMonth!: number | undefined;
    docDate!: moment.Moment | undefined;
    narration!: string | undefined;
    chType!: number | undefined;
    chNumber!: number | undefined;
    posted!: boolean | undefined;
    postedBy!: string | undefined;
    postedDate!: moment.Moment | undefined;
    approved!: boolean | undefined;
    aprovedBy!: string | undefined;
    aprovedDate!: moment.Moment | undefined;
    auditUser!: string | undefined;
    auditTime!: moment.Moment | undefined;
    oldCode!: string | undefined;
    glconfigId!: string | undefined;
    curid!: string | undefined;
    currate!: number | undefined;
    createdBy!: string | undefined;
    createdOn!: moment.Moment | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;
    fmtDocNo!: number | undefined;
    id!: number | undefined;
    isIntegrated!: boolean | undefined;
    constructor(data?: IGLTRHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookID = data["bookID"];
            this.fmtDocNo = data["fmtDocNo"];
            this.configID = data["configID"];
            this.accountID = data["accountID"];
            this.accountDesc = data["accountDesc"];
            this.docNo = data["docNo"];
            this.docMonth = data["docMonth"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.narration = data["narration"];
            this.amount = data["amount"];
            this.chType = data["chType"];
            this.chNumber = data["chNumber"];
            this.posted = data["posted"];
            this.postedBy = data["postedBy"];
            this.postedDate = data["postedDate"] ? moment(data["postedDate"].toString()) : <any>undefined;
            this.approved = data["approved"];
            this.aprovedBy = data["aprovedBy"];
            this.aprovedDate = data["aprovedDate"] ? moment(data["aprovedDate"].toString()) : <any>undefined;
            this.auditUser = data["auditUser"];
            this.auditTime = data["auditTime"] ? moment(data["auditTime"].toString()) : <any>undefined;
            this.oldCode = data["oldCode"];
            this.glconfigId = data["glconfigId"];
            this.curid = data["curid"];
            this.currate = data["currate"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>undefined;
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
            this.id = data["id"];
            this.isIntegrated = data["isIntegrated"];
        }
    }

    static fromJS(data: any): GLTRHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLTRHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookID"] = this.bookID;
        data["configID"] = this.configID;
        data["accountID"] = this.accountID;
        data["accountDesc"] = this.accountDesc;
        data["docNo"] = this.docNo;
        data["amount"] = this.amount;
        data["chType"] = this.chType;
        data["chNumber"] = this.chNumber;
        data["docMonth"] = this.docMonth;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["narration"] = this.narration;
        data["posted"] = this.posted;
        data["postedBy"] = this.postedBy;
        data["postedDate"] = this.postedDate ? this.postedDate.toISOString() : <any>undefined;
        data["approved"] = this.approved;
        data["aprovedBy"] = this.aprovedBy;
        data["aprovedDate"] = this.aprovedDate ? this.aprovedDate.toISOString() : <any>undefined;
        data["auditUser"] = this.auditUser;
        data["auditTime"] = this.auditTime ? this.auditTime.toISOString() : <any>undefined;
        data["oldCode"] = this.oldCode;
        data["glconfigId"] = this.glconfigId;
        data["curid"] = this.curid;
        data["currate"] = this.currate;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        data["fmtDocNo"] = this.fmtDocNo;
        data["id"] = this.id;
        data["isIntegrated"] = this.isIntegrated;
        return data;
    }
}

export interface IGLTRHeaderDto {
    bookID: string | undefined;
    configID: number | undefined;
    docNo: number | undefined;
    docMonth: number | undefined;
    docDate: moment.Moment | undefined;
    narration: string | undefined;
    amount: number | undefined,
    chType: number | undefined,
    chNumber: number | undefined,
    posted: boolean | undefined;
    postedBy: string | undefined;
    postedDate: moment.Moment | undefined;
    approved: boolean | undefined;
    aprovedBy: string | undefined;
    aprovedDate: moment.Moment | undefined;
    auditUser: string | undefined;
    auditTime: moment.Moment | undefined;
    oldCode: string | undefined;
    glconfigId: string | undefined;
    curid: string | undefined;
    currate: number | undefined;
    createdBy: string | undefined;
    createdOn: moment.Moment | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
    //fmtDocNo: string | undefined;
    fmtDocNo: number | undefined;
    id: number | undefined;
}

export class GetGLTRHeaderForEditOutput implements IGetGLTRHeaderForEditOutput {
    gltrHeader!: CreateOrEditGLTRHeaderDto | undefined;
    glconfigConfigID!: string | undefined;

    constructor(data?: IGetGLTRHeaderForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gltrHeader = data["gltrHeader"] ? CreateOrEditGLTRHeaderDto.fromJS(data["gltrHeader"]) : <any>undefined;
            this.glconfigConfigID = data["glconfigConfigID"];
        }
    }

    static fromJS(data: any): GetGLTRHeaderForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGLTRHeaderForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gltrHeader"] = this.gltrHeader ? this.gltrHeader.toJSON() : <any>undefined;
        data["glconfigConfigID"] = this.glconfigConfigID;
        return data;
    }
}

export interface IGetGLTRHeaderForEditOutput {
    gltrHeader: CreateOrEditGLTRHeaderDto | undefined;
    glconfigConfigID: string | undefined;
}

export class CreateOrEditGLTRHeaderDto implements ICreateOrEditGLTRHeaderDto {
    bookID!: string;
    configID!: number;
    fmtDocNo!: number;
    docNo!: number;
    docMonth!: number;
    docDate!: moment.Moment;
    narration!: string | undefined;
    posted!: boolean;
    postedBy!: string | undefined;
    postedDate!: moment.Moment | undefined;
    approved!: boolean | undefined;
    aprovedBy!: string | undefined;
    aprovedDate!: moment.Moment | undefined;
    auditUser!: string | undefined;
    auditTime!: moment.Moment | undefined;
    oldCode!: string | undefined;
    glconfigId!: string | undefined;
    curid!: string | undefined;
    currate!: number | undefined;
    chNumber!: string | undefined;
    chType!: number | undefined;
    amount!: number | undefined;
    createdBy!: string | undefined;
    createdOn!: moment.Moment | undefined;
    locId!: number | undefined;
    id!: number | undefined;
    vouchNo!: number | undefined;
    reference!: string | undefined;
    isIntegrated!: boolean | undefined;

    constructor(data?: ICreateOrEditGLTRHeaderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookID = data["bookID"];
            this.configID = data["configID"];
            this.fmtDocNo = data["fmtDocNo"];
            this.docNo = data["docNo"];
            this.docMonth = data["docMonth"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.narration = data["narration"];
            this.posted = data["posted"];
            this.postedBy = data["postedBy"];
            this.postedDate = data["postedDate"] ? moment(data["postedDate"].toString()) : <any>undefined;
            this.approved = data["approved"];
            this.aprovedBy = data["aprovedBy"];
            this.aprovedDate = data["aprovedDate"] ? moment(data["aprovedDate"].toString()) : <any>undefined;
            this.auditUser = data["auditUser"];
            this.auditTime = data["auditTime"] ? moment(data["auditTime"].toString()) : <any>undefined;
            this.oldCode = data["oldCode"];
            this.glconfigId = data["glconfigId"];
            this.curid = data["curid"];
            this.currate = data["currate"];
            this.createdBy = data["createdBy"];
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>undefined;
            this.locId = data["locId"];
            this.chNumber = data["chNumber"];
            this.chType = data["chType"];
            this.amount = data["amount"];
            this.id = data["id"];
            this.vouchNo = data["vouchNo"];
            this.reference = data["reference"];
            this.isIntegrated = data["isIntegrated"];
        }
    }

    static fromJS(data: any): CreateOrEditGLTRHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGLTRHeaderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookID"] = this.bookID;
        data["configID"] = this.configID;
        data["fmtDocNo"] = this.fmtDocNo;
        data["docNo"] = this.docNo;
        data["docMonth"] = this.docMonth;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["narration"] = this.narration;
        data["posted"] = this.posted;
        data["postedBy"] = this.postedBy;
        data["postedDate"] = this.postedDate ? this.postedDate.toISOString() : <any>undefined;
        data["approved"] = this.approved;
        data["aprovedBy"] = this.aprovedBy;
        data["aprovedDate"] = this.aprovedDate ? this.aprovedDate.toISOString() : <any>undefined;
        data["auditUser"] = this.auditUser;
        data["auditTime"] = this.auditTime ? this.auditTime.toISOString() : <any>undefined;
        data["oldCode"] = this.oldCode;
        data["glconfigId"] = this.glconfigId;
        data["curid"] = this.curid;
        data["currate"] = this.currate;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["locId"] = this.locId;
        data["chNumber"] = this.chNumber;
        data["chType"] = this.chType;
        data["amount"] = this.amount;
        data["id"] = this.id;
        data["vouchNo"] = this.vouchNo;
        data["reference"] = this.reference;
        data["isIntegrated"] = this.isIntegrated;
        return data;
    }
}

export interface ICreateOrEditGLTRHeaderDto {
    bookID: string;
    configID: number;
    docNo: number;
    docMonth: number;
    docDate: moment.Moment;
    narration: string | undefined;
    posted: boolean;
    postedBy: string | undefined;
    postedDate: moment.Moment | undefined;
    approved: boolean | undefined;
    aprovedBy: string | undefined;
    aprovedDate: moment.Moment | undefined;
    auditUser: string | undefined;
    fmtDocNo: number | undefined;
    auditTime: moment.Moment | undefined;
    oldCode: string | undefined;
    glconfigId: string | undefined;
    curid: string | undefined;
    currate: number | undefined;
    createdBy: string | undefined;
    createdOn: moment.Moment | undefined;
    chNumber: string | undefined;
    chType: number | undefined;
    amount: number | undefined;
    locId: number | undefined;
    id: number | undefined;
    reference: string | undefined;
}

export class PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto implements IPagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto {
    totalCount!: number | undefined;
    items!: GLTRHeaderGLCONFIGLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLTRHeaderGLCONFIGLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGLTRHeaderGLCONFIGLookupTableDto {
    totalCount: number | undefined;
    items: GLTRHeaderGLCONFIGLookupTableDto[] | undefined;
}

export class GLTRHeaderGLCONFIGLookupTableDto implements IGLTRHeaderGLCONFIGLookupTableDto {
    configId!: string | undefined;
    accountId!: string | undefined;
    accountDesc!: string | undefined;

    constructor(data?: IGLTRHeaderGLCONFIGLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.configId = data["configId"];
            this.accountId = data["accountId"];
            this.accountDesc = data["accountDesc"];
        }
    }

    static fromJS(data: any): GLTRHeaderGLCONFIGLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLTRHeaderGLCONFIGLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configId"] = this.configId;
        data["accountId"] = this.accountId;
        data["accountDesc"] = this.accountDesc;
        return data;
    }
}

export interface IGLTRHeaderGLCONFIGLookupTableDto {
    configId: string | undefined;
    accountId: string | undefined;
    accountDesc: string | undefined;
}

export class PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto implements IPagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto {
    totalCount!: number | undefined;
    items!: GLTRHeaderGLSubledgerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GLTRHeaderGLSubledgerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGLTRHeaderGLSubledgerLookupTableDto {
    totalCount: number | undefined;
    items: GLTRHeaderGLSubledgerLookupTableDto[] | undefined;
}

export class GLTRHeaderGLSubledgerLookupTableDto implements IGLTRHeaderGLSubledgerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IGLTRHeaderGLSubledgerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): GLTRHeaderGLSubledgerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GLTRHeaderGLSubledgerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGLTRHeaderGLSubledgerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetGroupCategoryForViewDto implements IPagedResultDtoOfGetGroupCategoryForViewDto {
    totalCount!: number | undefined;
    items!: GetGroupCategoryForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGroupCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGroupCategoryForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGroupCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGroupCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGroupCategoryForViewDto {
    totalCount: number | undefined;
    items: GetGroupCategoryForViewDto[] | undefined;
}

export class GetGroupCategoryForViewDto implements IGetGroupCategoryForViewDto {
    groupCategory!: GroupCategoryDto | undefined;

    constructor(data?: IGetGroupCategoryForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupCategory = data["groupCategory"] ? GroupCategoryDto.fromJS(data["groupCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGroupCategoryForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGroupCategoryForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCategory"] = this.groupCategory ? this.groupCategory.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGroupCategoryForViewDto {
    groupCategory: GroupCategoryDto | undefined;
}

export class GroupCategoryDto implements IGroupCategoryDto {
    grpctcode!: number | undefined;
    grpctdesc!: string | undefined;
    id!: number | undefined;

    constructor(data?: IGroupCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grpctcode = data["grpctcode"];
            this.grpctdesc = data["grpctdesc"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GroupCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grpctcode"] = this.grpctcode;
        data["grpctdesc"] = this.grpctdesc;
        data["id"] = this.id;
        return data;
    }
}

export interface IGroupCategoryDto {
    grpctcode: number | undefined;
    grpctdesc: string | undefined;
    id: number | undefined;
}

export class GetGroupCategoryForEditOutput implements IGetGroupCategoryForEditOutput {
    groupCategory!: CreateOrEditGroupCategoryDto | undefined;

    constructor(data?: IGetGroupCategoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupCategory = data["groupCategory"] ? CreateOrEditGroupCategoryDto.fromJS(data["groupCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGroupCategoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGroupCategoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCategory"] = this.groupCategory ? this.groupCategory.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGroupCategoryForEditOutput {
    groupCategory: CreateOrEditGroupCategoryDto | undefined;
}

export class CreateOrEditGroupCategoryDto implements ICreateOrEditGroupCategoryDto {
    grpctcode!: number | undefined;
    grpctdesc!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditGroupCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grpctcode = data["grpctcode"];
            this.grpctdesc = data["grpctdesc"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGroupCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGroupCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grpctcode"] = this.grpctcode;
        data["grpctdesc"] = this.grpctdesc;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGroupCategoryDto {
    grpctcode: number | undefined;
    grpctdesc: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetGroupCodeForViewDto implements IPagedResultDtoOfGetGroupCodeForViewDto {
    totalCount!: number | undefined;
    items!: GetGroupCodeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGroupCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetGroupCodeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGroupCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGroupCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGroupCodeForViewDto {
    totalCount: number | undefined;
    items: GetGroupCodeForViewDto[] | undefined;
}

export class GetGroupCodeForViewDto implements IGetGroupCodeForViewDto {
    groupCode!: GroupCodeDto | undefined;
    grpctcodedesc!: string | undefined;

    constructor(data?: IGetGroupCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupCode = data["groupCode"] ? GroupCodeDto.fromJS(data["groupCode"]) : <any>undefined;
            this.grpctcodedesc = data["grpctcodedesc"];
        }
    }

    static fromJS(data: any): GetGroupCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGroupCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCode"] = this.groupCode ? this.groupCode.toJSON() : <any>undefined;
        data["grpctcodedesc"] = this.grpctcodedesc;
        return data;
    }
}

export interface IGetGroupCodeForViewDto {
    groupCode: GroupCodeDto | undefined;
    grpctcodedesc: string | undefined;
}

export class GroupCodeDto implements IGroupCodeDto {
    grpcode!: number | undefined;
    grpdesc!: string | undefined;
    grpctcode!: number | undefined;
    id!: number | undefined;

    constructor(data?: IGroupCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grpcode = data["grpcode"];
            this.grpdesc = data["grpdesc"];
            this.grpctcode = data["grpctcode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GroupCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grpcode"] = this.grpcode;
        data["grpdesc"] = this.grpdesc;
        data["grpctcode"] = this.grpctcode;
        data["id"] = this.id;
        return data;
    }
}

export interface IGroupCodeDto {
    grpcode: number | undefined;
    grpdesc: string | undefined;
    grpctcode: number | undefined;
    id: number | undefined;
}

export class GetMaxIDGroupCodes implements IGetMaxIDGroupCodes {
    groupID!: number[] | undefined;
    maxID!: number | undefined;

    constructor(data?: IGetMaxIDGroupCodes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["groupID"] && data["groupID"].constructor === Array) {
                this.groupID = [] as any;
                for (let item of data["groupID"])
                    this.groupID!.push(item);
            }
            this.maxID = data["maxID"];
        }
    }

    static fromJS(data: any): GetMaxIDGroupCodes {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaxIDGroupCodes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.groupID && this.groupID.constructor === Array) {
            data["groupID"] = [];
            for (let item of this.groupID)
                data["groupID"].push(item);
        }
        data["maxID"] = this.maxID;
        return data;
    }
}

export interface IGetMaxIDGroupCodes {
    groupID: number[] | undefined;
    maxID: number | undefined;
}

export class GetGroupCodeForEditOutput implements IGetGroupCodeForEditOutput {
    groupCode!: CreateOrEditGroupCodeDto | undefined;
    grpctcode!: number | undefined;

    constructor(data?: IGetGroupCodeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupCode = data["groupCode"] ? CreateOrEditGroupCodeDto.fromJS(data["groupCode"]) : <any>undefined;
            this.grpctcode = data["grpctcode"];
        }
    }

    static fromJS(data: any): GetGroupCodeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGroupCodeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCode"] = this.groupCode ? this.groupCode.toJSON() : <any>undefined;
        data["grpctcode"] = this.grpctcode;
        return data;
    }
}

export interface IGetGroupCodeForEditOutput {
    groupCode: CreateOrEditGroupCodeDto | undefined;
    grpctcode: number | undefined;
}

export class CreateOrEditGroupCodeDto implements ICreateOrEditGroupCodeDto {
    grpcode!: number | undefined;
    grpdesc!: string;
    grpctcode!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditGroupCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.grpcode = data["grpcode"];
            this.grpdesc = data["grpdesc"];
            this.grpctcode = data["grpctcode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGroupCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGroupCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["grpcode"] = this.grpcode;
        data["grpdesc"] = this.grpdesc;
        data["grpctcode"] = this.grpctcode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGroupCodeDto {
    grpcode: number | undefined;
    grpdesc: string;
    grpctcode: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfGroupCategoryForComboboxDto implements IListResultDtoOfGroupCategoryForComboboxDto {
    items!: GroupCategoryForComboboxDto[] | undefined;

    constructor(data?: IListResultDtoOfGroupCategoryForComboboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GroupCategoryForComboboxDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGroupCategoryForComboboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGroupCategoryForComboboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGroupCategoryForComboboxDto {
    items: GroupCategoryForComboboxDto[] | undefined;
}

export class GroupCategoryForComboboxDto implements IGroupCategoryForComboboxDto {
    id!: number | undefined;
    displayName!: string | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IGroupCategoryForComboboxDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): GroupCategoryForComboboxDto {
        data = typeof data === 'object' ? data : {};
        let result = new GroupCategoryForComboboxDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IGroupCategoryForComboboxDto {
    id: number | undefined;
    displayName: string | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [] as any;
                for (let item of data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [] as any;
                for (let item of data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;
    otherSettings!: OtherSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto | undefined;
    billInfo!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment | undefined;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [] as any;
                for (let item of data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [] as any;
                for (let item of data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data;
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class UserDTO implements IUserDTO {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: IUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUserDTO {
    id: number | undefined;
    name: string | undefined;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotification | undefined;
    id!: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties![key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    roleCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PartyBalances implements IPartyBalances {
    accountId!: string | undefined;
    subAccountName!: string | undefined;
    accountName!: string | undefined;
    subAccId!: number | undefined;
    opening!: number | undefined;
    closing!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;

    constructor(data?: IPartyBalances) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.subAccountName = data["subAccountName"];
            this.accountName = data["accountName"];
            this.subAccId = data["subAccId"];
            this.opening = data["opening"];
            this.closing = data["closing"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
        }
    }

    static fromJS(data: any): PartyBalances {
        data = typeof data === 'object' ? data : {};
        let result = new PartyBalances();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["subAccountName"] = this.subAccountName;
        data["accountName"] = this.accountName;
        data["subAccId"] = this.subAccId;
        data["opening"] = this.opening;
        data["closing"] = this.closing;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        return data;
    }
}

export interface IPartyBalances {
    accountId: string | undefined;
    subAccountName: string | undefined;
    accountName: string | undefined;
    subAccId: number | undefined;
    opening: number | undefined;
    closing: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto | undefined;
    additionalPrice!: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean | undefined;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number | undefined;
    editionPaymentType!: EditionPaymentType | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled!: boolean | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data;
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export enum PaymentPeriodType {
    Monthly = 30,
    Annual = 365,
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number | undefined;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number | undefined;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments!: boolean | undefined;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    tenantId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number | undefined;
    status!: SubscriptionPaymentStatus | undefined;
    isRecurring!: boolean | undefined;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    environment!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.environment = data["environment"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["environment"] = this.environment;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    environment: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number | undefined;
    y!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ListResultDtoOfChartOfControlLookupDto implements IListResultDtoOfChartOfControlLookupDto {
    items!: ChartOfControlLookupDto[] | undefined;

    constructor(data?: IListResultDtoOfChartOfControlLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChartOfControlLookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChartOfControlLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChartOfControlLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChartOfControlLookupDto {
    items: ChartOfControlLookupDto[] | undefined;
}

export class ChartOfControlLookupDto implements IChartOfControlLookupDto {
    accountID!: string | undefined;
    accountName!: string | undefined;

    constructor(data?: IChartOfControlLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountID = data["accountID"];
            this.accountName = data["accountName"];
        }
    }

    static fromJS(data: any): ChartOfControlLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartOfControlLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountID"] = this.accountID;
        data["accountName"] = this.accountName;
        return data;
    }
}

export interface IChartOfControlLookupDto {
    accountID: string | undefined;
    accountName: string | undefined;
}

export class PagedResultDtoOfAccountSubLedgerListDto implements IPagedResultDtoOfAccountSubLedgerListDto {
    totalCount!: number | undefined;
    items!: AccountSubLedgerListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountSubLedgerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AccountSubLedgerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountSubLedgerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountSubLedgerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAccountSubLedgerListDto {
    totalCount: number | undefined;
    items: AccountSubLedgerListDto[] | undefined;
}

export class AccountSubLedgerListDto implements IAccountSubLedgerListDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAccountSubLedgerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AccountSubLedgerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountSubLedgerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IAccountSubLedgerListDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLookupDto implements IPagedResultDtoOfLookupDto {
    totalCount!: number | undefined;
    items!: LookupDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLookupDto {
    totalCount: number | undefined;
    items: LookupDto[] | undefined;
}

export class LookupDto implements ILookupDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ILookupDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];
debugger
    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class PagedResultDtoOfGetSegmentlevel3ForViewDto implements IPagedResultDtoOfGetSegmentlevel3ForViewDto {
    totalCount!: number | undefined;
    items!: GetSegmentlevel3ForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSegmentlevel3ForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSegmentlevel3ForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSegmentlevel3ForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSegmentlevel3ForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSegmentlevel3ForViewDto {
    totalCount: number | undefined;
    items: GetSegmentlevel3ForViewDto[] | undefined;
}

export class GetSegmentlevel3ForViewDto implements IGetSegmentlevel3ForViewDto {
    segmentlevel3!: Segmentlevel3Dto | undefined;
    controlDetailId!: string | undefined;
    controlDetailDesc!: string | undefined;
    subControlDetailId!: string | undefined;
    subControlDetailDesc!: string | undefined;

    constructor(data?: IGetSegmentlevel3ForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentlevel3 = data["segmentlevel3"] ? Segmentlevel3Dto.fromJS(data["segmentlevel3"]) : <any>undefined;
            this.controlDetailId = data["controlDetailId"];
            this.controlDetailDesc = data["controlDetailDesc"];
            this.subControlDetailId = data["subControlDetailId"];
            this.subControlDetailDesc = data["subControlDetailDesc"];
        }
    }

    static fromJS(data: any): GetSegmentlevel3ForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSegmentlevel3ForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentlevel3"] = this.segmentlevel3 ? this.segmentlevel3.toJSON() : <any>undefined;
        data["controlDetailId"] = this.controlDetailId;
        data["controlDetailDesc"] = this.controlDetailDesc;
        data["subControlDetailId"] = this.subControlDetailId;
        data["subControlDetailDesc"] = this.subControlDetailDesc;
        return data;
    }
}

export interface IGetSegmentlevel3ForViewDto {
    segmentlevel3: Segmentlevel3Dto | undefined;
    controlDetailId: string | undefined;
    controlDetailDesc: string | undefined;
    subControlDetailId: string | undefined;
    subControlDetailDesc: string | undefined;
}

export class Segmentlevel3Dto implements ISegmentlevel3Dto {
    seg3ID!: string | undefined;
    segmentName!: string | undefined;
    oldCode!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISegmentlevel3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg3ID = data["seg3ID"];
            this.segmentName = data["segmentName"];
            this.oldCode = data["oldCode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Segmentlevel3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new Segmentlevel3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg3ID"] = this.seg3ID;
        data["segmentName"] = this.segmentName;
        data["oldCode"] = this.oldCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ISegmentlevel3Dto {
    seg3ID: string | undefined;
    segmentName: string | undefined;
    oldCode: string | undefined;
    id: number | undefined;
}

export class GetSegmentlevel3ForEditOutput implements IGetSegmentlevel3ForEditOutput {
    segmentlevel3!: CreateOrEditSegmentlevel3Dto | undefined;
    controlDetailId!: string | undefined;
    controlDetailDesc!: string | undefined;
    subControlDetailId!: string | undefined;
    subControlDetailDesc!: string | undefined;

    constructor(data?: IGetSegmentlevel3ForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.segmentlevel3 = data["segmentlevel3"] ? CreateOrEditSegmentlevel3Dto.fromJS(data["segmentlevel3"]) : <any>undefined;
            this.controlDetailId = data["controlDetailId"];
            this.controlDetailDesc = data["controlDetailDesc"];
            this.subControlDetailId = data["subControlDetailId"];
            this.subControlDetailDesc = data["subControlDetailDesc"];
        }
    }

    static fromJS(data: any): GetSegmentlevel3ForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSegmentlevel3ForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["segmentlevel3"] = this.segmentlevel3 ? this.segmentlevel3.toJSON() : <any>undefined;
        data["controlDetailId"] = this.controlDetailId;
        data["controlDetailDesc"] = this.controlDetailDesc;
        data["subControlDetailId"] = this.subControlDetailId;
        data["subControlDetailDesc"] = this.subControlDetailDesc;
        return data;
    }
}

export interface IGetSegmentlevel3ForEditOutput {
    segmentlevel3: CreateOrEditSegmentlevel3Dto | undefined;
    controlDetailId: string | undefined;
    controlDetailDesc: string | undefined;
    subControlDetailId: string | undefined;
    subControlDetailDesc: string | undefined;
}

export class CreateOrEditSegmentlevel3Dto implements ICreateOrEditSegmentlevel3Dto {
    seg3ID!: string | undefined;
    segmentName!: string | undefined;
    oldCode!: string | undefined;
    controlDetailId!: string | undefined;
    subControlDetailId!: string | undefined;
    flag!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSegmentlevel3Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg3ID = data["seg3ID"];
            this.segmentName = data["segmentName"];
            this.oldCode = data["oldCode"];
            this.controlDetailId = data["controlDetailId"];
            this.subControlDetailId = data["subControlDetailId"];
            this.flag = data["flag"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSegmentlevel3Dto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSegmentlevel3Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg3ID"] = this.seg3ID;
        data["segmentName"] = this.segmentName;
        data["oldCode"] = this.oldCode;
        data["controlDetailId"] = this.controlDetailId;
        data["subControlDetailId"] = this.subControlDetailId;
        data["flag"] = this.flag;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditSegmentlevel3Dto {
    seg3ID: string | undefined;
    segmentName: string | undefined;
    oldCode: string | undefined;
    controlDetailId: string | undefined;
    subControlDetailId: string | undefined;
    flag: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto implements IPagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto {
    totalCount!: number | undefined;
    items!: Segmentlevel3ControlDetailLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(Segmentlevel3ControlDetailLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSegmentlevel3ControlDetailLookupTableDto {
    totalCount: number | undefined;
    items: Segmentlevel3ControlDetailLookupTableDto[] | undefined;
}

export class Segmentlevel3ControlDetailLookupTableDto implements ISegmentlevel3ControlDetailLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ISegmentlevel3ControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): Segmentlevel3ControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new Segmentlevel3ControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISegmentlevel3ControlDetailLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto implements IPagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto {
    totalCount!: number | undefined;
    items!: Segmentlevel3SubControlDetailLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(Segmentlevel3SubControlDetailLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSegmentlevel3SubControlDetailLookupTableDto {
    totalCount: number | undefined;
    items: Segmentlevel3SubControlDetailLookupTableDto[] | undefined;
}

export class Segmentlevel3SubControlDetailLookupTableDto implements ISegmentlevel3SubControlDetailLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ISegmentlevel3SubControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): Segmentlevel3SubControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new Segmentlevel3SubControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISegmentlevel3SubControlDetailLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;
    theme!: UiCustomizationSettingsDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    subscriptionPaymentType!: SubscriptionPaymentType | undefined;
    edition!: EditionInfoDto | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean | undefined;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features![key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string]: boolean; } | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto | undefined;
    isLeftMenuUsed!: boolean | undefined;
    isTopMenuUsed!: boolean | undefined;
    isTabMenuUsed!: boolean | undefined;
    allowMenuScroll!: boolean | undefined;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean | undefined;
    isFree!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto | undefined;
    header!: ThemeHeaderSettingsDto | undefined;
    subHeader!: ThemeSubHeaderSettingsDto | undefined;
    menu!: ThemeMenuSettingsDto | undefined;
    footer!: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.subHeader = data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(data["subHeader"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    subHeader: ThemeSubHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;
    headerMenuArrows!: boolean | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.minimizeDesktopHeaderType = data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean | undefined;
    subheaderStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedSubHeader = data["fixedSubHeader"];
            this.subheaderStyle = data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean | undefined;
    subheaderStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    submenuToggle!: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        return data;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    submenuToggle: string | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data;
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data;
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId!: number | undefined;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data;
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class PagedResultDtoOfGetSubControlDetailForViewDto implements IPagedResultDtoOfGetSubControlDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetSubControlDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSubControlDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSubControlDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSubControlDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSubControlDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetSubControlDetailForViewDto {
    totalCount: number | undefined;
    items: GetSubControlDetailForViewDto[] | undefined;
}

export class GetSubControlDetailForViewDto implements IGetSubControlDetailForViewDto {
    subControlDetail!: SubControlDetailDto | undefined;
    controlDetailId!: string | undefined;
    controlDetaildesc!: string | undefined;

    constructor(data?: IGetSubControlDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subControlDetail = data["subControlDetail"] ? SubControlDetailDto.fromJS(data["subControlDetail"]) : <any>undefined;
            this.controlDetailId = data["controlDetailId"];
            this.controlDetaildesc = data["controlDetaildesc"];
        }
    }

    static fromJS(data: any): GetSubControlDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSubControlDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subControlDetail"] = this.subControlDetail ? this.subControlDetail.toJSON() : <any>undefined;
        data["controlDetailId"] = this.controlDetailId;
        data["controlDetaildesc"] = this.controlDetaildesc;
        return data;
    }
}

export interface IGetSubControlDetailForViewDto {
    subControlDetail: SubControlDetailDto | undefined;
    controlDetailId: string | undefined;
    controlDetaildesc: string | undefined;
}

export class SubControlDetailDto implements ISubControlDetailDto {
    seg2ID!: string | undefined;
    segmentName!: string | undefined;
    oldCode!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubControlDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg2ID = data["seg2ID"];
            this.segmentName = data["segmentName"];
            this.oldCode = data["oldCode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubControlDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubControlDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg2ID"] = this.seg2ID;
        data["segmentName"] = this.segmentName;
        data["oldCode"] = this.oldCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubControlDetailDto {
    seg2ID: string | undefined;
    segmentName: string | undefined;
    oldCode: string | undefined;
    id: number | undefined;
}

export class GetSubControlDetailForEditOutput implements IGetSubControlDetailForEditOutput {
    subControlDetail!: CreateOrEditSubControlDetailDto | undefined;
    controlDetailId!: string | undefined;
    controlDetailDesc!: string | undefined;

    constructor(data?: IGetSubControlDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subControlDetail = data["subControlDetail"] ? CreateOrEditSubControlDetailDto.fromJS(data["subControlDetail"]) : <any>undefined;
            this.controlDetailId = data["controlDetailId"];
            this.controlDetailDesc = data["controlDetailDesc"];
        }
    }

    static fromJS(data: any): GetSubControlDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSubControlDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subControlDetail"] = this.subControlDetail ? this.subControlDetail.toJSON() : <any>undefined;
        data["controlDetailId"] = this.controlDetailId;
        data["controlDetailDesc"] = this.controlDetailDesc;
        return data;
    }
}

export interface IGetSubControlDetailForEditOutput {
    subControlDetail: CreateOrEditSubControlDetailDto | undefined;
    controlDetailId: string | undefined;
    controlDetailDesc: string | undefined;
}

export class CreateOrEditSubControlDetailDto implements ICreateOrEditSubControlDetailDto {
    seg2ID!: string | undefined;
    segmentName!: string | undefined;
    segmantID1!: string | undefined;
    oldCode!: string | undefined;
    flag!: boolean | undefined;
    id!: number | undefined;
    sortOrder!: number | undefined;
    accountType!: string | undefined;
    accountHeader!: number | undefined;
    accountBSType !: string | undefined;
    accountBSHeader !: number | undefined;
    sortBSOrder !: number | undefined;
    accountCFType !: string | undefined;
    accountCFHeader !: number | undefined;
    sortCFOrder !: number | undefined;
    acctype:string|undefined;

    constructor(data?: ICreateOrEditSubControlDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg2ID = data["seg2ID"];
            this.segmentName = data["segmentName"];
            this.segmantID1 = data["segmantID1"];
            this.oldCode = data["oldCode"];
            this.flag = data["flag"];
            this.id = data["id"];
            this.sortOrder = data["sortOrder"];
            this.accountType = data["accountType"];
            this.accountHeader = data["accountHeader"];
            this.sortBSOrder = data["sortBSOrder"];
            this.accountBSType = data["accountBSType"];
            this.accountBSHeader = data["accountBSHeader"];
            this.accountCFType=data["accountCFType"];
            this.accountCFHeader=data["accountCFHeader"];
            this.sortCFOrder=data["sortCFOrder"];
            this.acctype=data["acctype"];
        }
    }

    static fromJS(data: any): CreateOrEditSubControlDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSubControlDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg2ID"] = this.seg2ID;
        data["segmentName"] = this.segmentName;
        data["segmantID1"] = this.segmantID1;
        data["oldCode"] = this.oldCode;
        data["flag"] = this.flag;
        data["id"] = this.id;
        data["sortOrder"]= this.sortOrder  ;
        data["accountType"]=    this.accountType ;
        data["accountHeader"]=    this.accountHeader  ;
        data["sortBSOrder"]= this.sortBSOrder ;
        data["accountBSType"]=  this.accountBSType  ;
        data["accountBSHeader"]= this.accountBSHeader  ;
        data["accountCFType"]=this.accountCFType;
        data["accountCFHeader"]=this.accountCFHeader;
        data["sortCFOrder"]=this.sortCFOrder;
        data["acctype"]=this.acctype;
        return data;
    }
}

export interface ICreateOrEditSubControlDetailDto {
    seg2ID: string | undefined;
    segmentName: string | undefined;
    segmantID1: string | undefined;
    oldCode: string | undefined;
    flag: boolean | undefined;
    id: number | undefined;
    sortOrder: number | undefined;
    accountType: string | undefined;
    accountHeader: number | undefined;
    sortBSOrder: number | undefined;
    accountBSType: string | undefined;
    accountBSHeader: number | undefined;
    accountCFType : string | undefined;
    accountCFHeader : number | undefined;
    sortCFOrder : number | undefined;
    acctype:string|undefined;
}

export class PagedResultDtoOfSubControlDetailControlDetailLookupTableDto implements IPagedResultDtoOfSubControlDetailControlDetailLookupTableDto {
    totalCount!: number | undefined;
    items!: SubControlDetailControlDetailLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubControlDetailControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubControlDetailControlDetailLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubControlDetailControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubControlDetailControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSubControlDetailControlDetailLookupTableDto {
    totalCount: number | undefined;
    items: SubControlDetailControlDetailLookupTableDto[] | undefined;
}

export class SubControlDetailControlDetailLookupTableDto implements ISubControlDetailControlDetailLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ISubControlDetailControlDetailLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SubControlDetailControlDetailLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubControlDetailControlDetailLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ISubControlDetailControlDetailLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class SubedgerModel implements ISubedgerModel {
    accountCode!: string | undefined;
    accountTitle!: string | undefined;
    docNo!: number | undefined;
    subledgerCode!: number | undefined;
    subledgerDesc!: string | undefined;
    narration!: string | undefined;
    docDate!: moment.Moment | undefined;
    bookId!: string | undefined;
    configId!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    amount!: number | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;

    constructor(data?: ISubedgerModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountCode = data["accountCode"];
            this.accountTitle = data["accountTitle"];
            this.docNo = data["docNo"];
            this.subledgerCode = data["subledgerCode"];
            this.subledgerDesc = data["subledgerDesc"];
            this.narration = data["narration"];
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.bookId = data["bookId"];
            this.configId = data["configId"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.amount = data["amount"];
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
        }
    }

    static fromJS(data: any): SubedgerModel {
        data = typeof data === 'object' ? data : {};
        let result = new SubedgerModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountCode"] = this.accountCode;
        data["accountTitle"] = this.accountTitle;
        data["docNo"] = this.docNo;
        data["subledgerCode"] = this.subledgerCode;
        data["subledgerDesc"] = this.subledgerDesc;
        data["narration"] = this.narration;
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["bookId"] = this.bookId;
        data["configId"] = this.configId;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["amount"] = this.amount;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        return data;
    }
}

export interface ISubedgerModel {
    accountCode: string | undefined;
    accountTitle: string | undefined;
    docNo: number | undefined;
    subledgerCode: number | undefined;
    subledgerDesc: string | undefined;
    narration: string | undefined;
    docDate: moment.Moment | undefined;
    bookId: string | undefined;
    configId: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
    amount: number | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
}

export class SubLedgerTrial implements ISubLedgerTrial {
    seg1ID!: string | undefined;
    seg1Name!: string | undefined;
    seg2ID!: string | undefined;
    seg2Name!: string | undefined;
    seg3ID!: string | undefined;
    seg3Name!: string | undefined;
    accountID!: string | undefined;
    accountName!: string | undefined;
    subAccID!: number | undefined;
    subAccName!: string | undefined;
    subLedger!: boolean | undefined;
    family!: string | undefined;
    opn!: number | undefined;
    cur!: number | undefined;
    thisMonth!: number | undefined;
    debit!: number | undefined;
    credit!: number | undefined;

    constructor(data?: ISubLedgerTrial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg1ID = data["seg1ID"];
            this.seg1Name = data["seg1Name"];
            this.seg2ID = data["seg2ID"];
            this.seg2Name = data["seg2Name"];
            this.seg3ID = data["seg3ID"];
            this.seg3Name = data["seg3Name"];
            this.accountID = data["accountID"];
            this.accountName = data["accountName"];
            this.subAccID = data["subAccID"];
            this.subAccName = data["subAccName"];
            this.subLedger = data["subLedger"];
            this.family = data["family"];
            this.opn = data["opn"];
            this.cur = data["cur"];
            this.thisMonth = data["thisMonth"];
            this.debit = data["debit"];
            this.credit = data["credit"];
        }
    }

    static fromJS(data: any): SubLedgerTrial {
        data = typeof data === 'object' ? data : {};
        let result = new SubLedgerTrial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg1ID"] = this.seg1ID;
        data["seg1Name"] = this.seg1Name;
        data["seg2ID"] = this.seg2ID;
        data["seg2Name"] = this.seg2Name;
        data["seg3ID"] = this.seg3ID;
        data["seg3Name"] = this.seg3Name;
        data["accountID"] = this.accountID;
        data["accountName"] = this.accountName;
        data["subAccID"] = this.subAccID;
        data["subAccName"] = this.subAccName;
        data["subLedger"] = this.subLedger;
        data["family"] = this.family;
        data["opn"] = this.opn;
        data["cur"] = this.cur;
        data["thisMonth"] = this.thisMonth;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        return data;
    }
}

export interface ISubLedgerTrial {
    seg1ID: string | undefined;
    seg1Name: string | undefined;
    seg2ID: string | undefined;
    seg2Name: string | undefined;
    seg3ID: string | undefined;
    seg3Name: string | undefined;
    accountID: string | undefined;
    accountName: string | undefined;
    subAccID: number | undefined;
    subAccName: string | undefined;
    subLedger: boolean | undefined;
    family: string | undefined;
    opn: number | undefined;
    cur: number | undefined;
    thisMonth: number | undefined;
    debit: number | undefined;
    credit: number | undefined;
}

export class PagedResultDtoOfGetTaxAuthorityForViewDto implements IPagedResultDtoOfGetTaxAuthorityForViewDto {
    totalCount!: number | undefined;
    items!: GetTaxAuthorityForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTaxAuthorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTaxAuthorityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTaxAuthorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTaxAuthorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTaxAuthorityForViewDto {
    totalCount: number | undefined;
    items: GetTaxAuthorityForViewDto[] | undefined;
}

export class GetTaxAuthorityForViewDto implements IGetTaxAuthorityForViewDto {
    taxAuthority!: TaxAuthorityDto | undefined;
    companyProfileId!: string | undefined;

    constructor(data?: IGetTaxAuthorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taxAuthority = data["taxAuthority"] ? TaxAuthorityDto.fromJS(data["taxAuthority"]) : <any>undefined;
            this.companyProfileId = data["companyProfileId"];
        }
    }

    static fromJS(data: any): GetTaxAuthorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaxAuthorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxAuthority"] = this.taxAuthority ? this.taxAuthority.toJSON() : <any>undefined;
        data["companyProfileId"] = this.companyProfileId;
        return data;
    }
}

export interface IGetTaxAuthorityForViewDto {
    taxAuthority: TaxAuthorityDto | undefined;
    companyProfileId: string | undefined;
}

export class TaxAuthorityDto implements ITaxAuthorityDto {
    cmpid!: string | undefined;
    taxauthdesc!: string | undefined;
    accliability!: string | undefined;
    accrecoverable!: string | undefined;
    recoverrate!: number | undefined;
    accexpense!: string | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    companyId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ITaxAuthorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cmpid = data["cmpid"];
            this.taxauthdesc = data["taxauthdesc"];
            this.accliability = data["accliability"];
            this.accrecoverable = data["accrecoverable"];
            this.recoverrate = data["recoverrate"];
            this.accexpense = data["accexpense"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.companyId = data["companyId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TaxAuthorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxAuthorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cmpid"] = this.cmpid;
        data["taxauthdesc"] = this.taxauthdesc;
        data["accliability"] = this.accliability;
        data["accrecoverable"] = this.accrecoverable;
        data["recoverrate"] = this.recoverrate;
        data["accexpense"] = this.accexpense;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxAuthorityDto {
    cmpid: string | undefined;
    taxauthdesc: string | undefined;
    accliability: string | undefined;
    accrecoverable: string | undefined;
    recoverrate: number | undefined;
    accexpense: string | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    companyId: string | undefined;
    id: string | undefined;
}

export class GetTaxAuthorityForEditOutput implements IGetTaxAuthorityForEditOutput {
    taxAuthority!: CreateOrEditTaxAuthorityDto | undefined;

    constructor(data?: IGetTaxAuthorityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taxAuthority = data["taxAuthority"] ? CreateOrEditTaxAuthorityDto.fromJS(data["taxAuthority"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTaxAuthorityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaxAuthorityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxAuthority"] = this.taxAuthority ? this.taxAuthority.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetTaxAuthorityForEditOutput {
    taxAuthority: CreateOrEditTaxAuthorityDto | undefined;
}

export class CreateOrEditTaxAuthorityDto implements ICreateOrEditTaxAuthorityDto {
    taxauthdesc!: string;
    flag!: boolean | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditTaxAuthorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taxauthdesc = data["taxauthdesc"];
            this.flag = data["flag"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTaxAuthorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTaxAuthorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxauthdesc"] = this.taxauthdesc;
        data["flag"] = this.flag;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTaxAuthorityDto {
    taxauthdesc: string;
    flag: boolean | undefined;
    id: string | undefined;
}

export class PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto implements IPagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto {
    totalCount!: number | undefined;
    items!: TaxAuthorityCompanyProfileLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TaxAuthorityCompanyProfileLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTaxAuthorityCompanyProfileLookupTableDto {
    totalCount: number | undefined;
    items: TaxAuthorityCompanyProfileLookupTableDto[] | undefined;
}

export class TaxAuthorityCompanyProfileLookupTableDto implements ITaxAuthorityCompanyProfileLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ITaxAuthorityCompanyProfileLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TaxAuthorityCompanyProfileLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxAuthorityCompanyProfileLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITaxAuthorityCompanyProfileLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetTaxClassForViewDto implements IPagedResultDtoOfGetTaxClassForViewDto {
    totalCount!: number | undefined;
    items!: GetTaxClassForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTaxClassForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetTaxClassForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTaxClassForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTaxClassForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTaxClassForViewDto {
    totalCount: number | undefined;
    items: GetTaxClassForViewDto[] | undefined;
}

export class GetTaxClassForViewDto implements IGetTaxClassForViewDto {
    taxClass!: TaxClassDto | undefined;
    taxAuthorityTAXAUTH!: string | undefined;

    constructor(data?: IGetTaxClassForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taxClass = data["taxClass"] ? TaxClassDto.fromJS(data["taxClass"]) : <any>undefined;
            this.taxAuthorityTAXAUTH = data["taxAuthorityTAXAUTH"];
        }
    }

    static fromJS(data: any): GetTaxClassForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaxClassForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxClass"] = this.taxClass ? this.taxClass.toJSON() : <any>undefined;
        data["taxAuthorityTAXAUTH"] = this.taxAuthorityTAXAUTH;
        return data;
    }
}

export interface IGetTaxClassForViewDto {
    taxClass: TaxClassDto | undefined;
    taxAuthorityTAXAUTH: string | undefined;
}

export class TaxClassDto implements ITaxClassDto {
    taxauth!: string | undefined;
    classdesc!: string | undefined;
    classrate!: number | undefined;
    transtype!: number | undefined;
    classtype!: string | undefined;
    taxaccid!: string | undefined;
    taxaccdesc!: string | undefined;
    isActive!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITaxClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taxauth = data["taxauth"];
            this.classdesc = data["classdesc"];
            this.classrate = data["classrate"];
            this.transtype = data["transtype"];
            this.classtype = data["classtype"];
            this.taxaccid = data["taxaccid"];
            this.taxaccdesc = data["taxaccdesc"];
            this.isActive = data["isActive"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TaxClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxauth"] = this.taxauth;
        data["classdesc"] = this.classdesc;
        data["classrate"] = this.classrate;
        data["transtype"] = this.transtype;
        data["classtype"] = this.classtype;
        data["taxaccid"] = this.taxaccid;
        data["taxaccdesc"] = this.taxaccdesc;
        data["isActive"] = this.isActive;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        return data;
    }
}

export interface ITaxClassDto {
    taxauth: string | undefined;
    classdesc: string | undefined;
    classrate: number | undefined;
    transtype: number | undefined;
    classtype: string | undefined;
    taxaccid: string | undefined;
    taxaccdesc: string | undefined;
    isActive: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class GetTaxClassForEditOutput implements IGetTaxClassForEditOutput {
    taxClass!: CreateOrEditTaxClassDto | undefined;
    taxAuthorityTAXAUTH!: string | undefined;
    taxAccDesc: string | undefined;
    constructor(data?: IGetTaxClassForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.taxClass = data["taxClass"] ? CreateOrEditTaxClassDto.fromJS(data["taxClass"]) : <any>undefined;
			this.taxAuthorityTAXAUTH = data["taxAuthorityTAXAUTH"];
			this.taxAccDesc = data["taxAccDesc"];
        }
    }

    static fromJS(data: any): GetTaxClassForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTaxClassForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taxClass"] = this.taxClass ? this.taxClass.toJSON() : <any>undefined;
		data["taxAuthorityTAXAUTH"] = this.taxAuthorityTAXAUTH;
		data["taxAccDesc"] = this.taxAccDesc;
        return data;
    }
}

export interface IGetTaxClassForEditOutput {
    taxClass: CreateOrEditTaxClassDto | undefined;
	taxAuthorityTAXAUTH: string | undefined;
	taxAccDesc: string | undefined;
}

export class CreateOrEditTaxClassDto implements ICreateOrEditTaxClassDto {
    classid!: number | undefined;
    taxauth!: string | undefined;
    classdesc!: string | undefined;
    classrate!: number | undefined;
    transtype!: number | undefined;
    classtype!: string | undefined;
    taxaccid!: string | undefined;
    isActive!: boolean | undefined;
    audtdate!: moment.Moment | undefined;
    audtuser!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditTaxClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.classid = data["classid"];
            this.taxauth = data["taxauth"];
            this.classdesc = data["classdesc"];
            this.classrate = data["classrate"];
            this.transtype = data["transtype"];
            this.classtype = data["classtype"];
            this.taxaccid = data["taxaccid"];
            this.isActive = data["isActive"];
            this.audtdate = data["audtdate"] ? moment(data["audtdate"].toString()) : <any>undefined;
            this.audtuser = data["audtuser"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTaxClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTaxClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["classid"] = this.classid;
        data["taxauth"] = this.taxauth;
        data["classdesc"] = this.classdesc;
        data["classrate"] = this.classrate;
        data["transtype"] = this.transtype;
        data["classtype"] = this.classtype;
        data["taxaccid"] = this.taxaccid;
        data["isActive"] = this.isActive;
        data["audtdate"] = this.audtdate ? this.audtdate.toISOString() : <any>undefined;
        data["audtuser"] = this.audtuser;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTaxClassDto {
    classid: number | undefined;
    taxauth: string | undefined;
    classdesc: string | undefined;
    classrate: number | undefined;
    transtype: number | undefined;
    classtype: string | undefined;
    taxaccid: string | undefined;
    isActive: boolean | undefined;
    audtdate: moment.Moment | undefined;
    audtuser: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto implements IPagedResultDtoOfTaxClassTaxAuthorityLookupTableDto {
    totalCount!: number | undefined;
    items!: TaxClassTaxAuthorityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTaxClassTaxAuthorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TaxClassTaxAuthorityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTaxClassTaxAuthorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTaxClassTaxAuthorityLookupTableDto {
    totalCount: number | undefined;
    items: TaxClassTaxAuthorityLookupTableDto[] | undefined;
}

export class TaxClassTaxAuthorityLookupTableDto implements ITaxClassTaxAuthorityLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ITaxClassTaxAuthorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): TaxClassTaxAuthorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TaxClassTaxAuthorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITaxClassTaxAuthorityLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [] as any;
                for (let item of data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number | undefined;
    closed!: number | undefined;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number | undefined;
    newFeedbacks!: number | undefined;
    newOrders!: number | undefined;
    newUsers!: number | undefined;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number | undefined;
    revenue!: number | undefined;
    expenses!: number | undefined;
    growth!: number | undefined;
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;
    cashBalance!: number | undefined;
    bankBalance!: number | undefined;
    totalBalance!: number | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            this.cashBalance = data["cashBalance"];
            this.bankBalance = data["bankBalance"];
            this.totalBalance = data["totalBalance"];

            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [] as any;
                for (let item of data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [] as any;
                for (let item of data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        data["cashBalance"] = this.cashBalance;
        data["bankBalance"] = this.bankBalance;
        data["totalBalance"] = this.totalBalance;

        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
    cashBalance: number | undefined;
    bankBalance: number | undefined;
    totalBalance: number | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number | undefined;
    profit!: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [] as any;
                for (let item of data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number | undefined;
    change!: number[] | undefined;
    averagePrice!: number | undefined;
    totalPrice!: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [] as any;
                for (let item of data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class GetCashFlowSummaryInput implements IGetCashFlowSummaryInput {
    cashFlowSummaryDatePeriod!: CashFlowSummaryDatePeriod | undefined;

    constructor(data?: IGetCashFlowSummaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cashFlowSummaryDatePeriod = data["cashFlowSummaryDatePeriod"];
        }
    }

    static fromJS(data: any): GetCashFlowSummaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCashFlowSummaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cashFlowSummaryDatePeriod"] = this.cashFlowSummaryDatePeriod;
        return data;
    }
}

export interface IGetCashFlowSummaryInput {
    cashFlowSummaryDatePeriod: CashFlowSummaryDatePeriod | undefined;
}

export enum CashFlowSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class ListResultDtoOfCashFlowSummary implements IListResultDtoOfCashFlowSummary {
    items!: CashFlowSummary[] | undefined;

    constructor(data?: IListResultDtoOfCashFlowSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CashFlowSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCashFlowSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCashFlowSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCashFlowSummary {
    items: CashFlowSummary[] | undefined;
}

export class CashFlowSummary implements ICashFlowSummary {
    accountName!: string | undefined;
    docDate!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;

    constructor(data?: ICashFlowSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountName = data["accountName"];
            this.docDate = data["docDate"];
            this.debit = data["debit"];
            this.credit = data["credit"];
        }
    }

    static fromJS(data: any): CashFlowSummary {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["docDate"] = this.docDate;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        return data;
    }
}

export interface ICashFlowSummary {
    accountName: string | undefined;
    docDate: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
}

export class GetBankStatusSummaryInput implements IGetBankStatusSummaryInput {
    bankStatusSummaryDatePeriod!: BankStatusSummaryDatePeriod | undefined;

    constructor(data?: IGetBankStatusSummaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bankStatusSummaryDatePeriod = data["bankStatusSummaryDatePeriod"];
        }
    }

    static fromJS(data: any): GetBankStatusSummaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBankStatusSummaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankStatusSummaryDatePeriod"] = this.bankStatusSummaryDatePeriod;
        return data;
    }
}

export interface IGetBankStatusSummaryInput {
    bankStatusSummaryDatePeriod: BankStatusSummaryDatePeriod | undefined;
}

export enum BankStatusSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class ListResultDtoOfBankStatusSummary implements IListResultDtoOfBankStatusSummary {
    items!: BankStatusSummary[] | undefined;

    constructor(data?: IListResultDtoOfBankStatusSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BankStatusSummary.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfBankStatusSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfBankStatusSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfBankStatusSummary {
    items: BankStatusSummary[] | undefined;
}

export class BankStatusSummary implements IBankStatusSummary {
    accountName!: string | undefined;
    docDate!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;

    constructor(data?: IBankStatusSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountName = data["accountName"];
            this.docDate = data["docDate"];
            this.debit = data["debit"];
            this.credit = data["credit"];
        }
    }

    static fromJS(data: any): BankStatusSummary {
        data = typeof data === 'object' ? data : {};
        let result = new BankStatusSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountName"] = this.accountName;
        data["docDate"] = this.docDate;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        return data;
    }
}

export interface IBankStatusSummary {
    accountName: string | undefined;
    docDate: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType | undefined;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean | undefined;
    isActive!: boolean | undefined;
    isEmailConfirmationRequired!: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;
    tenantEditionId!: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [] as any;
                for (let item of data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [] as any;
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType | undefined;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto | undefined;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;
    otherSettings!: TenantOtherSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    waitingForActivation!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class TrialBalanceDto implements ITrialBalanceDto {
    seg1!: string | undefined;
    seg2!: string | undefined;
    seg3!: string | undefined;
    accountId!: string | undefined;
    seg1Name!: string | undefined;
    seg2Name!: string | undefined;
    seg3Name!: string | undefined;
    accountName!: string | undefined;
    family!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    openingDebit!: number | undefined;
    openingCredit!: number | undefined;
    sl!: boolean | undefined;
    locId!: number | undefined;
    locDesc!: string | undefined;

    constructor(data?: ITrialBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seg1 = data["seg1"];
            this.seg2 = data["seg2"];
            this.seg3 = data["seg3"];
            this.accountId = data["accountId"];
            this.seg1Name = data["seg1Name"];
            this.seg2Name = data["seg2Name"];
            this.seg3Name = data["seg3Name"];
            this.accountName = data["accountName"];
            this.family = data["family"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.openingDebit = data["openingDebit"];
            this.openingCredit = data["openingCredit"];
            this.sl = data["sl"];
            this.locId = data["locId"];
            this.locDesc = data["locDesc"];
        }
    }

    static fromJS(data: any): TrialBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TrialBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seg1"] = this.seg1;
        data["seg2"] = this.seg2;
        data["seg3"] = this.seg3;
        data["accountId"] = this.accountId;
        data["seg1Name"] = this.seg1Name;
        data["seg2Name"] = this.seg2Name;
        data["seg3Name"] = this.seg3Name;
        data["accountName"] = this.accountName;
        data["family"] = this.family;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["openingDebit"] = this.openingDebit;
        data["openingCredit"] = this.openingCredit;
        data["sl"] = this.sl;
        data["locId"] = this.locId;
        data["locDesc"] = this.locDesc;
        return data;
    }
}

export interface ITrialBalanceDto {
    seg1: string | undefined;
    seg2: string | undefined;
    seg3: string | undefined;
    accountId: string | undefined;
    seg1Name: string | undefined;
    seg2Name: string | undefined;
    seg3Name: string | undefined;
    accountName: string | undefined;
    family: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    openingDebit: number | undefined;
    openingCredit: number | undefined;
    sl: boolean | undefined;
    locId: number | undefined;
    locDesc: string | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data;
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class ListResultDtoOfGetVenderActivityForViewDto implements IListResultDtoOfGetVenderActivityForViewDto {
    items!: GetVenderActivityForViewDto[] | undefined;

    constructor(data?: IListResultDtoOfGetVenderActivityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVenderActivityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetVenderActivityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetVenderActivityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetVenderActivityForViewDto {
    items: GetVenderActivityForViewDto[] | undefined;
}

export class GetVenderActivityForViewDto implements IGetVenderActivityForViewDto {
    venderActivity!: VenderActivityDto | undefined;
    openingBalance!: number | undefined;
    outstandingBalance!: number | undefined;
    lastPayment!: number | undefined;

    constructor(data?: IGetVenderActivityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.venderActivity = data["venderActivity"] ? VenderActivityDto.fromJS(data["venderActivity"]) : <any>undefined;
            this.openingBalance = data["openingBalance"];
            this.outstandingBalance = data["outstandingBalance"];
            this.lastPayment = data["lastPayment"];
        }
    }

    static fromJS(data: any): GetVenderActivityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVenderActivityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["venderActivity"] = this.venderActivity ? this.venderActivity.toJSON() : <any>undefined;
        data["openingBalance"] = this.openingBalance;
        data["outstandingBalance"] = this.outstandingBalance;
        data["lastPayment"] = this.lastPayment;
        return data;
    }
}

export interface IGetVenderActivityForViewDto {
    venderActivity: VenderActivityDto | undefined;
    openingBalance: number | undefined;
    outstandingBalance: number | undefined;
    lastPayment: number | undefined;
}

export class VenderActivityDto implements IVenderActivityDto {
    docDate!: moment.Moment | undefined;
    type!: string | undefined;
    docNo!: number | undefined;
    narration!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    runningTotal!: number | undefined;

    constructor(data?: IVenderActivityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.docDate = data["docDate"] ? moment(data["docDate"].toString()) : <any>undefined;
            this.type = data["type"];
            this.docNo = data["docNo"];
            this.narration = data["narration"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.runningTotal = data["runningTotal"];
        }
    }

    static fromJS(data: any): VenderActivityDto {
        data = typeof data === 'object' ? data : {};
        let result = new VenderActivityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["docDate"] = this.docDate ? this.docDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["docNo"] = this.docNo;
        data["narration"] = this.narration;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["runningTotal"] = this.runningTotal;
        return data;
    }
}

export interface IVenderActivityDto {
    docDate: moment.Moment | undefined;
    type: string | undefined;
    docNo: number | undefined;
    narration: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    runningTotal: number | undefined;
}

export class VoucherEntryDto implements IVoucherEntryDto {
    gltrHeader!: CreateOrEditGLTRHeaderDto | undefined;
    gltrDetail!: CreateOrEditGLTRDetailDto[] | undefined;

    constructor(data?: IVoucherEntryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gltrHeader = data["gltrHeader"] ? CreateOrEditGLTRHeaderDto.fromJS(data["gltrHeader"]) : <any>undefined;
            if (data["gltrDetail"] && data["gltrDetail"].constructor === Array) {
                this.gltrDetail = [] as any;
                for (let item of data["gltrDetail"])
                    this.gltrDetail!.push(CreateOrEditGLTRDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VoucherEntryDto {
        data = typeof data === 'object' ? data : {};
        let result = new VoucherEntryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gltrHeader"] = this.gltrHeader ? this.gltrHeader : <any>undefined;
        if (this.gltrDetail && this.gltrDetail.constructor === Array) {
            data["gltrDetail"] = [];
            for (let item of this.gltrDetail)
                data["gltrDetail"].push(item);
        }
        return data;
    }
}

export interface IVoucherEntryDto {
    gltrHeader: CreateOrEditGLTRHeaderDto | undefined;
    gltrDetail: CreateOrEditGLTRDetailDto[] | undefined;
}

export class BooksDetailsDto implements IBooksDetailsDto {
    bookID!: string | undefined;
    bookName!: string | undefined;

    constructor(data?: IBooksDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bookID = data["bookID"];
            this.bookName = data["bookName"];
        }
    }

    static fromJS(data: any): BooksDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BooksDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookID"] = this.bookID;
        data["bookName"] = this.bookName;
        return data;
    }
}

export interface IBooksDetailsDto {
    bookID: string | undefined;
    bookName: string | undefined;
}

export class VoucherPrint implements IVoucherPrint {
    accountId!: string | undefined;
    detId!: number | undefined;
    bookId!: string | undefined;
    docNo!: number | undefined;
    accountName!: string | undefined;
    subAcName!: string | undefined;
    narration!: string | undefined;
    debit!: number | undefined;
    credit!: number | undefined;
    sumDebit!: number | undefined;
    sumCredit!: number | undefined;
    posted!: string | undefined;
    docDate!: string | undefined;

    constructor(data?: IVoucherPrint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.detId = data["detId"];
            this.bookId = data["bookId"];
            this.docNo = data["docNo"];
            this.accountName = data["accountName"];
            this.subAcName = data["subAcName"];
            this.narration = data["narration"];
            this.debit = data["debit"];
            this.credit = data["credit"];
            this.sumDebit = data["sumDebit"];
            this.sumCredit = data["sumCredit"];
            this.posted = data["posted"];
            this.docDate = data["docDate"];
        }
    }

    static fromJS(data: any): VoucherPrint {
        data = typeof data === 'object' ? data : {};
        let result = new VoucherPrint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["detId"] = this.detId;
        data["bookId"] = this.bookId;
        data["docNo"] = this.docNo;
        data["accountName"] = this.accountName;
        data["subAcName"] = this.subAcName;
        data["narration"] = this.narration;
        data["debit"] = this.debit;
        data["credit"] = this.credit;
        data["sumDebit"] = this.sumDebit;
        data["sumCredit"] = this.sumCredit;
        data["posted"] = this.posted;
        data["docDate"] = this.docDate;
        return data;
    }
}

export interface IVoucherPrint {
    accountId: string | undefined;
    detId: number | undefined;
    bookId: string | undefined;
    docNo: number | undefined;
    accountName: string | undefined;
    subAcName: string | undefined;
    narration: string | undefined;
    debit: number | undefined;
    credit: number | undefined;
    sumDebit: number | undefined;
    sumCredit: number | undefined;
    posted: string | undefined;
    docDate: string | undefined;
}

export class ChartofAccountdto implements IChartofAccountdto {
    accountId!: string | undefined;
    accountName!: string | undefined;
    seg1!: string | undefined;
    segName!: string | undefined;
    seg2!: string | undefined;
    seg2Name!: string | undefined;
    seg3!: string | undefined;
    seg3Name!: string | undefined;
    family!: string | undefined;
    subLedger!: string | undefined;

    constructor(data?: IChartofAccountdto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.seg1 = data["seg1"];
            this.segName = data["segName"];
            this.seg2 = data["seg2"];
            this.seg2Name = data["seg2Name"];
            this.seg3 = data["seg3"];
            this.seg3Name = data["seg3Name"];
            this.family = data["family"];
            this.subLedger = data["subLedger"];
        }
    }

    static fromJS(data: any): ChartofAccountdto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartofAccountdto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["seg1"] = this.seg1;
        data["segName"] = this.segName;
        data["seg2"] = this.seg2;
        data["seg2Name"] = this.seg2Name;
        data["seg3"] = this.seg3;
        data["seg3Name"] = this.seg3Name;
        data["family"] = this.family;
        data["subLedger"] = this.subLedger;
        return data;
    }
}

export interface IChartofAccountdto {
    accountId: string | undefined;
    accountName: string | undefined;
    seg1: string | undefined;
    segName: string | undefined;
    seg2: string | undefined;
    seg2Name: string | undefined;
    seg3: string | undefined;
    seg3Name: string | undefined;
    family: string | undefined;
    subLedger: string | undefined;
}

export class AccountsAging implements IAccountsAging {
    accountId!: string | undefined;
    accountName!: string | undefined;
    subId!: number | undefined;
    subAccountTitle!: string | undefined;
    balance!: number | undefined;
    a1!: number | undefined;
    a2!: number | undefined;
    a3!: number | undefined;
    a4!: number | undefined;
    a5!: number | undefined;

    constructor(data?: IAccountsAging) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountId = data["accountId"];
            this.accountName = data["accountName"];
            this.subId = data["subId"];
            this.subAccountTitle = data["subAccountTitle"];
            this.balance = data["balance"];
            this.a1 = data["a1"];
            this.a2 = data["a2"];
            this.a3 = data["a3"];
            this.a4 = data["a4"];
            this.a5 = data["a5"];
        }
    }

    static fromJS(data: any): AccountsAging {
        data = typeof data === 'object' ? data : {};
        let result = new AccountsAging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["subId"] = this.subId;
        data["subAccountTitle"] = this.subAccountTitle;
        data["balance"] = this.balance;
        data["a1"] = this.a1;
        data["a2"] = this.a2;
        data["a3"] = this.a3;
        data["a4"] = this.a4;
        data["a5"] = this.a5;
        return data;
    }
}

export interface IAccountsAging {
    accountId: string | undefined;
    accountName: string | undefined;
    subId: number | undefined;
    subAccountTitle: string | undefined;
    balance: number | undefined;
    a1: number | undefined;
    a2: number | undefined;
    a3: number | undefined;
    a4: number | undefined;
    a5: number | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; } | undefined;
    stripe!: { [key: string]: string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data;
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; } | undefined;
    stripe: { [key: string]: string; } | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

export function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

export function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
